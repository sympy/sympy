

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.simplify.simplify &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.simplify.simplify</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">SYMPY_DEBUG</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Basic</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span>
    <span class="n">Derivative</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">expand</span><span class="p">,</span> <span class="n">expand_mul</span><span class="p">,</span> <span class="n">expand_func</span><span class="p">,</span>
    <span class="n">Function</span><span class="p">,</span> <span class="n">Equality</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">count_ops</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">factor_terms</span><span class="p">,</span>
    <span class="n">expand_multinomial</span><span class="p">,</span> <span class="n">FunctionClass</span><span class="p">,</span> <span class="n">expand_power_base</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">igcd</span><span class="p">,</span>
    <span class="n">expand_power_exp</span><span class="p">,</span> <span class="n">expand_log</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="kn">import</span> <span class="n">_unevaluated_Add</span>
<span class="kn">from</span> <span class="nn">sympy.core.cache</span> <span class="kn">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">iterable</span><span class="p">,</span> <span class="nb">reduce</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="nb">xrange</span>
<span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">Factors</span><span class="p">,</span> <span class="n">gcd_terms</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Number</span><span class="p">,</span> <span class="n">I</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">expand_log</span><span class="p">,</span> <span class="n">count_ops</span>
<span class="kn">from</span> <span class="nn">sympy.core.mul</span> <span class="kn">import</span> <span class="n">_keep_coeff</span><span class="p">,</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">sympy.core.rules</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">gamma</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">,</span>
    <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cot</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">coth</span><span class="p">,</span> <span class="n">piecewise_fold</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.integers</span> <span class="kn">import</span> <span class="n">ceiling</span>

<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">has_variety</span><span class="p">,</span> <span class="n">sift</span>

<span class="kn">from</span> <span class="nn">sympy.simplify.cse_main</span> <span class="kn">import</span> <span class="n">cse</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.cse_opts</span> <span class="kn">import</span> <span class="n">sub_pre</span><span class="p">,</span> <span class="n">sub_post</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.sqrtdenest</span> <span class="kn">import</span> <span class="n">sqrtdenest</span>
<span class="kn">from</span> <span class="nn">sympy.ntheory.factor_</span> <span class="kn">import</span> <span class="n">multiplicity</span>

<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Poly</span><span class="p">,</span> <span class="n">together</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span>
    <span class="n">ComputationFailed</span><span class="p">,</span> <span class="n">lcm</span><span class="p">,</span> <span class="n">gcd</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">sympy.mpmath</span> <span class="kn">as</span> <span class="nn">mpmath</span>


<span class="k">def</span> <span class="nf">_mexpand</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>


<div class="viewcode-block" id="fraction"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.fraction">[docs]</a><span class="k">def</span> <span class="nf">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a pair with expression&#39;s numerator and denominator.</span>
<span class="sd">       If the given expression is not a fraction then this function</span>
<span class="sd">       will return the tuple (expr, 1).</span>

<span class="sd">       This function will not make any attempt to simplify nested</span>
<span class="sd">       fractions or to do any term rewriting at all.</span>

<span class="sd">       If only one of the numerator/denominator pair is needed then</span>
<span class="sd">       use numer(expr) or denom(expr) functions respectively.</span>

<span class="sd">       &gt;&gt;&gt; from sympy import fraction, Rational, Symbol</span>
<span class="sd">       &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">       &gt;&gt;&gt; fraction(x/y)</span>
<span class="sd">       (x, y)</span>
<span class="sd">       &gt;&gt;&gt; fraction(x)</span>
<span class="sd">       (x, 1)</span>

<span class="sd">       &gt;&gt;&gt; fraction(1/y**2)</span>
<span class="sd">       (1, y**2)</span>

<span class="sd">       &gt;&gt;&gt; fraction(x*y/2)</span>
<span class="sd">       (x*y, 2)</span>
<span class="sd">       &gt;&gt;&gt; fraction(Rational(1, 2))</span>
<span class="sd">       (1, 2)</span>

<span class="sd">       This function will also work fine with assumptions:</span>

<span class="sd">       &gt;&gt;&gt; k = Symbol(&#39;k&#39;, negative=True)</span>
<span class="sd">       &gt;&gt;&gt; fraction(x * y**k)</span>
<span class="sd">       (x, y**(-k))</span>

<span class="sd">       If we know nothing about sign of some exponent and &#39;exact&#39;</span>
<span class="sd">       flag is unset, then structure this exponent&#39;s structure will</span>
<span class="sd">       be analyzed and pretty fraction will be returned:</span>

<span class="sd">       &gt;&gt;&gt; from sympy import exp</span>
<span class="sd">       &gt;&gt;&gt; fraction(2*x**(-y))</span>
<span class="sd">       (2, x**y)</span>

<span class="sd">       &gt;&gt;&gt; fraction(exp(-x))</span>
<span class="sd">       (1, exp(x))</span>

<span class="sd">       &gt;&gt;&gt; fraction(exp(-x), exact=True)</span>
<span class="sd">       (exp(-x), 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">term</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">):</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ex</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">ex</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">exact</span> <span class="ow">and</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">numer</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">denom</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">numer</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">denom</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">fraction_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">numer_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">numer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">denom_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">denom</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>

<span class="n">expand_numer</span> <span class="o">=</span> <span class="n">numer_expand</span>
<span class="n">expand_denom</span> <span class="o">=</span> <span class="n">denom_expand</span>
<span class="n">expand_fraction</span> <span class="o">=</span> <span class="n">fraction_expand</span>


<div class="viewcode-block" id="separate"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.separate">[docs]</a><span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deprecated wrapper for ``expand_power_base()``.  Use that function instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.utilities.exceptions</span> <span class="kn">import</span> <span class="n">SymPyDeprecationWarning</span>
    <span class="n">SymPyDeprecationWarning</span><span class="p">(</span>
        <span class="n">feature</span><span class="o">=</span><span class="s">&quot;separate()&quot;</span><span class="p">,</span> <span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;expand_power_base()&quot;</span><span class="p">,</span> <span class="n">issue</span><span class="o">=</span><span class="mi">3383</span><span class="p">,</span>
        <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s">&quot;0.7.2&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;Note: in separate() deep &quot;</span>
        <span class="s">&quot;defaults to False, whereas in expand_power_base(), &quot;</span>
        <span class="s">&quot;deep defaults to True.&quot;</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="collect"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.collect">[docs]</a><span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect additive terms of an expression.</span>

<span class="sd">    This function collects additive terms of an expression with respect</span>
<span class="sd">    to a list of expression up to powers with rational exponents. By the</span>
<span class="sd">    term symbol here are meant arbitrary expressions, which can contain</span>
<span class="sd">    powers, products, sums etc. In other words symbol is a pattern which</span>
<span class="sd">    will be searched for in the expression&#39;s terms.</span>

<span class="sd">    The input expression is not expanded by :func:`collect`, so user is</span>
<span class="sd">    expected to provide an expression is an appropriate form. This makes</span>
<span class="sd">    :func:`collect` more predictable as there is no magic happening behind the</span>
<span class="sd">    scenes. However, it is important to note, that powers of products are</span>
<span class="sd">    converted to products of powers using the :func:`expand_power_base`</span>
<span class="sd">    function.</span>

<span class="sd">    There are two possible types of output. First, if ``evaluate`` flag is</span>
<span class="sd">    set, this function will return an expression with collected terms or</span>
<span class="sd">    else it will return a dictionary with expressions up to rational powers</span>
<span class="sd">    as keys and collected coefficients as values.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import S, collect, expand, factor, Wild</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, c, x, y, z</span>

<span class="sd">    This function can collect symbolic coefficients in polynomials or</span>
<span class="sd">    rational expressions. It will manage to find all integer or rational</span>
<span class="sd">    powers of collection variable::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**2 + b*x**2 + a*x - b*x + c, x)</span>
<span class="sd">        c + x**2*(a + b) + x*(a - b)</span>

<span class="sd">    The same result can be achieved in dictionary form::</span>

<span class="sd">        &gt;&gt;&gt; d = collect(a*x**2 + b*x**2 + a*x - b*x + c, x, evaluate=False)</span>
<span class="sd">        &gt;&gt;&gt; d[x**2]</span>
<span class="sd">        a + b</span>
<span class="sd">        &gt;&gt;&gt; d[x]</span>
<span class="sd">        a - b</span>
<span class="sd">        &gt;&gt;&gt; d[S.One]</span>
<span class="sd">        c</span>

<span class="sd">    You can also work with multivariate polynomials. However, remember that</span>
<span class="sd">    this function is greedy so it will care only about a single symbol at time,</span>
<span class="sd">    in specification order::</span>

<span class="sd">        &gt;&gt;&gt; collect(x**2 + y*x**2 + x*y + y + a*y, [x, y])</span>
<span class="sd">        x**2*(y + 1) + x*y + y*(a + 1)</span>

<span class="sd">    Also more complicated expressions can be used as patterns::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, log</span>
<span class="sd">        &gt;&gt;&gt; collect(a*sin(2*x) + b*sin(2*x), sin(2*x))</span>
<span class="sd">        (a + b)*sin(2*x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x*log(x) + b*(x*log(x)), x*log(x))</span>
<span class="sd">        x*(a + b)*log(x)</span>

<span class="sd">    You can use wildcards in the pattern::</span>

<span class="sd">        &gt;&gt;&gt; w = Wild(&#39;w1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**y - b*x**y, w**y)</span>
<span class="sd">        x**y*(a - b)</span>

<span class="sd">    It is also possible to work with symbolic powers, although it has more</span>
<span class="sd">    complicated behavior, because in this case power&#39;s base and symbolic part</span>
<span class="sd">    of the exponent are treated as a single symbol::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**c + b*x**c, x)</span>
<span class="sd">        a*x**c + b*x**c</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**c + b*x**c, x**c)</span>
<span class="sd">        x**c*(a + b)</span>

<span class="sd">    However if you incorporate rationals to the exponents, then you will get</span>
<span class="sd">    well known behavior::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**(2*c) + b*x**(2*c), x**c)</span>
<span class="sd">        x**(2*c)*(a + b)</span>

<span class="sd">    Note also that all previously stated facts about :func:`collect` function</span>
<span class="sd">    apply to the exponential function, so you can get::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import exp</span>
<span class="sd">        &gt;&gt;&gt; collect(a*exp(2*x) + b*exp(2*x), exp(x))</span>
<span class="sd">        (a + b)*exp(2*x)</span>

<span class="sd">    If you are interested only in collecting specific powers of some symbols</span>
<span class="sd">    then set ``exact`` flag in arguments::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**7 + b*x**7, x, exact=True)</span>
<span class="sd">        a*x**7 + b*x**7</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**7 + b*x**7, x**7, exact=True)</span>
<span class="sd">        x**7*(a + b)</span>

<span class="sd">    You can also apply this function to differential equations, where</span>
<span class="sd">    derivatives of arbitrary order can be collected. Note that if you</span>
<span class="sd">    collect with respect to a function or a derivative of a function, all</span>
<span class="sd">    derivatives of that function will also be collected. Use</span>
<span class="sd">    ``exact=True`` to prevent this from happening::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Derivative as D, collect, Function</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;) (x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x), D(f,x))</span>
<span class="sd">        (a + b)*Derivative(f(x), x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), f)</span>
<span class="sd">        (a + b)*Derivative(f(x), x, x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), D(f,x), exact=True)</span>
<span class="sd">        a*Derivative(f(x), x, x) + b*Derivative(f(x), x, x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x) + a*f + b*f, f)</span>
<span class="sd">        (a + b)*f(x) + (a + b)*Derivative(f(x), x)</span>

<span class="sd">    Or you can even match both derivative order and exponent at the same time::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x)**2 + b*D(D(f,x),x)**2, D(f,x))</span>
<span class="sd">        (a + b)*Derivative(f(x), x, x)**2</span>

<span class="sd">    Finally, you can apply a function to each of the collected coefficients.</span>
<span class="sd">    For example you can factorize symbolic coefficients of polynomial::</span>

<span class="sd">        &gt;&gt;&gt; f = expand((x + a + 1)**3)</span>

<span class="sd">        &gt;&gt;&gt; collect(f, x, factor)</span>
<span class="sd">        x**3 + 3*x**2*(a + 1) + 3*x*(a + 1)**2 + (a + 1)**3</span>

<span class="sd">    .. note:: Arguments are expected to be in expanded form, so you might have</span>
<span class="sd">              to call :func:`expand` prior to calling this function.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect_const, collect_sqrt, rcollect</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">make_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="n">product</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">deriv</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">var</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">deriv</span>

                <span class="k">while</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">term</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rat</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="o">*</span><span class="n">sym</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">product</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_derivative</span><span class="p">(</span><span class="n">deriv</span><span class="p">):</span>
        <span class="c"># scan derivatives tower in the input expression and return</span>
        <span class="c"># underlying function and maximal differentiation order</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">deriv</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">deriv</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">deriv</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s">&#39;Improve MV Derivative support in collect&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
            <span class="n">s0</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">s0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s">&#39;Improve MV Derivative support in collect&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">s0</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">Rational</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">parse_term</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses expression expr and outputs tuple (sexpr, rat_expo,</span>
<span class="sd">        sym_expo, deriv)</span>
<span class="sd">        where:</span>
<span class="sd">         - sexpr is the base expression</span>
<span class="sd">         - rat_expo is the rational exponent that sexpr is raised to</span>
<span class="sd">         - sym_expo is the symbolic exponent that sexpr is raised to</span>
<span class="sd">         - deriv contains the derivatives the the expression</span>

<span class="sd">         for example, the output of x would be (x, 1, None, None)</span>
<span class="sd">         the output of 2**x would be (2, 1, x, None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">parse_derivative</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span>

            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">,</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">tail</span><span class="p">),</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
            <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">parse_derivative</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span><span class="p">,</span> <span class="n">deriv</span>

    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse terms searching for a pattern.</span>
<span class="sd">        terms is a list of tuples as returned by parse_terms;</span>
<span class="sd">        pattern is an expression treated as a product of factors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
            <span class="c"># pattern is longer than matched product</span>
            <span class="c"># so no chance for positive parsing result</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_term</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">pattern</span><span class="p">]</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[:]</span>  <span class="c"># need a copy</span>
            <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span> <span class="o">=</span> <span class="p">[],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">e_rat</span><span class="p">,</span> <span class="n">e_sym</span><span class="p">,</span> <span class="n">e_ord</span> <span class="ow">in</span> <span class="n">pattern</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">e_rat</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">e_sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c"># a constant is a match for everything</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">term</span><span class="p">,</span> <span class="n">t_rat</span><span class="p">,</span> <span class="n">t_sym</span><span class="p">,</span> <span class="n">t_ord</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="c"># keeping track of whether one of the terms had</span>
                    <span class="c"># a derivative or not as this will require rebuilding</span>
                    <span class="c"># the expression later</span>
                    <span class="k">if</span> <span class="n">t_ord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">has_deriv</span> <span class="o">=</span> <span class="bp">True</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">t_sym</span> <span class="o">==</span> <span class="n">e_sym</span> <span class="ow">or</span> <span class="n">t_sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="n">e_sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="n">t_sym</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e_sym</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">exact</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="c"># we don&#39;t have to be exact so find common exponent</span>
                            <span class="c"># for both expression&#39;s term and pattern&#39;s element</span>
                            <span class="n">expo</span> <span class="o">=</span> <span class="n">t_rat</span> <span class="o">/</span> <span class="n">e_rat</span>

                            <span class="k">if</span> <span class="n">common_expo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="c"># first time</span>
                                <span class="n">common_expo</span> <span class="o">=</span> <span class="n">expo</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c"># common exponent was negotiated before so</span>
                                <span class="c"># there is no chance for a pattern match unless</span>
                                <span class="c"># common and current exponents are equal</span>
                                <span class="k">if</span> <span class="n">common_expo</span> <span class="o">!=</span> <span class="n">expo</span><span class="p">:</span>
                                    <span class="n">common_expo</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c"># we ought to be exact so all fields of</span>
                            <span class="c"># interest must match in every details</span>
                            <span class="k">if</span> <span class="n">e_rat</span> <span class="o">!=</span> <span class="n">t_rat</span> <span class="ow">or</span> <span class="n">e_ord</span> <span class="o">!=</span> <span class="n">t_ord</span><span class="p">:</span>
                                <span class="k">continue</span>

                        <span class="c"># found common term so remove it from the expression</span>
                        <span class="c"># and try to match next element in the pattern</span>
                        <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

                        <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># pattern element not found</span>
                    <span class="k">return</span> <span class="bp">None</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">_f</span> <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">_f</span><span class="p">],</span> <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span>

    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                <span class="n">collect</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">syms</span><span class="p">):</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)]</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">order_term</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">distribute_order_term</span><span class="p">:</span>
        <span class="n">order_term</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order_term</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">):</span>
                <span class="n">order_term</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>

    <span class="n">summa</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">)]</span>

    <span class="n">collected</span><span class="p">,</span> <span class="n">disliked</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">summa</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_term</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">product</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">SYMPY_DEBUG</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;DEBUG: parsing of expression </span><span class="si">%s</span><span class="s"> with symbol </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">terms</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">symbol</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">parse_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">SYMPY_DEBUG</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;DEBUG: returned </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">,</span> <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span> <span class="o">=</span> <span class="n">result</span>

                <span class="c"># when there was derivative in current pattern we</span>
                <span class="c"># will need to rebuild its expression from scratch</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_deriv</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">e</span> <span class="o">*=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">index</span> <span class="o">*=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">make_expression</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">make_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">),</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">collected</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># none of the patterns matched</span>
            <span class="n">disliked</span> <span class="o">+=</span> <span class="n">product</span>
    <span class="c"># add terms now for each key</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="k">if</span> <span class="n">disliked</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
        <span class="n">collected</span><span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span> <span class="o">=</span> <span class="n">disliked</span>

    <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">collected</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">order_term</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">collected</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">key</span><span class="o">*</span><span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">collected</span>

</div>
<div class="viewcode-block" id="rcollect"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.rcollect">[docs]</a><span class="k">def</span> <span class="nf">rcollect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively collect sums in an expression.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify import rcollect</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">    &gt;&gt;&gt; expr = (x**2*y + x*y + x + y)/(x + y)</span>

<span class="sd">    &gt;&gt;&gt; rcollect(expr, y)</span>
<span class="sd">    (x + y*(x**2 + x + 1))/(x + y)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect, collect_const, collect_sqrt</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="nb">vars</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">rcollect</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

</div>
<div class="viewcode-block" id="separatevars"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.separatevars">[docs]</a><span class="k">def</span> <span class="nf">separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separates variables in an expression, if possible.  By</span>
<span class="sd">    default, it separates with respect to all symbols in an</span>
<span class="sd">    expression and collects constant coefficients that are</span>
<span class="sd">    independent of symbols.</span>

<span class="sd">    If dict=True then the separated terms will be returned</span>
<span class="sd">    in a dictionary keyed to their corresponding symbols.</span>
<span class="sd">    By default, all symbols in the expression will appear as</span>
<span class="sd">    keys; if symbols are provided, then all those symbols will</span>
<span class="sd">    be used as keys, and any terms in the expression containing</span>
<span class="sd">    other symbols or non-symbols will be returned keyed to the</span>
<span class="sd">    string &#39;coeff&#39;. (Passing None for symbols will return the</span>
<span class="sd">    expression in a dictionary keyed to &#39;coeff&#39;.)</span>

<span class="sd">    If force=True, then bases of powers will be separated regardless</span>
<span class="sd">    of assumptions on the symbols involved.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">    The order of the factors is determined by Mul, so that the</span>
<span class="sd">    separated expressions may not necessarily be grouped together.</span>

<span class="sd">    Although factoring is necessary to separate variables in some</span>
<span class="sd">    expressions, it is not necessary in all cases, so one should not</span>
<span class="sd">    count on the returned factors being factored.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z, alpha</span>
<span class="sd">    &gt;&gt;&gt; from sympy import separatevars, sin</span>
<span class="sd">    &gt;&gt;&gt; separatevars((x*y)**y)</span>
<span class="sd">    (x*y)**y</span>
<span class="sd">    &gt;&gt;&gt; separatevars((x*y)**y, force=True)</span>
<span class="sd">    x**y*y**y</span>

<span class="sd">    &gt;&gt;&gt; e = 2*x**2*z*sin(y)+2*z*x**2</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e)</span>
<span class="sd">    2*x**2*z*(sin(y) + 1)</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e, symbols=(x, y), dict=True)</span>
<span class="sd">    {&#39;coeff&#39;: 2*z, x: x**2, y: sin(y) + 1}</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e, [x, y, alpha], dict=True)</span>
<span class="sd">    {&#39;coeff&#39;: 2*z, alpha: 1, x: x**2, y: sin(y) + 1}</span>

<span class="sd">    If the expression is not really separable, or is only partially</span>
<span class="sd">    separable, separatevars will do the best it can to separate it</span>
<span class="sd">    by using factoring.</span>

<span class="sd">    &gt;&gt;&gt; separatevars(x + x*y - 3*x**2)</span>
<span class="sd">    -x*(3*x - y - 1)</span>

<span class="sd">    If the expression is not separable then expr is returned unchanged</span>
<span class="sd">    or (if dict=True) then None is returned.</span>

<span class="sd">    &gt;&gt;&gt; eq = 2*x + y*sin(x)</span>
<span class="sd">    &gt;&gt;&gt; separatevars(eq) == eq</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_separatevars_dict</span><span class="p">(</span><span class="n">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">),</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="c"># don&#39;t destroy a Mul since much of the work may already be done</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="n">changed</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># get a Pow ready for expansion</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">separatevars</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

    <span class="c"># First try other expansion methods</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

    <span class="n">_expr</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">force</span> <span class="k">else</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">_expr</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># Find any common coefficients to pull out</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">commonc</span> <span class="o">&amp;=</span> <span class="n">i</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">commonc</span><span class="p">)</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">commonc</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># ignore constants</span>
    <span class="n">commonc_set</span> <span class="o">=</span> <span class="n">commonc</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># remove them</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">commonc_set</span>
        <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nc</span><span class="p">)</span>
    <span class="n">nonsepar</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonsepar</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_expr</span> <span class="o">=</span> <span class="n">nonsepar</span>
        <span class="n">_expr</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">_expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">force</span> <span class="k">else</span> <span class="p">(</span><span class="n">_expr</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">_expr</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">nonsepar</span> <span class="o">=</span> <span class="n">_expr</span>

    <span class="k">return</span> <span class="n">commonc</span><span class="o">*</span><span class="n">nonsepar</span>


<span class="k">def</span> <span class="nf">_separatevars_dict</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbols</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">is_Atom</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)),</span> <span class="s">&quot;symbols must be Atoms.&quot;</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">symbols</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;coeff&#39;</span><span class="p">:</span> <span class="n">expr</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="n">expsym</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">expsym</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># There are no symbols, so it is part of the coefficient</span>
            <span class="n">ret</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">intersection</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c"># rebuild</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret</span>


<div class="viewcode-block" id="ratsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.ratsimp">[docs]</a><span class="k">def</span> <span class="nf">ratsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Put an expression over a common denominator, cancel and reduce.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import ratsimp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; ratsimp(1/x + 1/y)</span>
<span class="sd">    (x + y)/(x*y)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">g</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">ComputationFailed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">/</span><span class="n">g</span>

    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span> <span class="o">+</span> <span class="n">cancel</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">ratsimpmodprime</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies a rational expression ``expr`` modulo the prime ideal</span>
<span class="sd">    generated by ``G``.  ``G`` should be a Groebner basis of the</span>
<span class="sd">    ideal.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import ratsimpmodprime</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; eq = (x + y**5 + y)/(x - y)</span>
<span class="sd">    &gt;&gt;&gt; ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order=&#39;lex&#39;)</span>
<span class="sd">    (x**2 + x*y + x + y)/(x**2 - x*y)</span>

<span class="sd">    If ``polynomial`` is False, the algorithm computes a rational</span>
<span class="sd">    simplification which minimizes the sum of the total degrees of</span>
<span class="sd">    the numerator and the denominator.</span>

<span class="sd">    If ``polynomial`` is True, this function just brings numerator and</span>
<span class="sd">    denominator into a canonical form. This is much faster, but has</span>
<span class="sd">    potentially worse results.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial</span>
<span class="sd">    Ideal,</span>
<span class="sd">    http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.163.6984</span>
<span class="sd">    (specifically, the second algorithm)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">parallel_poly_from_expr</span>
    <span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="kn">import</span> <span class="n">PolificationFailed</span><span class="p">,</span> <span class="n">DomainError</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Monomial</span>
    <span class="kn">from</span> <span class="nn">sympy.polys.monomials</span> <span class="kn">import</span> <span class="n">monomial_div</span>
    <span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">combinations_with_replacement</span>
    <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">debug</span>

    <span class="n">quick</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;quick&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">polynomial</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;polynomial&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">debug</span><span class="p">(</span><span class="s">&#39;ratsimpmodprime&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

    <span class="c"># usual preparation of polynomials:</span>

    <span class="n">num</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">polys</span><span class="p">,</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">parallel_poly_from_expr</span><span class="p">([</span><span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">PolificationFailed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">domain</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">if</span> <span class="n">domain</span><span class="o">.</span><span class="n">has_assoc_Field</span><span class="p">:</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">get_field</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">DomainError</span><span class="p">(</span>
            <span class="s">&quot;can&#39;t compute rational simplification over </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">domain</span><span class="p">)</span>

    <span class="c"># compute only once</span>
    <span class="n">leading_monomials</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">LM</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
    <span class="n">tested</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">staircase</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute all monomials with degree less than ``n`` that are</span>
<span class="sd">        not divisible by any element of ``leading_monomials``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)),</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mi</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">monomial_div</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">lmg</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">lmg</span> <span class="ow">in</span>
                    <span class="n">leading_monomials</span><span class="p">]):</span>
                <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">Monomial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span> <span class="o">+</span> <span class="n">staircase</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ratsimpmodprime</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">allsol</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a rational simplification of ``a/b`` which minimizes</span>
<span class="sd">        the sum of the total degrees of the numerator and the denominator.</span>

<span class="sd">        The algorithm proceeds by looking at ``a * d - b * c`` modulo</span>
<span class="sd">        the ideal generated by ``G`` for some ``c`` and ``d`` with degree</span>
<span class="sd">        less than ``a`` and ``b`` respectively.</span>
<span class="sd">        The coefficients of ``c`` and ``d`` are indeterminates and thus</span>
<span class="sd">        the coefficients of the normalform of ``a * d - b * c`` are</span>
<span class="sd">        linear polynomials in these indeterminates.</span>
<span class="sd">        If these linear polynomials, considered as system of</span>
<span class="sd">        equations, have a nontrivial solution, then `\frac{a}{b}</span>
<span class="sd">        \equiv \frac{c}{d}` modulo the ideal generated by ``G``. So,</span>
<span class="sd">        by construction, the degree of ``c`` and ``d`` is less than</span>
<span class="sd">        the degree of ``a`` and ``b``, so a simpler representation</span>
<span class="sd">        has been found.</span>
<span class="sd">        After a simpler representation has been found, the algorithm</span>
<span class="sd">        tries to reduce the degree of the numerator and denominator</span>
<span class="sd">        and returns the result afterwards.</span>

<span class="sd">        As an extension, if quick=False, we look at all possible degrees such</span>
<span class="sd">        that the total degree is less than *or equal to* the best current</span>
<span class="sd">        solution. We retain a list of all solutions of minimal degree, and try</span>
<span class="sd">        to find the best one at the end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">maxdeg</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">total_degree</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">total_degree</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">quick</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="n">maxdeg</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="n">maxdeg</span>
        <span class="k">while</span> <span class="n">N</span> <span class="o">+</span> <span class="n">D</span> <span class="o">&lt;=</span> <span class="n">bound</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tested</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">tested</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>

            <span class="n">M1</span> <span class="o">=</span> <span class="n">staircase</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">M2</span> <span class="o">=</span> <span class="n">staircase</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="n">debug</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> / </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">))</span>

            <span class="n">Cs</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;c:</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">M1</span><span class="p">),</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
            <span class="n">Ds</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;d:</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">M2</span><span class="p">),</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
            <span class="n">ng</span> <span class="o">=</span> <span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span>

            <span class="n">c_hat</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">([</span><span class="n">Cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M1</span><span class="p">))]),</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span> <span class="o">+</span> <span class="n">ng</span><span class="p">)</span>
            <span class="n">d_hat</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">([</span><span class="n">Ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M2</span><span class="p">))]),</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span> <span class="o">+</span> <span class="n">ng</span><span class="p">)</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">d_hat</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c_hat</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span> <span class="o">+</span> <span class="n">ng</span><span class="p">,</span>
                        <span class="n">order</span><span class="o">=</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">polys</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">S</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">gens</span><span class="o">=</span><span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span><span class="o">.</span><span class="n">coeffs</span><span class="p">()</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">,</span> <span class="n">minimal</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">quick</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c_hat</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d_hat</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

                <span class="c"># The &quot;free&quot; variables occuring before as parameters</span>
                <span class="c"># might still be in the substituted c, d, so set them</span>
                <span class="c"># to the value chosen before:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Cs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ds</span><span class="p">))))))</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Cs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ds</span><span class="p">))))))</span>

                <span class="n">c</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Ideal not prime?&#39;</span><span class="p">)</span>

                <span class="n">allsol</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c_hat</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">N</span> <span class="o">+</span> <span class="n">D</span> <span class="o">!=</span> <span class="n">maxdeg</span><span class="p">:</span>
                    <span class="n">allsol</span> <span class="o">=</span> <span class="p">[</span><span class="n">allsol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

                <span class="k">break</span>

            <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">D</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">steps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">allsol</span> <span class="o">=</span> <span class="n">_ratsimpmodprime</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">allsol</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">-</span> <span class="n">steps</span><span class="p">)</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">allsol</span> <span class="o">=</span> <span class="n">_ratsimpmodprime</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">allsol</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">steps</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">allsol</span>

    <span class="c"># preprocessing. this improves performance a bit when deg(num)</span>
    <span class="c"># and deg(denom) are large:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">polynomial</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">allsol</span> <span class="o">=</span> <span class="n">_ratsimpmodprime</span><span class="p">(</span>
        <span class="n">Poly</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">),</span> <span class="n">Poly</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">),</span> <span class="p">[])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">quick</span> <span class="ow">and</span> <span class="n">allsol</span><span class="p">:</span>
        <span class="n">debug</span><span class="p">(</span><span class="s">&#39;Looking for best minimal solution. Got: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">allsol</span><span class="p">))</span>
        <span class="n">newsol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c_hat</span><span class="p">,</span> <span class="n">d_hat</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ng</span> <span class="ow">in</span> <span class="n">allsol</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ng</span><span class="p">,</span> <span class="n">minimal</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">quick</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">newsol</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c_hat</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">),</span> <span class="n">d_hat</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)))</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">newsol</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">terms</span><span class="p">())</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">terms</span><span class="p">()))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">domain</span><span class="o">.</span><span class="n">has_Field</span><span class="p">:</span>
        <span class="n">cn</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">(</span><span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">dn</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">(</span><span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">dn</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">r</span><span class="o">.</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">trigsimp_groebner</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hints</span><span class="o">=</span><span class="p">[],</span> <span class="n">quick</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&quot;grlex&quot;</span><span class="p">,</span>
                      <span class="n">polynomial</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplify trigonometric expressions using a groebner basis algorithm.</span>

<span class="sd">    This routine takes a fraction involving trigonometric or hyperbolic</span>
<span class="sd">    expressions, and tries to simplify it. The primary metric is the</span>
<span class="sd">    total degree. Some attempts are made to choose the simplest possible</span>
<span class="sd">    expression of the minimal degree, but this is non-rigorous, and also</span>
<span class="sd">    very slow (see the ``quick=True`` option).</span>

<span class="sd">    If ``polynomial`` is set to True, instead of simplifying numerator and</span>
<span class="sd">    denominator together, this function just brings numerator and denominator</span>
<span class="sd">    into a canonical form. This is much faster, but has potentially worse</span>
<span class="sd">    results. However, if the input is a polynomial, then the result is</span>
<span class="sd">    guaranteed to be an equivalent polynomial of minimal degree.</span>

<span class="sd">    The most important option is hints. Its entries can be any of the</span>
<span class="sd">    following:</span>

<span class="sd">    - a natural number</span>
<span class="sd">    - a function</span>
<span class="sd">    - an iterable of the form (func, var1, var2, ...)</span>
<span class="sd">    - anything else, interpreted as a generator</span>

<span class="sd">    A number is used to indicate that the search space should be increased.</span>
<span class="sd">    A function is used to indicate that said function is likely to occur in a</span>
<span class="sd">    simplified expression.</span>
<span class="sd">    An iterable is used indicate that func(var1 + var2 + ...) is likely to</span>
<span class="sd">    occur in a simplified .</span>
<span class="sd">    An additional generator also indicates that it is likely to occur.</span>
<span class="sd">    (See examples below).</span>

<span class="sd">    This routine carries out various computationally intensive algorithms.</span>
<span class="sd">    The option ``quick=True`` can be used to suppress one particularly slow</span>
<span class="sd">    step (at the expense of potentially more complicated results, but never at</span>
<span class="sd">    the expense of increased total degree).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sin, tan, cos, sinh, cosh, tanh</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import trigsimp_groebner</span>

<span class="sd">    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:</span>

<span class="sd">    &gt;&gt;&gt; ex = sin(x)*cos(x)</span>
<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(ex)</span>
<span class="sd">    sin(x)*cos(x)</span>

<span class="sd">    This is because ``trigsimp_groebner`` only looks for a simplification</span>
<span class="sd">    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try</span>
<span class="sd">    ``2*x`` by passing ``hints=[2]``:</span>

<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(ex, hints=[2])</span>
<span class="sd">    sin(2*x)/2</span>
<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])</span>
<span class="sd">    -cos(2*x)</span>

<span class="sd">    Increasing the search space this way can quickly become expensive. A much</span>
<span class="sd">    faster way is to give a specific expression that is likely to occur:</span>

<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(ex, hints=[sin(2*x)])</span>
<span class="sd">    sin(2*x)/2</span>

<span class="sd">    Hyperbolic expressions are similarly supported:</span>

<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(sinh(2*x)/sinh(x))</span>
<span class="sd">    2*cosh(x)</span>

<span class="sd">    Note how no hints had to be passed, since the expression already involved</span>
<span class="sd">    ``2*x``.</span>

<span class="sd">    The tangent function is also supported. You can either pass ``tan`` in the</span>
<span class="sd">    hints, to indicate that than should be tried whenever cosine or sine are,</span>
<span class="sd">    or you can pass a specific generator:</span>

<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(sin(x)/cos(x), hints=[tan])</span>
<span class="sd">    tan(x)</span>
<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])</span>
<span class="sd">    tanh(x)</span>

<span class="sd">    Finally, you can use the iterable form to suggest that angle sum formulae</span>
<span class="sd">    should be tried:</span>

<span class="sd">    &gt;&gt;&gt; ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))</span>
<span class="sd">    &gt;&gt;&gt; trigsimp_groebner(ex, hints=[(tan, x, y)])</span>
<span class="sd">    tan(x + y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO</span>
    <span class="c">#  - preprocess by replacing everything by funcs we can handle</span>
    <span class="c"># - optionally use cot instead of tan</span>
    <span class="c"># - more intelligent hinting.</span>
    <span class="c">#     For example, if the ideal is small, and we have sin(x), sin(y),</span>
    <span class="c">#     add sin(x + y) automatically... ?</span>
    <span class="c"># - algebraic numbers ...</span>
    <span class="c"># - expressions of lowest degree are not distinguished properly</span>
    <span class="c">#   e.g. 1 - sin(x)**2</span>
    <span class="c"># - we could try to order the generators intelligently, so as to influence</span>
    <span class="c">#   which monomials appear in the quotient basis</span>

    <span class="c"># THEORY</span>
    <span class="c"># ------</span>
    <span class="c"># Ratsimpmodprime above can be used to &quot;simplify&quot; a rational function</span>
    <span class="c"># modulo a prime ideal. &quot;Simplify&quot; mainly means finding an equivalent</span>
    <span class="c"># expression of lower total degree.</span>
    <span class="c">#</span>
    <span class="c"># We intend to use this to simplify trigonometric functions. To do that,</span>
    <span class="c"># we need to decide (a) which ring to use, and (b) modulo which ideal to</span>
    <span class="c"># simplify. In practice, (a) means settling on a list of &quot;generators&quot;</span>
    <span class="c"># a, b, c, ..., such that the fraction we want to simplify is a rational</span>
    <span class="c"># function in a, b, c, ..., with coefficients in ZZ (integers).</span>
    <span class="c"># (2) means that we have to decide what relations to impose on the</span>
    <span class="c"># generators. There are two practical problems:</span>
    <span class="c">#   (1) The ideal has to be *prime* (a technical term).</span>
    <span class="c">#   (2) The relations have to be polynomials in the generators.</span>
    <span class="c">#</span>
    <span class="c"># We typically have two kinds of generators:</span>
    <span class="c"># - trigonometric expressions, like sin(x), cos(5*x), etc</span>
    <span class="c"># - &quot;everything else&quot;, like gamma(x), pi, etc.</span>
    <span class="c">#</span>
    <span class="c"># Since this function is trigsimp, we will concentrate on what to do with</span>
    <span class="c"># trigonometric expressions. We can also simplify hyperbolic expressions,</span>
    <span class="c"># but the extensions should be clear.</span>
    <span class="c">#</span>
    <span class="c"># One crucial point is that all *other* generators really should behave</span>
    <span class="c"># like indeterminates. In particular if (say) &quot;I&quot; is one of them, then</span>
    <span class="c"># in fact I**2 + 1 = 0 and we may and will compute non-sensical</span>
    <span class="c"># expressions. However, we can work with a dummy and add the relation</span>
    <span class="c"># I**2 + 1 = 0 to our ideal, then substitute back in the end.</span>
    <span class="c">#</span>
    <span class="c"># Now regarding trigonometric generators. We split them into groups,</span>
    <span class="c"># according to the argument of the trigonometric functions. We want to</span>
    <span class="c"># organise this in such a way that most trigonometric identities apply in</span>
    <span class="c"># the same group. For example, given sin(x), cos(2*x) and cos(y), we would</span>
    <span class="c"># group as [sin(x), cos(2*x)] and [cos(y)].</span>
    <span class="c">#</span>
    <span class="c"># Our prime ideal will be built in three steps:</span>
    <span class="c"># (1) For each group, compute a &quot;geometrically prime&quot; ideal of relations.</span>
    <span class="c">#     Geometrically prime means that it generates a prime ideal in</span>
    <span class="c">#     CC[gens], not just ZZ[gens].</span>
    <span class="c"># (2) Take the union of all the generators of the ideals for all groups.</span>
    <span class="c">#     By the geometric primality condition, this is still prime.</span>
    <span class="c"># (3) Add further inter-group relations which preserve primality.</span>
    <span class="c">#</span>
    <span class="c"># Step (1) works as follows. We will isolate common factors in the</span>
    <span class="c"># argument, so that all our generators are of the form sin(n*x), cos(n*x)</span>
    <span class="c"># or tan(n*x), with n an integer. Suppose first there are no tan terms.</span>
    <span class="c"># The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since</span>
    <span class="c"># X**2 + Y**2 - 1 is irreducible over CC.</span>
    <span class="c"># Now, if we have a generator sin(n*x), than we can, using trig identities,</span>
    <span class="c"># express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this</span>
    <span class="c"># relation to the ideal, preserving geometric primality, since the quotient</span>
    <span class="c"># ring is unchanged.</span>
    <span class="c"># Thus we have treated all sin and cos terms.</span>
    <span class="c"># For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.</span>
    <span class="c"># (This requires of course that we already have relations for cos(n*x) and</span>
    <span class="c"># sin(n*x).) It is not obvious, but it seems that this preserves geometric</span>
    <span class="c"># primality.</span>
    <span class="c"># XXX A real proof would be nice. HELP!</span>
    <span class="c">#     Sketch that &lt;S**2 + C**2 - 1, C*T - S&gt; is a prime ideal of</span>
    <span class="c">#     CC[S, C, T]:</span>
    <span class="c">#     - it suffices to show that the projective closure in CP**3 is</span>
    <span class="c">#       irreducible</span>
    <span class="c">#     - using the half-angle substitutions, we can express sin(x), tan(x),</span>
    <span class="c">#       cos(x) as rational functions in tan(x/2)</span>
    <span class="c">#     - from this, we get a rational map from CP**1 to our curve</span>
    <span class="c">#     - this is a morphism, hence the curve is prime</span>
    <span class="c">#</span>
    <span class="c"># Step (2) is trivial.</span>
    <span class="c">#</span>
    <span class="c"># Step (3) works by adding selected relations of the form</span>
    <span class="c"># sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is</span>
    <span class="c"># preserved by the same argument as before.</span>

    <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">debug</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
    <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">parallel_poly_from_expr</span><span class="p">,</span> <span class="n">groebner</span><span class="p">,</span> <span class="n">ZZ</span>
    <span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="kn">import</span> <span class="n">PolificationFailed</span>

    <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">tan</span>
    <span class="n">sinh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">tanh</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">sinh</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">cosh</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">tanh</span>

    <span class="k">def</span> <span class="nf">parse_hints</span><span class="p">(</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split hints into (n, funcs, iterables, gens).&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">funcs</span><span class="p">,</span> <span class="n">iterables</span><span class="p">,</span> <span class="n">gens</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">hints</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">FunctionClass</span><span class="p">):</span>
                <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="n">iterables</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="c"># XXX sin(x+2y)?</span>
                <span class="c"># Note: we go through polys so e.g.</span>
                <span class="c"># sin(-x) -&gt; -sin(x) -&gt; sin(x)</span>
                <span class="n">gens</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">parallel_poly_from_expr</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))])[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">iterables</span><span class="p">,</span> <span class="n">gens</span>

    <span class="k">def</span> <span class="nf">build_ideal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build generators for our ideal. Terms is an iterable with elements of</span>
<span class="sd">        the form (fn, coeff), indicating that we have a generator fn(coeff*x).</span>

<span class="sd">        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed</span>
<span class="sd">        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),</span>
<span class="sd">        sin(n*x) and cos(n*x) are guaranteed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">I</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">rel</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="p">[</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">cosh</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">]:</span>
                    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">fn</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">]:</span>
                    <span class="n">cn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">trig</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">cn</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">analyse_gens</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyse the generators ``gens``, using the hints ``hints``.</span>

<span class="sd">        The meaning of ``hints`` is described in the main docstring.</span>
<span class="sd">        Return a new list of generators, and also the ideal we should</span>
<span class="sd">        work with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># First parse the hints</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">iterables</span><span class="p">,</span> <span class="n">extragens</span> <span class="o">=</span> <span class="n">parse_hints</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span>
        <span class="n">debug</span><span class="p">(</span><span class="s">&#39;n=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="s">&#39;funcs:&#39;</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="s">&#39;iterables:&#39;</span><span class="p">,</span>
              <span class="n">iterables</span><span class="p">,</span> <span class="s">&#39;extragens:&#39;</span><span class="p">,</span> <span class="n">extragens</span><span class="p">)</span>

        <span class="c"># We just add the extragens to gens and analyse them as before</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>
        <span class="n">gens</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extragens</span><span class="p">)</span>

        <span class="c"># remove duplicates</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">funcs</span><span class="p">))</span>
        <span class="n">iterables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">iterables</span><span class="p">))</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">gens</span><span class="p">))</span>

        <span class="c"># all the functions we can do anything with</span>
        <span class="n">allfuncs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">tanh</span><span class="p">])</span>
        <span class="c"># sin(3*x) -&gt; ((3, x), sin)</span>
        <span class="n">trigterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">g</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span>
                     <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="n">allfuncs</span><span class="p">]</span>
        <span class="c"># Our list of new generators - start with anything that we cannot</span>
        <span class="c"># work with (i.e. is not a trigonometric term)</span>
        <span class="n">freegens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allfuncs</span><span class="p">]</span>
        <span class="n">newgens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trigdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">trigterms</span><span class="p">:</span>
            <span class="n">trigdict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coeff</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># the ideal</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">trigdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c"># We have now assembeled a dictionary. Its keys are common</span>
            <span class="c"># arguments in trigonometric expressions, and values are lists of</span>
            <span class="c"># pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we</span>
            <span class="c"># need to deal with fn(coeff*x0). We take the rational gcd of the</span>
            <span class="c"># coeffs, call it ``gcd``. We then use x = x0/gcd as &quot;base symbol&quot;,</span>
            <span class="c"># all other arguments are integral multiples thereof.</span>
            <span class="c"># We will build an ideal which works with sin(x), cos(x).</span>
            <span class="c"># If hint tan is provided, also work with tan(x). Moreover, if</span>
            <span class="c"># n &gt; 1, also work with sin(k*x) for k &lt;= n, and similarly for cos</span>
            <span class="c"># (and tan if the hint is provided). Finally, any generators which</span>
            <span class="c"># the ideal does not work with but we need to accomodate (either</span>
            <span class="c"># because it was in expr or because it was provided as a hint)</span>
            <span class="c"># we also build into the ideal.</span>
            <span class="c"># This selection process is expressed in the list ``terms``.</span>
            <span class="c"># build_ideal then generates the actual relations in our ideal,</span>
            <span class="c"># from this list.</span>
            <span class="n">fns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
            <span class="n">gcd</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">igcd</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="n">gcd</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="n">val</span><span class="p">)]</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">funcs</span> <span class="o">+</span> <span class="n">fns</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">([</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span><span class="p">],</span> <span class="p">[</span><span class="n">cosh</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">tanh</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">fs</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)):</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fn</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="n">tan</span><span class="p">:</span>
                    <span class="n">extra</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sin</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="n">extra</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cos</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tan</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">:</span>
                    <span class="n">extra</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tan</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="n">tanh</span><span class="p">:</span>
                    <span class="n">extra</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sinh</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="n">extra</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cosh</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sinh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tanh</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">:</span>
                    <span class="n">extra</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tanh</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">gcd</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">build_ideal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">newgens</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">))</span>

        <span class="c"># Add generators for compound expressions from iterables</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="n">tan</span><span class="p">:</span>
                <span class="c"># Tan expressions are recovered from sin and cos.</span>
                <span class="n">iterables</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">sin</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">args</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="n">fn</span> <span class="o">==</span> <span class="n">tanh</span><span class="p">:</span>
                <span class="c"># Tanh expressions are recovered from sihn and cosh.</span>
                <span class="n">iterables</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">sinh</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="p">(</span><span class="n">cosh</span><span class="p">,</span> <span class="n">args</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummys</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;d:</span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">dummys</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">trig</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dummys</span><span class="p">,</span> <span class="n">args</span><span class="p">)))</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span> <span class="o">-</span> <span class="n">expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">myI</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">myI</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">freegens</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">myI</span><span class="p">)</span>
            <span class="n">newgens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">myI</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">freegens</span><span class="p">,</span> <span class="n">newgens</span>

    <span class="n">myI</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">,</span> <span class="n">myI</span><span class="p">)</span>
    <span class="n">subs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">myI</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">)]</span>

    <span class="n">num</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="p">(</span><span class="n">pnum</span><span class="p">,</span> <span class="n">pdenom</span><span class="p">),</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">parallel_poly_from_expr</span><span class="p">([</span><span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">])</span>
    <span class="k">except</span> <span class="n">PolificationFailed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="n">debug</span><span class="p">(</span><span class="s">&#39;initial gens:&#39;</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
    <span class="n">ideal</span><span class="p">,</span> <span class="n">freegens</span><span class="p">,</span> <span class="n">gens</span> <span class="o">=</span> <span class="n">analyse_gens</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">,</span> <span class="n">hints</span><span class="p">)</span>
    <span class="n">debug</span><span class="p">(</span><span class="s">&#39;ideal:&#39;</span><span class="p">,</span> <span class="n">ideal</span><span class="p">)</span>
    <span class="n">debug</span><span class="p">(</span><span class="s">&#39;new gens:&#39;</span><span class="p">,</span> <span class="n">gens</span><span class="p">,</span> <span class="s">&quot; -- len&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">))</span>
    <span class="n">debug</span><span class="p">(</span><span class="s">&#39;free gens:&#39;</span><span class="p">,</span> <span class="n">freegens</span><span class="p">,</span> <span class="s">&quot; -- len&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">))</span>
    <span class="c"># NOTE we force the domain to be ZZ to stop polys from injecting generators</span>
    <span class="c">#      (which is usually a sign of a bug in the way we build the ideal)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">gens</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">groebner</span><span class="p">(</span><span class="n">ideal</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">gens</span><span class="o">=</span><span class="n">gens</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">ZZ</span><span class="p">)</span>
    <span class="n">debug</span><span class="p">(</span><span class="s">&#39;groebner basis:&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="s">&quot; -- len&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

    <span class="c"># If our fraction is a polynomial in the free generators, simplify all</span>
    <span class="c"># coefficients separately:</span>
    <span class="k">if</span> <span class="n">freegens</span> <span class="ow">and</span> <span class="n">pdenom</span><span class="o">.</span><span class="n">has_only_gens</span><span class="p">(</span><span class="o">*</span><span class="nb">set</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">pdenom</span><span class="o">.</span><span class="n">gens</span><span class="p">)):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">gens</span><span class="o">=</span><span class="n">gens</span><span class="o">+</span><span class="n">freegens</span><span class="p">)</span><span class="o">.</span><span class="n">eject</span><span class="p">(</span><span class="o">*</span><span class="n">gens</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">num</span><span class="o">.</span><span class="n">terms</span><span class="p">():</span>
            <span class="n">ourgens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parallel_poly_from_expr</span><span class="p">([</span><span class="n">coeff</span><span class="p">,</span> <span class="n">denom</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
            <span class="c"># We compute the transitive closure of all generators that can</span>
            <span class="c"># be reached from our generators through relations in the ideal.</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ideal</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ourgens</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span> <span class="ow">and</span> \
                       <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">has_only_gens</span><span class="p">(</span><span class="o">*</span><span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ourgens</span><span class="p">)):</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">ourgens</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exclude</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
            <span class="c"># NOTE preserve order!</span>
            <span class="n">realgens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gens</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ourgens</span><span class="p">]</span>
            <span class="c"># The generators of the ideal have now been (implicitely) split</span>
            <span class="c"># into two groups: those involving ourgens and those that don&#39;t.</span>
            <span class="c"># Since we took the transitive closure above, these two groups</span>
            <span class="c"># live in subgrings generated by a *disjoint* set of variables.</span>
            <span class="c"># Any sensible groebner basis algorithm will preserve this disjoint</span>
            <span class="c"># structure (i.e. the elements of the groebner basis can be split</span>
            <span class="c"># similarly), and and the two subsets of the groebner basis then</span>
            <span class="c"># form groebner bases by themselves. (For the smaller generating</span>
            <span class="c"># sets, of course.)</span>
            <span class="n">ourG</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">polys</span> <span class="k">if</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">has_only_gens</span><span class="p">(</span><span class="o">*</span><span class="n">ourgens</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">gens</span><span class="p">))]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">a</span><span class="o">**</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">freegens</span><span class="p">,</span> <span class="n">monom</span><span class="p">)])</span> <span class="o">*</span> \
                       <span class="n">ratsimpmodprime</span><span class="p">(</span><span class="n">coeff</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">ourG</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                                       <span class="n">gens</span><span class="o">=</span><span class="n">realgens</span><span class="p">,</span> <span class="n">quick</span><span class="o">=</span><span class="n">quick</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">ZZ</span><span class="p">,</span>
                                       <span class="n">polynomial</span><span class="o">=</span><span class="n">polynomial</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)</span>
        <span class="c"># NOTE The following is simpler and has less assumptions on the</span>
        <span class="c">#      groebner basis algorithm. If the above turns out to be broken,</span>
        <span class="c">#      use this.</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">a</span><span class="o">**</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">freegens</span><span class="p">,</span> <span class="n">monom</span><span class="p">)])</span> <span class="o">*</span> \
                     <span class="n">ratsimpmodprime</span><span class="p">(</span><span class="n">coeff</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                                     <span class="n">gens</span><span class="o">=</span><span class="n">gens</span><span class="p">,</span> <span class="n">quick</span><span class="o">=</span><span class="n">quick</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">ZZ</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">num</span><span class="o">.</span><span class="n">terms</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ratsimpmodprime</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">gens</span><span class="o">=</span><span class="n">freegens</span><span class="o">+</span><span class="n">gens</span><span class="p">,</span>
            <span class="n">quick</span><span class="o">=</span><span class="n">quick</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">polynomial</span><span class="o">=</span><span class="n">polynomial</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span>


<span class="n">_trigs</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">)</span>


<div class="viewcode-block" id="trigsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.trigsimp">[docs]</a><span class="k">def</span> <span class="nf">trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reduces expression by using known trig identities</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    method:</span>
<span class="sd">    - Determine the method to use. Valid choices are &#39;matching&#39; (default),</span>
<span class="sd">    &#39;groebner&#39;, &#39;combined&#39;, and &#39;fu&#39;. If &#39;matching&#39;, simplify the</span>
<span class="sd">    expression recursively by targeting common patterns. If &#39;groebner&#39;, apply</span>
<span class="sd">    an experimental groebner basis algorithm. In this case further options</span>
<span class="sd">    are forwarded to ``trigsimp_groebner``, please refer to its docstring.</span>
<span class="sd">    If &#39;combined&#39;, first run the groebner basis algorithm with small</span>
<span class="sd">    default parameters, then run the &#39;matching&#39; algorithm. &#39;fu&#39; runs the</span>
<span class="sd">    collection of trigonometric transformations described by Fu, et al.</span>
<span class="sd">    (see the `fu` docstring).</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import trigsimp, sin, cos, log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; e = 2*sin(x)**2 + 2*cos(x)**2</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(e)</span>
<span class="sd">    2</span>

<span class="sd">    Simplification occurs wherever trigonometric functions are located.</span>

<span class="sd">    &gt;&gt;&gt; trigsimp(log(e))</span>
<span class="sd">    log(2)</span>

<span class="sd">    Using `method=&quot;groebner&quot;` (or `&quot;combined&quot;`) might lead to greater</span>
<span class="sd">    simplification.</span>

<span class="sd">    The old trigsimp routine can be accessed as with method &#39;old&#39;.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import coth, tanh</span>
<span class="sd">    &gt;&gt;&gt; t = 3*tanh(x)**7 - 2/coth(x)**7</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(t, method=&#39;old&#39;) == t</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(t)</span>
<span class="sd">    tanh(x)**7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="n">fu</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">old</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;old&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">old</span><span class="p">:</span>
        <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;deep&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">recursive</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;recursive&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;method&#39;</span><span class="p">,</span> <span class="s">&#39;matching&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;old&#39;</span>

    <span class="k">def</span> <span class="nf">groebnersimp</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">trigsimp_groebner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trigsimp_groebner</span><span class="p">(</span><span class="n">traverse</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

    <span class="n">trigsimpfunc</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;fu&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">fu</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
        <span class="s">&#39;matching&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">futrig</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
        <span class="s">&#39;groebner&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">groebnersimp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)),</span>
        <span class="s">&#39;combined&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">futrig</span><span class="p">(</span><span class="n">groebnersimp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                               <span class="n">polynomial</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">hints</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">tan</span><span class="p">]))),</span>
        <span class="s">&#39;old&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">trigsimp_old</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">),</span>
                   <span class="p">}[</span><span class="n">method</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">trigsimpfunc</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="collect_sqrt"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.collect_sqrt">[docs]</a><span class="k">def</span> <span class="nf">collect_sqrt</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return expr with terms having common square roots collected together.</span>
<span class="sd">    If ``evaluate`` is False a count indicating the number of sqrt-containing</span>
<span class="sd">    terms will be returned and, if non-zero, the terms of the Add will be</span>
<span class="sd">    returned, else the expression itself will be returned as a single term.</span>
<span class="sd">    If ``evaluate`` is True, the expression with any collected terms will be</span>
<span class="sd">    returned.</span>

<span class="sd">    Note: since I = sqrt(-1), it is collected, too.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import collect_sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b</span>

<span class="sd">    &gt;&gt;&gt; r2, r3, r5 = [sqrt(i) for i in [2, 3, 5]]</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2)</span>
<span class="sd">    sqrt(2)*(a + b)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r3)</span>
<span class="sd">    sqrt(2)*(a + b) + sqrt(3)*(a + b)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5)</span>
<span class="sd">    sqrt(3)*a + sqrt(5)*b + sqrt(2)*(a + b)</span>

<span class="sd">    If evaluate is False then the arguments will be sorted and</span>
<span class="sd">    returned as a list and a count of the number of sqrt-containing</span>
<span class="sd">    terms will be returned:</span>

<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5, evaluate=False)</span>
<span class="sd">    ((sqrt(3)*a, sqrt(5)*b, sqrt(2)*(a + b)), 3)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*sqrt(2) + b, evaluate=False)</span>
<span class="sd">    ((b, sqrt(2)*a), 1)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a + b, evaluate=False)</span>
<span class="sd">    ((a + b,), 0)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect, collect_const, rcollect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># this step will help to standardize any complex arguments</span>
    <span class="c"># of sqrts</span>
    <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span>
                    <span class="n">m</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">):</span>
                <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="c"># we only want radicals, so exclude Number handling; in this case</span>
    <span class="c"># d will be evaluated</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">collect_const</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="n">Numbers</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">hit</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">d</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="n">nrad</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># make the evaluated args canonical</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="c"># XXX should this be restricted to ci.is_number as above?</span>
                <span class="k">if</span> <span class="n">ci</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">ci</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">ci</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> \
                        <span class="n">ci</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
                    <span class="n">nrad</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">coeff</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">hit</span> <span class="ow">or</span> <span class="n">nrad</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">nrad</span>

    <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">d</span>

</div>
<div class="viewcode-block" id="collect_const"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.collect_const">[docs]</a><span class="k">def</span> <span class="nf">collect_const</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A non-greedy collection of terms with similar number coefficients in</span>
<span class="sd">    an Add expr. If ``vars`` is given then only those constants will be</span>
<span class="sd">    targeted. Although any Number can also be targeted, if this is not</span>
<span class="sd">    desired set ``Numbers=False`` and no Float or Rational will be collected.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, s, x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import collect_const</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3) + sqrt(3)*(1 + sqrt(2)))</span>
<span class="sd">    sqrt(3)*(sqrt(2) + 2)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(7)*s + sqrt(3) + sqrt(7))</span>
<span class="sd">    (sqrt(3) + sqrt(7))*(s + 1)</span>
<span class="sd">    &gt;&gt;&gt; s = sqrt(2) + 2</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7))</span>
<span class="sd">    (sqrt(2) + 3)*(sqrt(3) + sqrt(7))</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7), sqrt(3))</span>
<span class="sd">    sqrt(7) + sqrt(3)*(sqrt(2) + 3) + sqrt(7)*(sqrt(2) + 2)</span>

<span class="sd">    The collection is sign-sensitive, giving higher precedence to the</span>
<span class="sd">    unsigned values:</span>

<span class="sd">    &gt;&gt;&gt; collect_const(x - y - z)</span>
<span class="sd">    x - (y + z)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(-y - z)</span>
<span class="sd">    -(y + z)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(2*x - 2*y - 2*z, 2)</span>
<span class="sd">    2*(x - y - z)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(2*x - 2*y - 2*z, -2)</span>
<span class="sd">    2*x - 2*(y + z)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect, collect_sqrt, rcollect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">recurse</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">Numbers</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Numbers&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">recurse</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">Numbers</span><span class="p">:</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Number</span><span class="p">]</span>

    <span class="nb">vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">vars</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">Fv</span> <span class="o">=</span> <span class="n">Factors</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">Factors</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">Fv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">is_one</span><span class="p">:</span>
                <span class="c"># only accept this as a true factor if</span>
                <span class="c"># it didn&#39;t change an exponent from an Integer</span>
                <span class="c"># to a non-Integer, e.g. 2/sqrt(2) -&gt; sqrt(2)</span>
                <span class="c"># -- we aren&#39;t looking for this sort of change</span>
                <span class="n">fwas</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">fnow</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">factors</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">fwas</span> <span class="ow">and</span> <span class="n">fwas</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="ow">not</span>
                        <span class="n">fnow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fnow</span><span class="p">):</span>
                    <span class="n">terms</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
                    <span class="k">continue</span>
            <span class="n">terms</span><span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">uneval</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">recurse</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c"># be careful not to let uneval become True unless</span>
            <span class="c"># it must be because it&#39;s going to be more expensive</span>
            <span class="c"># to rebuild the expression as an unevaluated one</span>
            <span class="k">if</span> <span class="n">Numbers</span> <span class="ow">and</span> <span class="n">k</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_keep_coeff</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                <span class="n">uneval</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">uneval</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">_unevaluated_Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">expr</span>

</div>
<span class="k">def</span> <span class="nf">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    split the list of integers ``a`` into a list of integers, ``a1`` having</span>
<span class="sd">    ``g = gcd(a1)``, and a list ``a2`` whose elements are not divisible by</span>
<span class="sd">    ``g``.  Returns ``g, a1, a2``</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import _split_gcd</span>
<span class="sd">    &gt;&gt;&gt; _split_gcd(55, 35, 22, 14, 77, 10)</span>
<span class="sd">    (5, [55, 35, 10], [22, 14, 77])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g1</span>
            <span class="n">b1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span>

<span class="k">def</span> <span class="nf">_is_sum_surds</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="k">else</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">is_real</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">_nthroot_solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     helper function for ``nthroot``</span>
<span class="sd">     It denests ``p**Rational(1, n)`` using its minimal polynomial</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.polys.numberfields</span> <span class="kn">import</span> <span class="n">_minimal_polynomial_sq</span>
    <span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">solve</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">sqrtdenest</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="n">p</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">_minimal_polynomial_sq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">sols</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">sols</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sol</span> <span class="o">-</span> <span class="n">pn</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">prec</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">sqrtdenest</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">sol</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sol</span>

<div class="viewcode-block" id="nthroot"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.nthroot">[docs]</a><span class="k">def</span> <span class="nf">nthroot</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute a real nth-root of a sum of surds</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    expr : sum of surds</span>
<span class="sd">    n : integer</span>
<span class="sd">    max_len : maximum number of surds passed as constants to ``nsimplify``</span>

<span class="sd">    Algorithm</span>
<span class="sd">    =========</span>

<span class="sd">    First ``nsimplify`` is used to get a candidate root; if it is not a</span>
<span class="sd">    root the minimal polynomial is computed; the answer is one of its</span>
<span class="sd">    roots.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import nthroot</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Rational, sqrt</span>
<span class="sd">    &gt;&gt;&gt; nthroot(90 + 34*sqrt(7), 3)</span>
<span class="sd">    sqrt(7) + 3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.sqrtdenest</span> <span class="kn">import</span> <span class="n">sqrt_depth</span><span class="p">,</span> <span class="n">is_algebraic</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">expr</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_sum_surds</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="n">surds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">coeff_muls</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">coeff_muls</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_rational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">exp</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_integer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">p</span>
        <span class="n">surds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">surds</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">surds</span> <span class="o">=</span> <span class="n">surds</span><span class="p">[:</span><span class="n">max_len</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">expr</span><span class="p">)</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">surds</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">_mexpand</span><span class="p">(</span><span class="o">-</span><span class="n">expr</span><span class="p">)</span> <span class="k">else</span> <span class="n">p</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">res</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">surds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">_nthroot_solve</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">expr</span>

</div>
<span class="k">def</span> <span class="nf">split_surds</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    split an expression with terms whose squares are rationals</span>
<span class="sd">    into a sum of terms whose surds squared have gcd equal to g</span>
<span class="sd">    and a sum of terms with surds squared prime with g</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import split_surds</span>
<span class="sd">    &gt;&gt;&gt; split_surds(3*sqrt(3) + sqrt(5)/7 + sqrt(6) + sqrt(10) + sqrt(15))</span>
<span class="sd">    (3, sqrt(2) + sqrt(5) + 3, sqrt(5)/7 + sqrt(10))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
    <span class="n">coeff_muls</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">surds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coeff_muls</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">]</span>
    <span class="n">surds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">surds</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">b2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">b1n</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">/</span><span class="n">g</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">]</span>
        <span class="n">b1n</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b1n</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c"># only a common factor has been factored; split again</span>
        <span class="n">g1</span><span class="p">,</span> <span class="n">b1n</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">b1n</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="n">g1</span>
    <span class="n">a1v</span><span class="p">,</span> <span class="n">a2v</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">coeff_muls</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">exp</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">base</span>
            <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">:</span>
                <span class="n">a1v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s1</span><span class="o">/</span><span class="n">g2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a2v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a2v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">a1v</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">a2v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>


<div class="viewcode-block" id="rad_rationalize"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.rad_rationalize">[docs]</a><span class="k">def</span> <span class="nf">rad_rationalize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rationalize num/den by removing square roots in the denominator;</span>
<span class="sd">    num and den are sum of terms whose squares are rationals</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import rad_rationalize</span>
<span class="sd">    &gt;&gt;&gt; rad_rationalize(sqrt(3), 1 + sqrt(2)/3)</span>
<span class="sd">    (-sqrt(3) + sqrt(6)/3, -7/9)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">den</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span><span class="p">,</span> <span class="n">den</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">split_surds</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">num</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rad_rationalize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="radsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.radsimp">[docs]</a><span class="k">def</span> <span class="nf">radsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">max_terms</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rationalize the denominator by removing square roots.</span>

<span class="sd">    Note: the expression returned from radsimp must be used with caution</span>
<span class="sd">    since if the denominator contains symbols, it will be possible to make</span>
<span class="sd">    substitutions that violate the assumptions of the simplification process:</span>
<span class="sd">    that for a denominator matching a + b*sqrt(c), a != +/-b*sqrt(c). (If</span>
<span class="sd">    there are no symbols, this assumptions is made valid by collecting terms</span>
<span class="sd">    of sqrt(c) so the match variable ``a`` does not contain ``sqrt(c)``.) If</span>
<span class="sd">    you do not want the simplification to occur for symbolic denominators, set</span>
<span class="sd">    ``symbolic`` to False.</span>

<span class="sd">    If there are more than ``max_terms`` radical terms then the expression is</span>
<span class="sd">    returned unchanged.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import radsimp, sqrt, Symbol, denom, pprint, I</span>
<span class="sd">    &gt;&gt;&gt; from sympy import factor_terms, fraction, signsimp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import collect_sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, c</span>

<span class="sd">    &gt;&gt;&gt; radsimp(1/(I + 1))</span>
<span class="sd">    (1 - I)/2</span>
<span class="sd">    &gt;&gt;&gt; radsimp(1/(2 + sqrt(2)))</span>
<span class="sd">    (-sqrt(2) + 2)/2</span>
<span class="sd">    &gt;&gt;&gt; x,y = map(Symbol, &#39;xy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; e = ((2 + 2*sqrt(2))*x + (2 + sqrt(8))*y)/(2 + sqrt(2))</span>
<span class="sd">    &gt;&gt;&gt; radsimp(e)</span>
<span class="sd">    sqrt(2)*(x + y)</span>

<span class="sd">    No simplification beyond removal of the gcd is done. One might</span>
<span class="sd">    want to polish the result a little, however, by collecting</span>
<span class="sd">    square root terms:</span>

<span class="sd">    &gt;&gt;&gt; r2 = sqrt(2)</span>
<span class="sd">    &gt;&gt;&gt; r5 = sqrt(5)</span>
<span class="sd">    &gt;&gt;&gt; ans = radsimp(1/(y*r2 + x*r2 + a*r5 + b*r5)); pprint(ans)</span>
<span class="sd">        ___       ___       ___       ___</span>
<span class="sd">      \/ 5 *a + \/ 5 *b - \/ 2 *x - \/ 2 *y</span>
<span class="sd">    ------------------------------------------</span>
<span class="sd">       2               2      2              2</span>
<span class="sd">    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y</span>

<span class="sd">    &gt;&gt;&gt; n, d = fraction(ans)</span>
<span class="sd">    &gt;&gt;&gt; pprint(factor_terms(signsimp(collect_sqrt(n))/d, radical=True))</span>
<span class="sd">            ___             ___</span>
<span class="sd">          \/ 5 *(a + b) - \/ 2 *(x + y)</span>
<span class="sd">    ------------------------------------------</span>
<span class="sd">       2               2      2              2</span>
<span class="sd">    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y</span>

<span class="sd">    If radicals in the denominator cannot be removed or there is no denominator,</span>
<span class="sd">    the original expression will be returned.</span>

<span class="sd">    &gt;&gt;&gt; radsimp(sqrt(2)*x + sqrt(2))</span>
<span class="sd">    sqrt(2)*x + sqrt(2)</span>

<span class="sd">    Results with symbols will not always be valid for all substitutions:</span>

<span class="sd">    &gt;&gt;&gt; eq = 1/(a + b*sqrt(c))</span>
<span class="sd">    &gt;&gt;&gt; eq.subs(a, b*sqrt(c))</span>
<span class="sd">    1/(2*b*sqrt(c))</span>
<span class="sd">    &gt;&gt;&gt; radsimp(eq).subs(a, b*sqrt(c))</span>
<span class="sd">    nan</span>

<span class="sd">    If symbolic=False, symbolic denominators will not be transformed (but</span>
<span class="sd">    numeric denominators will still be processed):</span>

<span class="sd">    &gt;&gt;&gt; radsimp(eq, symbolic=False)</span>
<span class="sd">    1/(a + b*sqrt(c))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.core.mul</span> <span class="kn">import</span> <span class="n">_unevaluated_Mul</span> <span class="k">as</span> <span class="n">_umul</span>
    <span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">Factors</span>

    <span class="n">syms</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;a:d A:D&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_num</span><span class="p">(</span><span class="n">rterms</span><span class="p">):</span>
        <span class="c"># return the multiplier that will simplify the expression described</span>
        <span class="c"># by rterms [(sqrt arg, coeff), ... ]</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">syms</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rterms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])))</span>
            <span class="k">return</span> <span class="p">(</span>
            <span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">a</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rterms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])))</span>
            <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
            <span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rterms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])))</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
                <span class="o">-</span> <span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                <span class="n">D</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                <span class="n">D</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="c"># n can&#39;t be an Atom since expr is not an Atom</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">handle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">_umul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_umul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">sqrtdenest</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">base</span><span class="p">))</span><span class="o">**</span><span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">p</span>
            <span class="k">if</span> <span class="n">d2</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_positive</span><span class="p">):</span>
            <span class="c"># (1/d**i) = (1/d)**i</span>
            <span class="k">return</span> <span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="o">.</span><span class="n">base</span><span class="p">)</span><span class="o">**</span><span class="n">d</span><span class="o">.</span><span class="n">exp</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">handle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="c"># handle 1/d treating d as an Add (though it may not be)</span>

        <span class="n">keep</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c"># keep changes that are made</span>

        <span class="c"># flatten it and collect radicals after checking for special</span>
        <span class="c"># conditions</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c"># did it change?</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span>

        <span class="c"># is it a number that might be handled easily?</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">_d</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_d</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">_d</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">_d</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># collect similar terms</span>
            <span class="n">collected</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>  <span class="c"># d might have become non-Add</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">exp</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span> <span class="ow">or</span>
                            <span class="n">i</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span>
                            <span class="n">log</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">):</span>
                        <span class="n">p2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">exp</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span> <span class="k">else</span> <span class="n">i</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">.</span><span class="n">exp</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
                        <span class="n">p2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">collected</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">p2</span><span class="p">))]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">))</span>
            <span class="n">rterms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
            <span class="n">rterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">),</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rterms</span><span class="p">]</span>
            <span class="n">nrad</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nrad</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">nrad</span> <span class="o">&gt;</span> <span class="n">max_terms</span><span class="p">:</span>
                <span class="c"># there may have been invalid operations leading to this point</span>
                <span class="c"># so don&#39;t keep changes, e.g. this expression is troublesome</span>
                <span class="c"># in collecting terms so as not to raise the issue of 2834:</span>
                <span class="c"># r = sqrt(sqrt(5) + 5)</span>
                <span class="c"># eq = 1/(sqrt(5)*r + 2*sqrt(5)*sqrt(-sqrt(5) + 5) + 5*r)</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c"># in general, only 4 terms can be removed with repeated squaring</span>
                <span class="c"># but other considerations can guide selection of radical terms</span>
                <span class="c"># so that radicals are removed</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Rational</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">rterms</span><span class="p">]):</span>
                    <span class="n">nd</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">rad_rationalize</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">Add</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">rterms</span><span class="p">]))</span>
                    <span class="n">n</span> <span class="o">*=</span> <span class="n">nd</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># is there anything else that might be attempted?</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>

            <span class="n">num</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">_num</span><span class="p">(</span><span class="n">rterms</span><span class="p">))</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="n">num</span>
            <span class="n">d</span> <span class="o">*=</span> <span class="n">num</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">return</span> <span class="n">_umul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>

    <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">handle</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">old</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">was</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Factors</span><span class="p">(</span><span class="n">_umul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">))</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">_umul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">k</span><span class="o">**</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">was</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">n2</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">gcd_terms</span><span class="p">(</span><span class="n">_umul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">d2</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">count_ops</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="o">.</span><span class="n">count_ops</span><span class="p">()):</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">signsimp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">d2</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coeff</span> <span class="o">+</span> <span class="n">_umul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="posify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.posify">[docs]</a><span class="k">def</span> <span class="nf">posify</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return eq (with generic symbols made positive) and a restore</span>
<span class="sd">    dictionary.</span>

<span class="sd">    Any symbol that has positive=None will be replaced with a positive dummy</span>
<span class="sd">    symbol having the same name. This replacement will allow more symbolic</span>
<span class="sd">    processing of expressions, especially those involving powers and</span>
<span class="sd">    logarithms.</span>

<span class="sd">    A dictionary that can be sent to subs to restore eq to its original</span>
<span class="sd">    symbols is also returned.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import posify, Symbol, log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; posify(x + Symbol(&#39;p&#39;, positive=True) + Symbol(&#39;n&#39;, negative=True))</span>
<span class="sd">    (_x + n + p, {_x: x})</span>

<span class="sd">    &gt;&gt; log(1/x).expand() # should be log(1/x) but it comes back as -log(x)</span>
<span class="sd">    log(1/x)</span>

<span class="sd">    &gt;&gt;&gt; log(posify(1/x)[0]).expand() # take [0] and ignore replacements</span>
<span class="sd">    -log(_x)</span>
<span class="sd">    &gt;&gt;&gt; eq, rep = posify(1/x)</span>
<span class="sd">    &gt;&gt;&gt; log(eq).expand().subs(rep)</span>
<span class="sd">    -log(x)</span>
<span class="sd">    &gt;&gt;&gt; posify([x, 1 + x])</span>
<span class="sd">    ([_x, _x + 1], {_x: x})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">))</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">reps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">posify</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
            <span class="n">eq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">])</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

</div>
<span class="k">def</span> <span class="nf">_polarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">polar_lift</span><span class="p">,</span> <span class="n">Integral</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_polar</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pause</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">polar_lift</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pause</span> <span class="ow">and</span> <span class="n">lift</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">polar_lift</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>
    <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_polarify</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">lift</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">polar_lift</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_polarify</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
        <span class="c"># Don&#39;t lift the integration variable</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">limit</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lift</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">limit</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">lift</span><span class="o">=</span><span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span>
            <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var</span><span class="p">,)</span> <span class="o">+</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Integral</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">func</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">limits</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_polarify</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span>
                         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">polarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">lift</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn all numbers in eq into their polar equivalents (under the standard</span>
<span class="sd">    choice of argument).</span>

<span class="sd">    Note that no attempt is made to guess a formal convention of adding</span>
<span class="sd">    polar numbers, expressions like 1 + x will generally not be altered.</span>

<span class="sd">    Note also that this function does not promote exp(x) to exp_polar(x).</span>

<span class="sd">    If ``subs`` is True, all symbols which are not already polar will be</span>
<span class="sd">    substituted for polar dummies; in this case the function behaves much</span>
<span class="sd">    like posify.</span>

<span class="sd">    If ``lift`` is True, both addition statements and non-polar symbols are</span>
<span class="sd">    changed to their polar_lift()ed versions.</span>
<span class="sd">    Note that lift=True implies subs=False.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import polarify, sin, I</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; expr = (-x)**y</span>
<span class="sd">    &gt;&gt;&gt; expr.expand()</span>
<span class="sd">    (-x)**y</span>
<span class="sd">    &gt;&gt;&gt; polarify(expr)</span>
<span class="sd">    ((_x*exp_polar(I*pi))**_y, {_x: x, _y: y})</span>
<span class="sd">    &gt;&gt;&gt; polarify(expr)[0].expand()</span>
<span class="sd">    _x**_y*exp_polar(_y*I*pi)</span>
<span class="sd">    &gt;&gt;&gt; polarify(x, lift=True)</span>
<span class="sd">    polar_lift(x)</span>
<span class="sd">    &gt;&gt;&gt; polarify(x*(1+y), lift=True)</span>
<span class="sd">    polar_lift(x)*polar_lift(y + 1)</span>

<span class="sd">    Adds are treated carefully:</span>

<span class="sd">    &gt;&gt;&gt; polarify(1 + sin((1 + I)*x))</span>
<span class="sd">    (sin(_x*polar_lift(1 + I)) + 1, {_x: x})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lift</span><span class="p">:</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="n">lift</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">subs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)])</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>


<span class="k">def</span> <span class="nf">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">polar_lift</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">principal_branch</span><span class="p">,</span> <span class="n">pi</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pause</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp_polar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">principal_branch</span> <span class="ow">and</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exponents_only</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Boolean</span> <span class="ow">or</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">is_Relational</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">rel_op</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;==&#39;</span><span class="p">,</span> <span class="s">&#39;!=&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">rel_op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;==&#39;</span><span class="p">,</span> <span class="s">&#39;!=&#39;</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">polar_lift</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exponents_only</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="n">expo</span> <span class="o">=</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span>
            <span class="ow">not</span> <span class="p">(</span><span class="n">expo</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pause</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">**</span><span class="n">expo</span>

    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="s">&#39;unbranched&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">{},</span> <span class="n">exponents_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If p denotes the projection from the Riemann surface of the logarithm to</span>
<span class="sd">    the complex line, return a simplified version eq&#39; of `eq` such that</span>
<span class="sd">    p(eq&#39;) == p(eq).</span>
<span class="sd">    Also apply the substitution subs in the end. (This is a convenience, since</span>
<span class="sd">    ``unpolarify``, in a certain sense, undoes polarify.)</span>

<span class="sd">    &gt;&gt;&gt; from sympy import unpolarify, polar_lift, sin, I</span>
<span class="sd">    &gt;&gt;&gt; unpolarify(polar_lift(I + 2))</span>
<span class="sd">    2 + I</span>
<span class="sd">    &gt;&gt;&gt; unpolarify(sin(polar_lift(I + 7)))</span>
<span class="sd">    sin(7 + I)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">polar_lift</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subs</span> <span class="o">!=</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="n">unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">))</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">pause</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">exponents_only</span><span class="p">:</span>
        <span class="n">pause</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="n">eq</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">res</span>
    <span class="c"># Finally, replacing Exp(0) by 1 is always correct.</span>
    <span class="c"># So is polar_lift(0) -&gt; 0.</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="n">polar_lift</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="mi">0</span><span class="p">})</span>


<span class="k">def</span> <span class="nf">_denest_pow</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Denest powers.</span>

<span class="sd">    This is a helper function for powdenest that performs the actual</span>
<span class="sd">    transformation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>

    <span class="c"># denest exp with log terms in exponent</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ai</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">ei</span><span class="p">)):</span>
                <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">logs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logs</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">))</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">be</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">be</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span>
                            <span class="n">b</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span>
                            <span class="n">b</span><span class="o">.</span><span class="n">is_positive</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="c"># denest eq which is either pos**e or Pow**e or Mul**e or</span>
    <span class="c"># Mul(b1**e1, b2**e2)</span>

    <span class="c"># handle polar numbers specially</span>
    <span class="n">polars</span><span class="p">,</span> <span class="n">nonpolars</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bb</span><span class="o">.</span><span class="n">is_polar</span><span class="p">:</span>
            <span class="n">polars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bb</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nonpolars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">polars</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">polars</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">polars</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="o">*</span><span class="n">powdenest</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nonpolars</span><span class="p">)</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">polars</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">powdenest</span><span class="p">(</span><span class="n">bb</span><span class="o">**</span><span class="p">(</span><span class="n">ee</span><span class="o">*</span><span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">ee</span><span class="p">)</span> <span class="ow">in</span> <span class="n">polars</span><span class="p">])</span> \
            <span class="o">*</span><span class="n">powdenest</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nonpolars</span><span class="p">)</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>

    <span class="c"># see if there is a positive, non-Mul base at the very bottom</span>
    <span class="n">exponents</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">eq</span>
    <span class="k">while</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="n">kernel</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
        <span class="n">exponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">exponents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="c"># use log to see if there is a power here</span>
                <span class="n">logkernel</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">kernel</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">logkernel</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">logk</span> <span class="o">=</span> <span class="n">logkernel</span><span class="o">.</span><span class="n">args</span>
                    <span class="n">e</span> <span class="o">*=</span> <span class="n">c</span>
                    <span class="n">kernel</span> <span class="o">=</span> <span class="n">logk</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

    <span class="c"># if any factor is an atom then there is nothing to be done</span>
    <span class="c"># but the kernel check may have created a new exponent</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_Atom</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">exponents</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">**</span><span class="n">e</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="c"># let log handle the case of the base of the argument being a mul, e.g.</span>
    <span class="c"># sqrt(x**(2*i)*y**(6*i)) -&gt; x**i*y**(3**i) if x and y are positive; we</span>
    <span class="c"># will take the log, expand it, and then factor out the common powers that</span>
    <span class="c"># now appear as coefficient. We do this manually since terms_gcd pulls out</span>
    <span class="c"># fractions, terms_gcd(x+x*y/2) -&gt; x*(y + 2)/2 and we don&#39;t want the 1/2;</span>
    <span class="c"># gcd won&#39;t pull out numerators from a fraction: gcd(3*x, 9*x/2) -&gt; x but</span>
    <span class="c"># we want 3*x. Neither work with noncommutatives.</span>

    <span class="k">def</span> <span class="nf">nc_gcd</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">]]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">_keep_coeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="n">glogb</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">glogb</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span>
        <span class="n">g</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">nc_gcd</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cg</span><span class="p">,</span> <span class="n">rg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="n">glogb</span> <span class="o">=</span> <span class="n">_keep_coeff</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">rg</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">a</span><span class="o">/</span><span class="n">g</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]))</span>

    <span class="c"># now put the log back together again</span>
    <span class="k">if</span> <span class="n">glogb</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">glogb</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">:</span>
            <span class="n">glogb</span> <span class="o">=</span> <span class="n">_denest_pow</span><span class="p">(</span><span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">glogb</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">glogb</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">glogb</span><span class="o">.</span><span class="n">exp</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="c"># the log(b) was a Mul so join any adds with logcombine</span>
    <span class="n">add</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logcombine</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">))),</span> <span class="n">e</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">))</span>


<div class="viewcode-block" id="powdenest"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.powdenest">[docs]</a><span class="k">def</span> <span class="nf">powdenest</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Collect exponents on powers as assumptions allow.</span>

<span class="sd">    Given ``(bb**be)**e``, this can be simplified as follows:</span>
<span class="sd">        * if ``bb`` is positive, or</span>
<span class="sd">        * ``e`` is an integer, or</span>
<span class="sd">        * ``|be| &lt; 1`` then this simplifies to ``bb**(be*e)``</span>

<span class="sd">    Given a product of powers raised to a power, ``(bb1**be1 *</span>
<span class="sd">    bb2**be2...)**e``, simplification can be done as follows:</span>

<span class="sd">    - if e is positive, the gcd of all bei can be joined with e;</span>
<span class="sd">    - all non-negative bb can be separated from those that are negative</span>
<span class="sd">      and their gcd can be joined with e; autosimplification already</span>
<span class="sd">      handles this separation.</span>
<span class="sd">    - integer factors from powers that have integers in the denominator</span>
<span class="sd">      of the exponent can be removed from any term and the gcd of such</span>
<span class="sd">      integers can be joined with e</span>

<span class="sd">    Setting ``force`` to True will make symbols that are not explicitly</span>
<span class="sd">    negative behave as though they are positive, resulting in more</span>
<span class="sd">    denesting.</span>

<span class="sd">    Setting ``polar`` to True will do simplifications on the riemann surface of</span>
<span class="sd">    the logarithm, also resulting in more denestings.</span>

<span class="sd">    When there are sums of logs in exp() then a product of powers may be</span>
<span class="sd">    obtained e.g. ``exp(3*(log(a) + 2*log(b)))`` - &gt; ``a**3*b**6``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, exp, log, sqrt, symbols, powdenest</span>

<span class="sd">    &gt;&gt;&gt; powdenest((x**(2*a/3))**(3*x))</span>
<span class="sd">    (x**(2*a/3))**(3*x)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(exp(3*x*log(2)))</span>
<span class="sd">    2**(3*x)</span>

<span class="sd">    Assumptions may prevent expansion:</span>

<span class="sd">    &gt;&gt;&gt; powdenest(sqrt(x**2))</span>
<span class="sd">    sqrt(x**2)</span>

<span class="sd">    &gt;&gt;&gt; p = symbols(&#39;p&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(sqrt(p**2))</span>
<span class="sd">    p</span>

<span class="sd">    No other expansion is done.</span>

<span class="sd">    &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, integer=True)</span>
<span class="sd">    &gt;&gt;&gt; powdenest((x**x)**(i + j)) # -X-&gt; (x**x)**i*(x**x)**j</span>
<span class="sd">    x**(x*(i + j))</span>

<span class="sd">    But exp() will be denested by moving all non-log terms outside of</span>
<span class="sd">    the function; this may result in the collapsing of the exp to a power</span>
<span class="sd">    with a different base:</span>

<span class="sd">    &gt;&gt;&gt; powdenest(exp(3*y*log(x)))</span>
<span class="sd">    x**(3*y)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(exp(y*(log(a) + log(b))))</span>
<span class="sd">    (a*b)**y</span>
<span class="sd">    &gt;&gt;&gt; powdenest(exp(3*(log(a) + log(b))))</span>
<span class="sd">    a**3*b**3</span>

<span class="sd">    If assumptions allow, symbols can also be moved to the outermost exponent:</span>

<span class="sd">    &gt;&gt;&gt; i = Symbol(&#39;i&#39;, integer=True)</span>
<span class="sd">    &gt;&gt;&gt; p = Symbol(&#39;p&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(((x**(2*i))**(3*y))**x)</span>
<span class="sd">    ((x**(2*i))**(3*y))**x</span>
<span class="sd">    &gt;&gt;&gt; powdenest(((x**(2*i))**(3*y))**x, force=True)</span>
<span class="sd">    x**(6*i*x*y)</span>

<span class="sd">    &gt;&gt;&gt; powdenest(((p**(2*a))**(3*y))**x)</span>
<span class="sd">    p**(6*a*x*y)</span>

<span class="sd">    &gt;&gt;&gt; powdenest(((x**(2*a/3))**(3*y/i))**x)</span>
<span class="sd">    ((x**(2*a/3))**(3*y/i))**x</span>
<span class="sd">    &gt;&gt;&gt; powdenest((x**(2*i)*y**(4*i))**z, force=True)</span>
<span class="sd">    (x*y**2)**(2*i*z)</span>

<span class="sd">    &gt;&gt;&gt; n = Symbol(&#39;n&#39;, negative=True)</span>

<span class="sd">    &gt;&gt;&gt; powdenest((x**i)**y, force=True)</span>
<span class="sd">    x**(i*y)</span>
<span class="sd">    &gt;&gt;&gt; powdenest((n**i)**x, force=True)</span>
<span class="sd">    (n**i)**x</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">polar</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">polarify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unpolarify</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">exponents_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)),</span> <span class="n">rep</span><span class="p">)</span>

    <span class="n">new</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">Transform</span><span class="p">(</span>
        <span class="n">_denest_pow</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">m</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">))</span>
</div>
<span class="n">_y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="powsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.powsimp">[docs]</a><span class="k">def</span> <span class="nf">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">count_ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reduces expression by combining powers with similar bases and exponents.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    If deep is True then powsimp() will also simplify arguments of</span>
<span class="sd">    functions. By default deep is set to False.</span>

<span class="sd">    If force is True then bases will be combined without checking for</span>
<span class="sd">    assumptions, e.g. sqrt(x)*sqrt(y) -&gt; sqrt(x*y) which is not true</span>
<span class="sd">    if x and y are both negative.</span>

<span class="sd">    You can make powsimp() only combine bases or only combine exponents by</span>
<span class="sd">    changing combine=&#39;base&#39; or combine=&#39;exp&#39;.  By default, combine=&#39;all&#39;,</span>
<span class="sd">    which does both.  combine=&#39;base&#39; will only combine::</span>

<span class="sd">         a   a          a                          2x      x</span>
<span class="sd">        x * y  =&gt;  (x*y)   as well as things like 2   =&gt;  4</span>

<span class="sd">    and combine=&#39;exp&#39; will only combine</span>
<span class="sd">    ::</span>

<span class="sd">         a   b      (a + b)</span>
<span class="sd">        x * x  =&gt;  x</span>

<span class="sd">    combine=&#39;exp&#39; will strictly only combine exponents in the way that used</span>
<span class="sd">    to be automatic.  Also use deep=True if you need the old behavior.</span>

<span class="sd">    When combine=&#39;all&#39;, &#39;exp&#39; is evaluated first.  Consider the first</span>
<span class="sd">    example below for when there could be an ambiguity relating to this.</span>
<span class="sd">    This is done so things like the second example can be completely</span>
<span class="sd">    combined.  If you want &#39;base&#39; combined first, do something like</span>
<span class="sd">    powsimp(powsimp(expr, combine=&#39;base&#39;), combine=&#39;exp&#39;).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import powsimp, exp, log, symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z, n</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**y*x**z*y**z, combine=&#39;all&#39;)</span>
<span class="sd">    x**(y + z)*y**z</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**y*x**z*y**z, combine=&#39;exp&#39;)</span>
<span class="sd">    x**(y + z)*y**z</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**y*x**z*y**z, combine=&#39;base&#39;, force=True)</span>
<span class="sd">    x**y*(x*y)**z</span>

<span class="sd">    &gt;&gt;&gt; powsimp(x**z*x**y*n**z*n**y, combine=&#39;all&#39;, force=True)</span>
<span class="sd">    (n*x)**(y + z)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**z*x**y*n**z*n**y, combine=&#39;exp&#39;)</span>
<span class="sd">    n**(y + z)*x**(y + z)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**z*x**y*n**z*n**y, combine=&#39;base&#39;, force=True)</span>
<span class="sd">    (n*x)**y*(n*x)**z</span>

<span class="sd">    &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(log(exp(x)*exp(y)))</span>
<span class="sd">    log(exp(x)*exp(y))</span>
<span class="sd">    &gt;&gt;&gt; powsimp(log(exp(x)*exp(y)), deep=True)</span>
<span class="sd">    x + y</span>

<span class="sd">    Radicals with Mul bases will be combined if combine=&#39;exp&#39;</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt, Mul</span>
<span class="sd">    &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;)</span>

<span class="sd">    Two radicals are automatically joined through Mul:</span>
<span class="sd">    &gt;&gt;&gt; a=sqrt(x*sqrt(y))</span>
<span class="sd">    &gt;&gt;&gt; a*a**3 == a**4</span>
<span class="sd">    True</span>

<span class="sd">    But if an integer power of that radical has been</span>
<span class="sd">    autoexpanded then Mul does not join the resulting factors:</span>
<span class="sd">    &gt;&gt;&gt; a**4 # auto expands to a Mul, no longer a Pow</span>
<span class="sd">    x**2*y</span>
<span class="sd">    &gt;&gt;&gt; _*a # so Mul doesn&#39;t combine them</span>
<span class="sd">    x**2*y*sqrt(x*sqrt(y))</span>
<span class="sd">    &gt;&gt;&gt; powsimp(_) # but powsimp will</span>
<span class="sd">    (x*sqrt(y))**(5/2)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x*y*a) # but won&#39;t when doing so would violate assumptions</span>
<span class="sd">    x*y*sqrt(x*sqrt(y))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_deep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;deep&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
        <span class="n">_combine</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;combine&#39;</span><span class="p">,</span> <span class="n">combine</span><span class="p">)</span>
        <span class="n">_force</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
        <span class="n">_measure</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;measure&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_deep</span><span class="p">,</span> <span class="n">_combine</span><span class="p">,</span> <span class="n">_force</span><span class="p">,</span> <span class="n">_measure</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="n">expr</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">exp_polar</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">exp_polar</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="n">deep</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">_y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">recurse</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expr</span><span class="o">*</span><span class="n">_y</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">/</span><span class="n">_y</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># handle the Mul</span>
    <span class="k">if</span> <span class="n">combine</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;exp&#39;</span><span class="p">,</span> <span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="c"># Collect base/exp data, while maintaining order in the</span>
        <span class="c"># non-commutative parts of the product</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">nc_part</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">*=</span> <span class="n">term</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">_denest_pow</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                    <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">recurse</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">]]</span>
                <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># This is the logic that combines exponents for equal,</span>
                <span class="c"># but non-commutative bases: A**x*A**y == A**(x+y).</span>
                <span class="k">if</span> <span class="n">nc_part</span><span class="p">:</span>
                    <span class="n">b1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="n">b2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span> <span class="ow">and</span>
                            <span class="n">e1</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="n">e2</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">):</span>
                        <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
                        <span class="k">continue</span>
                <span class="n">nc_part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="c"># add up exponents of common bases</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">())):</span>
            <span class="c"># allow 2**x/4 -&gt; 2**(x - 2); don&#39;t do this when b and e are</span>
            <span class="c"># Numbers since autoevaluation will undo it, e.g.</span>
            <span class="c"># 2**(1/3)/4 -&gt; 2**(1/3 - 2) -&gt; 2**(1/3)/4</span>
            <span class="k">assert</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">ei</span><span class="o">.</span><span class="n">is_Number</span> <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">e</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span>
                    <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">)):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">multiplicity</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coeff</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">coeff</span> <span class="o">/=</span> <span class="n">b</span><span class="o">**</span><span class="n">m</span>
            <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
                <span class="n">c_powers</span><span class="p">[</span><span class="n">coeff</span><span class="p">]</span> <span class="o">+=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_powers</span><span class="p">[</span><span class="n">coeff</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="c"># convert to plain dictionary</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)</span>

        <span class="c"># check for base and inverted base pairs</span>
        <span class="n">be</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c"># skip if we already saw them</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">be</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">skip</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bpos</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_polar</span>
            <span class="k">if</span> <span class="n">bpos</span><span class="p">:</span>
                <span class="n">binv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">b</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">binv</span> <span class="ow">and</span> <span class="n">binv</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                        <span class="n">c_powers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">c_powers</span><span class="p">[</span><span class="n">binv</span><span class="p">]</span> <span class="o">-=</span> <span class="n">e</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">skip</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">binv</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">binv</span><span class="p">)</span>
                        <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-=</span> <span class="n">e</span>

        <span class="c"># check for base and negated base pairs</span>
        <span class="n">be</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">be</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">((</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Add</span><span class="p">)</span> <span class="ow">and</span> <span class="o">-</span><span class="n">b</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_integer</span><span class="p">):</span>
                    <span class="n">c_powers</span><span class="p">[</span><span class="o">-</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_n</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
                        <span class="n">c_powers</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">c_powers</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>

        <span class="c"># filter c_powers and convert to a list</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="p">]</span>

        <span class="c"># ==============================================================</span>
        <span class="c"># check for Mul bases of Rational powers that can be combined with</span>
        <span class="c"># separated bases, e.g. x*sqrt(x*y)*sqrt(x*sqrt(x*y)) -&gt;</span>
        <span class="c"># (x*sqrt(x*y))**(3/2)</span>
        <span class="c"># ---------------- helper functions</span>

        <span class="k">def</span> <span class="nf">ratq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Return Rational part of x&#39;s exponent as it appears in the bkey.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">return</span> <span class="n">bkey</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">bkey</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Return (b**s, c.q), c.p where e -&gt; c*s. If e is not given then</span>
<span class="sd">            it will be taken by using as_base_exp() on the input b.</span>
<span class="sd">            e.g.</span>
<span class="sd">                x**3/2 -&gt; (x, 2), 3</span>
<span class="sd">                x**y -&gt; (x**y, 1), 1</span>
<span class="sd">                x**(2*y/3) -&gt; (x**y, 3), 2</span>
<span class="sd">                exp(x/2) -&gt; (exp(a), 2), 1</span>

<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># coming from c_powers or from below</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span> <span class="n">e</span>
                <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Integer</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">q</span><span class="p">)),</span> <span class="n">Integer</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="n">m</span><span class="p">,</span> <span class="n">Integer</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">q</span><span class="p">)),</span> <span class="n">Integer</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="n">e</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">bkey</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Decide what to do with base, b. If its exponent is now an</span>
<span class="sd">            integer multiple of the Rational denominator, then remove it</span>
<span class="sd">            and put the factors of its base in the common_b dictionary or</span>
<span class="sd">            update the existing bases if necessary. If it has been zeroed</span>
<span class="sd">            out, simply remove the base.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">newe</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">common_b</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newe</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">newe</span><span class="p">):</span>
                        <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">bkey</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_b</span><span class="p">:</span>
                            <span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span>
                        <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c"># ---------------- end of helper functions</span>

        <span class="c"># assemble a dictionary of the factors having a Rational power</span>
        <span class="n">common_b</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">done</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">bkey</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">bases</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>  <span class="c"># this makes tie-breaking canonical</span>
        <span class="n">bases</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">measure</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># handle longest first</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_b</span><span class="p">:</span>  <span class="c"># it may have been removed already</span>
                <span class="k">continue</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">exponent</span> <span class="o">=</span> <span class="n">base</span>
            <span class="n">last</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># True when no factor of base is a radical</span>
            <span class="n">qlcm</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># the lcm of the radical denominators</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">bstart</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">qstart</span> <span class="o">=</span> <span class="n">qlcm</span>

                <span class="n">bb</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># list of factors</span>
                <span class="n">ee</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># (factor&#39;s expo. and it&#39;s current value in common_b)</span>
                <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="n">bib</span><span class="p">,</span> <span class="n">bie</span> <span class="o">=</span> <span class="n">bkey</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bib</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_b</span> <span class="ow">or</span> <span class="n">common_b</span><span class="p">[</span><span class="n">bib</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bie</span><span class="p">:</span>
                        <span class="n">ee</span> <span class="o">=</span> <span class="n">bb</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># failed</span>
                        <span class="k">break</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bie</span><span class="p">,</span> <span class="n">common_b</span><span class="p">[</span><span class="n">bib</span><span class="p">]])</span>
                    <span class="n">bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bib</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ee</span><span class="p">:</span>
                    <span class="c"># find the number of extractions possible</span>
                    <span class="c"># e.g. [(1, 2), (2, 2)] -&gt; min(2/1, 2/2) -&gt; 1</span>
                    <span class="n">min1</span> <span class="o">=</span> <span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ee</span><span class="p">)):</span>
                        <span class="n">rat</span> <span class="o">=</span> <span class="n">ee</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">ee</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">rat</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">min1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">rat</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># update base factor counts</span>
                        <span class="c"># e.g. if ee = [(2, 5), (3, 6)] then min1 = 2</span>
                        <span class="c"># and the new base counts will be 5-2*2 and 6-2*3</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bb</span><span class="p">)):</span>
                            <span class="n">common_b</span><span class="p">[</span><span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">min1</span><span class="o">*</span><span class="n">ee</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">update</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="c"># update the count of the base</span>
                        <span class="c"># e.g. x**2*y*sqrt(x*sqrt(y)) the count of x*sqrt(y)</span>
                        <span class="c"># will increase by 4 to give bkey (x*sqrt(y), 2, 5)</span>
                        <span class="n">common_b</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min1</span><span class="o">*</span><span class="n">qstart</span><span class="o">*</span><span class="n">exponent</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">last</span>  <span class="c"># no more radicals in base</span>
                    <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c"># nothing left to join with</span>
                    <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">common_b</span><span class="p">)</span>  <span class="c"># no rad&#39;s in common_b</span>
                        <span class="p">):</span>
                    <span class="k">break</span>
                <span class="c"># see what we can exponentiate base by to remove any radicals</span>
                <span class="c"># so we know what to search for</span>
                <span class="c"># e.g. if base were x**(1/2)*y**(1/3) then we should</span>
                <span class="c"># exponentiate by 6 and look for powers of x and y in the ratio</span>
                <span class="c"># of 2 to 3</span>
                <span class="n">qlcm</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">([</span><span class="n">ratq</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">bstart</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">qlcm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c"># we are done</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">bstart</span><span class="o">**</span><span class="n">qlcm</span>
                <span class="n">qlcm</span> <span class="o">*=</span> <span class="n">qstart</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ratq</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c"># we are going to be done after this next pass</span>
            <span class="c"># this base no longer can find anything to join with and</span>
            <span class="c"># since it was longer than any other we are done with it</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">base</span>
            <span class="n">done</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">common_b</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">*</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">)))</span>

        <span class="c"># update c_powers and get ready to continue with powsimp</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="n">done</span>
        <span class="c"># there may be terms still in common_b that were bases that were</span>
        <span class="c"># identified as needing processing, so remove those, too</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">common_b</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">be</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="p">(</span><span class="n">be</span><span class="o">/</span><span class="n">q</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">c_powers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
        <span class="n">check</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)</span> <span class="o">==</span> <span class="n">check</span>  <span class="c"># there should have been no duplicates</span>
        <span class="c"># ==============================================================</span>

        <span class="c"># rebuild the expression</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">newexpr</span> <span class="o">+</span> <span class="p">[</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">()]))</span>
        <span class="k">if</span> <span class="n">combine</span> <span class="o">==</span> <span class="s">&#39;exp&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">nc_part</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">nc_part</span><span class="p">),</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;base&#39;</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">recurse</span><span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;base&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">combine</span> <span class="o">==</span> <span class="s">&#39;base&#39;</span><span class="p">:</span>

        <span class="c"># Build c_powers and nc_part.  These must both be lists not</span>
        <span class="c"># dicts because exp&#39;s are not combined.</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nc_part</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">c_powers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># This is the logic that combines bases that are</span>
                <span class="c"># different and non-commutative, but with equal and</span>
                <span class="c"># commutative exponents: A**x*B**x == (A*B)**x.</span>
                <span class="k">if</span> <span class="n">nc_part</span><span class="p">:</span>
                    <span class="n">b1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="n">b2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span> <span class="ow">and</span> <span class="n">e2</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">):</span>
                        <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">b1</span><span class="o">*</span><span class="n">b2</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="n">nc_part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="c"># Pull out numerical coefficients from exponent if assumptions allow</span>
        <span class="c"># e.g., 2**(2*x) =&gt; 4**x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)):</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">c_powers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">force</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_polar</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">exp_c</span><span class="p">,</span> <span class="n">exp_t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exp_c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span> <span class="n">exp_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="n">c_powers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">exp_c</span><span class="p">),</span> <span class="n">exp_t</span><span class="p">]</span>

        <span class="c"># Combine bases whenever they have the same exponent and</span>
        <span class="c"># assumptions allow</span>
        <span class="c"># first gather the potential bases under the common exponent</span>
        <span class="n">c_exp</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">c_exp</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">c_powers</span>

        <span class="c"># Merge back in the results of the above to form a new product</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_exp</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">c_exp</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>

            <span class="c"># calculate the new base for e</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_base</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
                <span class="n">new_base</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">bases</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># see which ones can be joined</span>
                <span class="n">unk</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">nonneg</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bi</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                        <span class="n">neg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bi</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">:</span>
                        <span class="n">nonneg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bi</span><span class="o">.</span><span class="n">is_polar</span><span class="p">:</span>
                        <span class="n">nonneg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">bi</span><span class="p">)</span>  <span class="c"># polar can be treated like non-negative</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">unk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">neg</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">unk</span><span class="p">:</span>
                    <span class="c"># a single neg or a single unk can join the rest</span>
                    <span class="n">nonneg</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unk</span> <span class="o">+</span> <span class="n">neg</span><span class="p">)</span>
                    <span class="n">unk</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">elif</span> <span class="n">neg</span><span class="p">:</span>
                    <span class="c"># their negative signs cancel in groups of 2*q if we know</span>
                    <span class="c"># that e = p/q else we have to treat them as unknown</span>
                    <span class="n">israt</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                        <span class="n">israt</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
                            <span class="n">israt</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">israt</span><span class="p">:</span>
                        <span class="n">neg</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">neg</span><span class="p">]</span>
                        <span class="n">unk</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">unk</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span>
                        <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">del</span> <span class="n">israt</span>

                <span class="c"># these shouldn&#39;t be joined</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">unk</span><span class="p">:</span>
                    <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="c"># here is a new joined base</span>
                <span class="n">new_base</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">nonneg</span> <span class="o">+</span> <span class="n">neg</span><span class="p">))</span>
                <span class="c"># if there are positive parts they will just get separated</span>
                <span class="c"># again unless some change is made</span>

                <span class="k">def</span> <span class="nf">_terms</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="c"># return the number of terms of this expression</span>
                    <span class="c"># when multiplied out -- assuming no joining of terms</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">_terms</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">prod</span><span class="p">([</span><span class="n">_terms</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="n">xnew_base</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">xnew_base</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">_terms</span><span class="p">(</span><span class="n">new_base</span><span class="p">):</span>
                    <span class="n">new_base</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">xnew_base</span><span class="p">)</span>

            <span class="n">c_powers</span><span class="p">[</span><span class="n">new_base</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="c"># break out the powers from c_powers now</span>
        <span class="n">c_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ei</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>

        <span class="c"># we&#39;re done</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c_part</span> <span class="o">+</span> <span class="n">nc_part</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;combine must be one of (&#39;all&#39;, &#39;exp&#39;, &#39;base&#39;).&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="hypersimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.hypersimp">[docs]</a><span class="k">def</span> <span class="nf">hypersimp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given combinatorial term f(k) simplify its consecutive term ratio</span>
<span class="sd">       i.e. f(k+1)/f(k).  The input term can be composed of functions and</span>
<span class="sd">       integer sequences which have equivalent representation in terms</span>
<span class="sd">       of gamma special function.</span>

<span class="sd">       The algorithm performs three basic steps:</span>

<span class="sd">       1. Rewrite all functions in terms of gamma, if possible.</span>

<span class="sd">       2. Rewrite all occurrences of gamma in terms of products</span>
<span class="sd">          of gamma and rising factorial with integer,  absolute</span>
<span class="sd">          constant exponent.</span>

<span class="sd">       3. Perform simplification of nested fractions, powers</span>
<span class="sd">          and if the resulting expression is a quotient of</span>
<span class="sd">          polynomials, reduce their total degree.</span>

<span class="sd">       If f(k) is hypergeometric then as result we arrive with a</span>
<span class="sd">       quotient of polynomials of minimal degree. Otherwise None</span>
<span class="sd">       is returned.</span>

<span class="sd">       For more information on the implemented algorithm refer to:</span>

<span class="sd">       1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,</span>
<span class="sd">          Journal of Symbolic Computation (1995) 20, 399-417</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">f</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<div class="viewcode-block" id="hypersimilar"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.hypersimilar">[docs]</a><span class="k">def</span> <span class="nf">hypersimilar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if &#39;f&#39; and &#39;g&#39; are hyper-similar.</span>

<span class="sd">       Similarity in hypergeometric sense means that a quotient of</span>
<span class="sd">       f(k) and g(k) is a rational function in k.  This procedure</span>
<span class="sd">       is useful in solving recurrence relations.</span>

<span class="sd">       For more information see hypersimp().</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)))</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</div>
<span class="kn">from</span> <span class="nn">sympy.utilities.timeutils</span> <span class="kn">import</span> <span class="n">timethis</span>


<span class="nd">@timethis</span><span class="p">(</span><span class="s">&#39;combsimp&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="combsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.combsimp">[docs]</a><span class="k">def</span> <span class="nf">combsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Simplify combinatorial expressions.</span>

<span class="sd">    This function takes as input an expression containing factorials,</span>
<span class="sd">    binomials, Pochhammer symbol and other &quot;combinatorial&quot; functions,</span>
<span class="sd">    and tries to minimize the number of those functions and reduce</span>
<span class="sd">    the size of their arguments. The result is be given in terms of</span>
<span class="sd">    binomials and factorials.</span>

<span class="sd">    The algorithm works by rewriting all combinatorial functions as</span>
<span class="sd">    expressions involving rising factorials (Pochhammer symbols) and</span>
<span class="sd">    applies recurrence relations and other transformations applicable</span>
<span class="sd">    to rising factorials, to reduce their arguments, possibly letting</span>
<span class="sd">    the resulting rising factorial to cancel. Rising factorials with</span>
<span class="sd">    the second argument being an integer are expanded into polynomial</span>
<span class="sd">    forms and finally all other rising factorial are rewritten in terms</span>
<span class="sd">    more familiar functions. If the initial expression contained any</span>
<span class="sd">    combinatorial functions, the result is expressed using binomial</span>
<span class="sd">    coefficients and gamma functions. If the initial expression consisted</span>
<span class="sd">    of gamma functions alone, the result is expressed in terms of gamma</span>
<span class="sd">    functions.</span>

<span class="sd">    If the result is expressed using gamma functions, the following three</span>
<span class="sd">    additional steps are performed:</span>

<span class="sd">    1. Reduce the number of gammas by applying the reflection theorem</span>
<span class="sd">       gamma(x)*gamma(1-x) == pi/sin(pi*x).</span>
<span class="sd">    2. Reduce the number of gammas by applying the multiplication theorem</span>
<span class="sd">       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).</span>
<span class="sd">    3. Reduce the number of prefactors by absorbing them into gammas, where</span>
<span class="sd">       possible.</span>

<span class="sd">    All transformation rules can be found (or was derived from) here:</span>

<span class="sd">    1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/</span>
<span class="sd">    2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify import combsimp</span>
<span class="sd">    &gt;&gt;&gt; from sympy import factorial, binomial</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import n, k</span>

<span class="sd">    &gt;&gt;&gt; combsimp(factorial(n)/factorial(n - 3))</span>
<span class="sd">    n*(n - 2)*(n - 1)</span>
<span class="sd">    &gt;&gt;&gt; combsimp(binomial(n+1, k+1)/binomial(n, k))</span>
<span class="sd">    (n + 1)/(k + 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">factorial</span>
    <span class="n">binomial</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">binomial</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">gamma</span>

    <span class="c"># as a rule of thumb, if the expression contained gammas initially, it</span>
    <span class="c"># probably makes sense to retain them</span>
    <span class="n">as_gamma</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span> <span class="n">binomial</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">rf</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

                <span class="n">n</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span>

                    <span class="k">return</span> <span class="n">result</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">i</span>

                    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">*</span><span class="n">rf</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">_b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">binomial</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">rf</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">k</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>

    <span class="k">if</span> <span class="n">as_gamma</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">binomial</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rule</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">rewrite</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">False</span>

        <span class="n">cn</span><span class="p">,</span> <span class="n">_n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">_n</span> <span class="ow">and</span> <span class="n">cn</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">cn</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">rf</span><span class="p">(</span><span class="n">_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cn</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cn</span><span class="p">)</span>
            <span class="n">rewrite</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_n</span>

        <span class="c"># this sort of binomial has already been removed by</span>
        <span class="c"># rising factorials but is left here in case the order</span>
        <span class="c"># of rule application is changed</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">ck</span><span class="p">,</span> <span class="n">_k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">_k</span> <span class="ow">and</span> <span class="n">ck</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">ck</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">*=</span> <span class="n">rf</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">ck</span> <span class="o">-</span> <span class="n">_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ck</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ck</span><span class="p">)</span>
                <span class="n">rewrite</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">_k</span>

        <span class="k">if</span> <span class="n">rewrite</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">binomial</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rule_gamma</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simplify products of gamma functions further. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="k">def</span> <span class="nf">gamma_rat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># helper to simplify ratios of gammas</span>
            <span class="n">was</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
            <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">was</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xx</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">def</span> <span class="nf">gamma_factor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># return True if there is a gamma factor in shallow args</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">gamma_factor</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_positive</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">gamma_factor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># recursion step</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">rule_gamma</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="c"># non-commutative step</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expr</span>
            <span class="k">if</span> <span class="n">nc</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rule_gamma</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># pure gamma handling, not factor absorbtion</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sifted</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">gamma_factor</span><span class="p">)</span>
            <span class="n">gamma_ind</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">sifted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">sifted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">sifted</span>

            <span class="n">nd</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ipass</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">nd</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ni</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="n">ni</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                            <span class="n">rule_gamma</span><span class="p">(</span><span class="n">gamma_rat</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">dd</span><span class="p">),</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ni</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                        <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ni</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">dd</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">gamma</span><span class="p">):</span>
                            <span class="k">break</span>
                <span class="n">nd</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ipass</span> <span class="o">==</span>  <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gamma_factor</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">nd</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">dd</span><span class="p">,</span> <span class="n">nd</span>  <span class="c"># now process in reversed order</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">gamma_ind</span><span class="o">*</span><span class="n">nd</span><span class="o">/</span><span class="n">dd</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gamma_factor</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma_factor</span><span class="p">(</span><span class="n">nd</span><span class="p">))):</span>
                <span class="k">return</span> <span class="n">expr</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># iteration until constant</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">was</span> <span class="o">=</span> <span class="n">expr</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">rule_gamma</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">expr</span>

        <span class="n">numer_gammas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_gammas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numer_others</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_others</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">explicate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[]</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">gamma</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>

        <span class="n">newargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">newargs</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">newargs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="n">isg</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">explicate</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isg</span><span class="p">:</span>
                <span class="n">numer_gammas</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">isg</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">numer_others</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">isg</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">explicate</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isg</span><span class="p">:</span>
                <span class="n">denom_gammas</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">isg</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">denom_others</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="c"># =========== level 2 work: pure gamma manipulation =========</span>

        <span class="c"># Try to reduce the number of gamma factors by applying the</span>
        <span class="c"># reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)</span>
        <span class="k">for</span> <span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span>
            <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">gammas</span><span class="p">:</span>
                <span class="n">g1</span> <span class="o">=</span> <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gammas</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">)</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="o">*</span><span class="n">g1</span><span class="p">))</span>
                    <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">):</span>
                            <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">g1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span>
            <span class="c"># /!\ updating IN PLACE</span>
            <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new</span>

        <span class="c"># Try to reduce the number of gammas by using the duplication</span>
        <span class="c"># theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =</span>
        <span class="c"># 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could</span>
        <span class="c"># be done with higher argument ratios like gamma(3*x)/gamma(x),</span>
        <span class="c"># this would not reduce the number of gammas as in this case.</span>
        <span class="k">for</span> <span class="n">ng</span><span class="p">,</span> <span class="n">dg</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">do</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">numer_gammas</span><span class="p">,</span> <span class="n">denom_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span>
                                <span class="n">denom_others</span><span class="p">),</span>
                               <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span>
                                <span class="n">numer_others</span><span class="p">)]:</span>

            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ng</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dg</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">ng</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">dg</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">do</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">ng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">do</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">))</span>

        <span class="c"># Try to reduce the number of gamma factors by applying the</span>
        <span class="c"># multiplication theorem (used when n gammas with args differing</span>
        <span class="c"># by 1/n mod 1 are encountered).</span>
        <span class="c">#</span>
        <span class="c"># run of 2 with args differing by 1/2</span>
        <span class="c">#</span>
        <span class="c"># &gt;&gt;&gt; combsimp(gamma(x)*gamma(x+S.Half))</span>
        <span class="c"># 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)</span>
        <span class="c">#</span>
        <span class="c"># run of 3 args differing by 1/3 (mod 1)</span>
        <span class="c">#</span>
        <span class="c"># &gt;&gt;&gt; combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))</span>
        <span class="c"># 6*3**(-3*x - 1/2)*pi*gamma(3*x)</span>
        <span class="c"># &gt;&gt;&gt; combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))</span>
        <span class="c"># 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)</span>
        <span class="c">#</span>
        <span class="k">def</span> <span class="nf">_run</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
            <span class="c"># find runs in coeffs such that the difference in terms (mod 1)</span>
            <span class="c"># of t1, t2, ..., tn is 1/n</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">uniq</span>
            <span class="n">u</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
                <span class="n">dj</span> <span class="o">=</span> <span class="p">([((</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))])</span>
                <span class="k">for</span> <span class="n">one</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dj</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">one</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span>
                        <span class="n">got</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">get</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dj</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">d</span>
                            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">get</span><span class="p">:</span>
                                <span class="n">get</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                                <span class="n">got</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">get</span><span class="p">:</span>
                                    <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">got</span><span class="p">):</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">coeffs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                            <span class="n">got</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                        <span class="k">return</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">got</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">got</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">def</span> <span class="nf">_mult_thm</span><span class="p">(</span><span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
            <span class="c"># pull off and analyze the leading coefficient from each gamma arg</span>
            <span class="c"># looking for runs in those Rationals</span>

            <span class="c"># expr -&gt; coeff + resid -&gt; rats[resid] = coeff</span>
            <span class="n">rats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gammas</span><span class="p">:</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">resid</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
                <span class="n">rats</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="c"># look for runs in Rationals for each resid</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]))</span>
                <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">run</span> <span class="o">=</span> <span class="n">_run</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">run</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="c"># process the sequence that was found:</span>
                    <span class="c"># 1) convert all the gamma functions to have the right</span>
                    <span class="c">#    argument (could be off by an integer)</span>
                    <span class="c"># 2) append the factors corresponding to the theorem</span>
                    <span class="c"># 3) append the new gamma function</span>

                    <span class="n">n</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">run</span>

                    <span class="c"># (1)</span>
                    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">con</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">+</span> <span class="n">u</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">ui</span><span class="p">)):</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

                    <span class="n">con</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">resid</span> <span class="o">+</span> <span class="n">ui</span><span class="p">)</span>  <span class="c"># for (2) and (3)</span>

                    <span class="c"># (2)</span>
                    <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span>
                                 <span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">con</span><span class="p">))</span>
                    <span class="c"># (3)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>

                <span class="c"># restore resid to coeffs</span>
                <span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">resid</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">]</span> <span class="o">+</span> <span class="n">new</span>

            <span class="c"># rebuild the gamma arguments</span>
            <span class="n">g</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">+=</span> <span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span>
            <span class="c"># /!\ updating IN PLACE</span>
            <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">g</span>

        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                                <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
            <span class="n">_mult_thm</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>

        <span class="c"># =========== level &gt;= 2 work: factor absorbtion =========</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># Try to absorb factors into the gammas: x*gamma(x) -&gt; gamma(x + 1)</span>
            <span class="c"># and gamma(x)/(x - 1) -&gt; gamma(x - 1)</span>
            <span class="c"># This code (in particular repeated calls to find_fuzzy) can be very</span>
            <span class="c"># slow.</span>
            <span class="k">def</span> <span class="nf">find_fuzzy</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">S1</span><span class="p">,</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">compute_ST</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">S2</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">T1</span> <span class="o">!=</span> <span class="n">T2</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">S1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span> <span class="ow">and</span>
                                    <span class="p">(</span><span class="n">S1</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S2</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">())):</span>
                        <span class="k">continue</span>
                    <span class="c"># XXX we want some simplification (e.g. cancel or</span>
                    <span class="c"># simplify) but no matter what it&#39;s slow.</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cancel</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                    <span class="c"># TODO is there a better heuristic?</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">y</span>

            <span class="c"># We thus try to avoid expensive calls by building the following</span>
            <span class="c"># &quot;invariants&quot;: For every factor or gamma function argument</span>
            <span class="c">#   - the set of free symbols S</span>
            <span class="c">#   - the set of functional components T</span>
            <span class="c"># We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset</span>
            <span class="c"># or S1 == S2 == emptyset)</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="nf">compute_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Pow</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">inv</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">exp</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Pow</span><span class="p">))))</span>

            <span class="k">def</span> <span class="nf">update_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">inv</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">numer_gammas</span> <span class="o">+</span> <span class="n">denom_gammas</span> <span class="o">+</span> <span class="n">numer_others</span> <span class="o">+</span> <span class="n">denom_others</span><span class="p">:</span>
                <span class="n">update_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span>
                <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">gammas</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">g</span><span class="p">:</span>
                                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
                                <span class="n">update_ST</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
                            <span class="n">g</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">denom</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
                                <span class="n">update_ST</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
                            <span class="n">g</span> <span class="o">-=</span> <span class="mi">1</span>
                            <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="c"># /!\ updating IN PLACE</span>
                <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new</span>

        <span class="c"># =========== rebuild expr ==================================</span>

        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">gamma</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">numer_gammas</span><span class="p">])</span> \
            <span class="o">/</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">gamma</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">denom_gammas</span><span class="p">])</span> \
            <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">numer_others</span><span class="p">)</span> <span class="o">/</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">denom_others</span><span class="p">)</span>

    <span class="c"># (for some reason we cannot use Basic.replace in this case)</span>
    <span class="n">was</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">rule_gamma</span><span class="p">(</span><span class="n">was</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">was</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span>

</div>
<span class="k">def</span> <span class="nf">signsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make all Add sub-expressions canonical wrt sign.</span>

<span class="sd">    If an Add subexpression, ``a``, can have a sign extracted,</span>
<span class="sd">    as determined by could_extract_minus_sign, it is replaced</span>
<span class="sd">    with Mul(-1, a, evaluate=False). This allows signs to be</span>
<span class="sd">    extracted from powers and products.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import signsimp, exp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; n = -1 + 1/x</span>
<span class="sd">    &gt;&gt;&gt; n/x/(-n)**2 - 1/n/x</span>
<span class="sd">    (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; x*n + x*-n</span>
<span class="sd">    x*(-1 + 1/x) + x*(1 - 1/x)</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; n**3</span>
<span class="sd">    (-1 + 1/x)**3</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    -(1 - 1/x)**3</span>

<span class="sd">    By default, signsimp doesn&#39;t leave behind any hollow simplification:</span>
<span class="sd">    if making an Add canonical wrt sign didn&#39;t change the expression, the</span>
<span class="sd">    original Add is restored. If this is not desired then the keyword</span>
<span class="sd">    ``evaluate`` can be set to False:</span>

<span class="sd">    &gt;&gt;&gt; e = exp(y - x)</span>
<span class="sd">    &gt;&gt;&gt; signsimp(e) == e</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; signsimp(e, evaluate=False)</span>
<span class="sd">    exp(-(x - y))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">sub_post</span><span class="p">(</span><span class="n">sub_pre</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>
    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">signsimp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span> <span class="k">if</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">e</span>


<div class="viewcode-block" id="simplify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.simplify">[docs]</a><span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">count_ops</span><span class="p">,</span> <span class="n">fu</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies the given expression.</span>

<span class="sd">    Simplification is not a well defined term and the exact strategies</span>
<span class="sd">    this function tries can change in the future versions of SymPy. If</span>
<span class="sd">    your algorithm relies on &quot;simplification&quot; (whatever it is), try to</span>
<span class="sd">    determine what you need exactly  -  is it powsimp()?, radsimp()?,</span>
<span class="sd">    together()?, logcombine()?, or something else? And use this particular</span>
<span class="sd">    function directly, because those are well defined and thus your algorithm</span>
<span class="sd">    will be robust.</span>

<span class="sd">    Nonetheless, especially for interactive use, or when you don&#39;t know</span>
<span class="sd">    anything about the structure of the expression, simplify() tries to apply</span>
<span class="sd">    intelligent heuristics to make the input expression &quot;simpler&quot;.  For</span>
<span class="sd">    example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import simplify, cos, sin</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)</span>
<span class="sd">    &gt;&gt;&gt; simplify(a)</span>
<span class="sd">    x + 1</span>

<span class="sd">    Note that we could have obtained the same result by using specific</span>
<span class="sd">    simplification functions:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import trigsimp, cancel</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(a)</span>
<span class="sd">    (x**2 + x)/x</span>
<span class="sd">    &gt;&gt;&gt; cancel(_)</span>
<span class="sd">    x + 1</span>

<span class="sd">    In some cases, applying :func:`simplify` may actually result in some more</span>
<span class="sd">    complicated expression. The default ``ratio=1.7`` prevents more extreme</span>
<span class="sd">    cases: if (result length)/(input length) &gt; ratio, then input is returned</span>
<span class="sd">    unmodified.  The ``measure`` parameter lets you specify the function used</span>
<span class="sd">    to determine how complex an expression is.  The function should take a</span>
<span class="sd">    single argument as an expression and return a number such that if</span>
<span class="sd">    expression ``a`` is more complex than expression ``b``, then</span>
<span class="sd">    ``measure(a) &gt; measure(b)``.  The default measure function is</span>
<span class="sd">    :func:`count_ops`, which returns the total number of operations in the</span>
<span class="sd">    expression.</span>

<span class="sd">    For example, if ``ratio=1``, ``simplify`` output can&#39;t be longer</span>
<span class="sd">    than input.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, simplify, count_ops, oo</span>
<span class="sd">        &gt;&gt;&gt; root = 1/(sqrt(2)+3)</span>

<span class="sd">    Since ``simplify(root)`` would result in a slightly longer expression,</span>
<span class="sd">    root is returned unchanged instead::</span>

<span class="sd">       &gt;&gt;&gt; simplify(root, ratio=1) == root</span>
<span class="sd">       True</span>

<span class="sd">    If ``ratio=oo``, simplify will be applied anyway::</span>

<span class="sd">        &gt;&gt;&gt; count_ops(simplify(root, ratio=oo)) &gt; count_ops(root)</span>
<span class="sd">        True</span>

<span class="sd">    Note that the shortest expression is not necessary the simplest, so</span>
<span class="sd">    setting ``ratio`` to 1 may not be a good idea.</span>
<span class="sd">    Heuristically, the default value ``ratio=1.7`` seems like a reasonable</span>
<span class="sd">    choice.</span>

<span class="sd">    You can easily define your own measure function based on what you feel</span>
<span class="sd">    should represent the &quot;size&quot; or &quot;complexity&quot; of the input expression.  Note</span>
<span class="sd">    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be</span>
<span class="sd">    good metrics, but have other problems (in this case, the measure function</span>
<span class="sd">    may slow down simplify too much for very large expressions).  If you don&#39;t</span>
<span class="sd">    know what a good metric would be, the default, ``count_ops``, is a good</span>
<span class="sd">    one.</span>

<span class="sd">    For example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, log</span>
<span class="sd">    &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; g = log(a) + log(b) + log(a)*log(1/b)</span>
<span class="sd">    &gt;&gt;&gt; h = simplify(g)</span>
<span class="sd">    &gt;&gt;&gt; h</span>
<span class="sd">    log(a*b**(-log(a) + 1))</span>
<span class="sd">    &gt;&gt;&gt; count_ops(g)</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; count_ops(h)</span>
<span class="sd">    5</span>

<span class="sd">    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.</span>
<span class="sd">    However, we may not like how ``simplify`` (in this case, using</span>
<span class="sd">    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way</span>
<span class="sd">    to reduce this would be to give more weight to powers as operations in</span>
<span class="sd">    ``count_ops``.  We can do this by using the ``visual=True`` option:</span>

<span class="sd">    &gt;&gt;&gt; print(count_ops(g, visual=True))</span>
<span class="sd">    2*ADD + DIV + 4*LOG + MUL</span>
<span class="sd">    &gt;&gt;&gt; print(count_ops(h, visual=True))</span>
<span class="sd">    2*LOG + MUL + POW + SUB</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, S</span>
<span class="sd">    &gt;&gt;&gt; def my_measure(expr):</span>
<span class="sd">    ...     POW = Symbol(&#39;POW&#39;)</span>
<span class="sd">    ...     # Discourage powers by giving POW a weight of 10</span>
<span class="sd">    ...     count = count_ops(expr, visual=True).subs(POW, 10)</span>
<span class="sd">    ...     # Every other operation gets a weight of 1 (the default)</span>
<span class="sd">    ...     count = count.replace(Symbol, type(S.One))</span>
<span class="sd">    ...     return count</span>
<span class="sd">    &gt;&gt;&gt; my_measure(g)</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; my_measure(h)</span>
<span class="sd">    14</span>
<span class="sd">    &gt;&gt;&gt; 15./8 &gt; 1.7 # 1.7 is the default ratio</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; simplify(g, measure=my_measure)</span>
<span class="sd">    -log(a)*log(b) + log(a) + log(b)</span>

<span class="sd">    Note that because ``simplify()`` internally tries many different</span>
<span class="sd">    simplification strategies and then compares them using the measure</span>
<span class="sd">    function, we get a completely different result that is still different</span>
<span class="sd">    from the input expression by doing this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.hyperexpand</span> <span class="kn">import</span> <span class="n">hyperexpand</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.special.bessel</span> <span class="kn">import</span> <span class="n">BesselBase</span>

    <span class="n">original_expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">_eval_simplify</span><span class="p">(</span><span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">measure</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="kn">from</span> <span class="nn">sympy.simplify.hyperexpand</span> <span class="kn">import</span> <span class="n">hyperexpand</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.special.bessel</span> <span class="kn">import</span> <span class="n">BesselBase</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">Product</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>  <span class="c"># XXX: temporary hack</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># TODO: Apply different strategies, considering expression pattern:</span>
    <span class="c"># is it a purely rational function? Is there any trigonometric function?...</span>
    <span class="c"># See also https://github.com/sympy/sympy/pull/185.</span>

    <span class="k">def</span> <span class="nf">shorter</span><span class="p">(</span><span class="o">*</span><span class="n">choices</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return the choice that has the fewest ops. In case of a tie,</span>
<span class="sd">        the expression listed first is selected.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_variety</span><span class="p">(</span><span class="n">choices</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">measure</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">bottom_up</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">normal</span><span class="p">())</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">())</span>
    <span class="n">_e</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">expr1</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">_e</span><span class="p">,</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">_e</span><span class="p">)</span><span class="o">.</span><span class="n">cancel</span><span class="p">())</span>  <span class="c"># issue 3730</span>
    <span class="n">expr2</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">together</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">together</span><span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ratio</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>  <span class="c"># XXX: temporary hack</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c"># hyperexpand automatically only works on hypergeometric terms</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">hyperexpand</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">piecewise_fold</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">BesselBase</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">besselsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fu</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span>
            <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expand_log</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">CombinatorialFunction</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">combsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Sum</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">sum_simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Product</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">product_simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">short</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
    <span class="n">short</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">short</span><span class="p">,</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">short</span><span class="p">),</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">(</span><span class="n">short</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">short</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">ExpBase</span><span class="p">):</span>
        <span class="n">short</span> <span class="o">=</span> <span class="n">exptrigsimp</span><span class="p">(</span><span class="n">short</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c"># get rid of hollow 2-arg Mul factorization</span>
    <span class="kn">from</span> <span class="nn">sympy.core.rules</span> <span class="kn">import</span> <span class="n">Transform</span>
    <span class="n">hollow_mul</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
        <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span>
        <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span>
        <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">short</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">hollow_mul</span><span class="p">)</span>

    <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">denom</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">radsimp</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">max_terms</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">numer</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">/</span><span class="n">d</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">():</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">measure</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ratio</span><span class="o">*</span><span class="n">measure</span><span class="p">(</span><span class="n">original_expr</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">original_expr</span>

    <span class="k">return</span> <span class="n">expr</span>

</div>
<span class="k">def</span> <span class="nf">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace all reals in expr with rationals.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import nsimplify</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">    &gt;&gt;&gt; nsimplify(.76 + .1*x**.5, rational=True)</span>
<span class="sd">    sqrt(x)/10 + 19/25</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">reduce_num</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">reduce_num</span> <span class="o">=</span> <span class="n">ceiling</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">tolerance</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">float</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="k">if</span> <span class="n">reduce_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="n">reduce_num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">tolerance</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="nb">float</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">tolerance</span><span class="o">*</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="o">/</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="c"># e.g. log(3).n() -&gt; log(3) instead of a Rational</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">float</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">Rational</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="o">/</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="n">d</span>
                <span class="k">elif</span> <span class="nb">float</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="o">/</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="n">d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">reps</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">simultaneous</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<div class="viewcode-block" id="nsimplify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.nsimplify">[docs]</a><span class="k">def</span> <span class="nf">nsimplify</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="p">[],</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a simple representation for a number or, if there are free symbols or</span>
<span class="sd">    if rational=True, then replace Floats with their Rational equivalents. If</span>
<span class="sd">    no change is made and rational is not False then Floats will at least be</span>
<span class="sd">    converted to Rationals.</span>

<span class="sd">    For numerical expressions, a simple formula that numerically matches the</span>
<span class="sd">    given numerical expression is sought (and the input should be possible</span>
<span class="sd">    to evalf to a precision of at least 30 digits).</span>

<span class="sd">    Optionally, a list of (rationally independent) constants to</span>
<span class="sd">    include in the formula may be given.</span>

<span class="sd">    A lower tolerance may be set to find less exact matches. If no tolerance</span>
<span class="sd">    is given then the least precise value will set the tolerance (e.g. Floats</span>
<span class="sd">    default to 15 digits of precision, so would be tolerance=10**-15).</span>

<span class="sd">    With full=True, a more extensive search is performed</span>
<span class="sd">    (this is useful to find simpler numbers when the tolerance</span>
<span class="sd">    is set low).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi</span>
<span class="sd">    &gt;&gt;&gt; nsimplify(4/(1+sqrt(5)), [GoldenRatio])</span>
<span class="sd">    -2 + 2*GoldenRatio</span>
<span class="sd">    &gt;&gt;&gt; nsimplify((1/(exp(3*pi*I/5)+1)))</span>
<span class="sd">    1/2 - I*sqrt(sqrt(5)/10 + 1/4)</span>
<span class="sd">    &gt;&gt;&gt; nsimplify(I**I, [pi])</span>
<span class="sd">    exp(-pi/2)</span>
<span class="sd">    &gt;&gt;&gt; nsimplify(pi, tolerance=0.01)</span>
<span class="sd">    22/7</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    sympy.core.function.nfloat</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rational</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="c"># SymPy&#39;s default tolerance for Rationals is 15; other numbers may have</span>
    <span class="c"># lower tolerances set, so use them to pick the largest tolerance if None</span>
    <span class="c"># was given</span>
    <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**-</span><span class="nb">min</span><span class="p">([</span><span class="mi">15</span><span class="p">]</span> <span class="o">+</span>
             <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">libmp</span><span class="o">.</span><span class="n">libmpf</span><span class="o">.</span><span class="n">prec_to_dps</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">_prec</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Float</span><span class="p">)])</span>

    <span class="n">prec</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">bprec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">prec</span><span class="o">*</span><span class="mf">3.33</span><span class="p">)</span>

    <span class="n">constants_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">constant</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">:</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">constant</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;constants must be real-valued&quot;</span><span class="p">)</span>
        <span class="n">constants_dict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">constant</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">bprec</span><span class="p">)</span>

    <span class="n">exprval</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">exprval</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>

    <span class="c"># safety check to make sure that this evaluated to a number</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">im</span><span class="o">.</span><span class="n">is_Number</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">nsimplify_real</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span>
        <span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">bprec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># We&#39;ll be happy with low precision if a simple fraction</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tolerance</span> <span class="ow">or</span> <span class="n">full</span><span class="p">):</span>
                <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
                <span class="n">rat</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">findpoly</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">rat</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">rat</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">prec</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">constants_dict</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">newexpr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">newexpr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_bounded</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xv</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">ninf</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># even though there are returns above, this is executed</span>
            <span class="c"># before leaving</span>
            <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">orig</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="p">:</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">nsimplify_real</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">nsimplify_real</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rational</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">rv</span> <span class="o">=</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
    <span class="c"># if there was a change or rational is explicitly not wanted</span>
    <span class="c"># return the value, else return the Rational representation</span>
    <span class="k">if</span> <span class="n">rv</span> <span class="o">!=</span> <span class="n">expr</span> <span class="ow">or</span> <span class="n">rational</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rv</span>
    <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="logcombine"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.logcombine">[docs]</a><span class="k">def</span> <span class="nf">logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes logarithms and combines them using the following rules:</span>

<span class="sd">    - log(x) + log(y) == log(x*y) if both are not negative</span>
<span class="sd">    - a*log(x) == log(x**a) if x is positive and a is real</span>

<span class="sd">    If ``force`` is True then the assumptions above will be assumed to hold if</span>
<span class="sd">    there is no assumption already in place on a quantity. For example, if</span>
<span class="sd">    ``a`` is imaginary or the argument negative, force will not perform a</span>
<span class="sd">    combination but if ``a`` is a symbol with no assumptions the change will</span>
<span class="sd">    take place.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, symbols, log, logcombine, I</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, x, y, z</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z))</span>
<span class="sd">    a*log(x) + log(y) - log(z)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z), force=True)</span>
<span class="sd">    log(x**a*y/z)</span>
<span class="sd">    &gt;&gt;&gt; x,y,z = symbols(&#39;x,y,z&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; a = Symbol(&#39;a&#39;, real=True)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z))</span>
<span class="sd">    log(x**a*y/z)</span>

<span class="sd">    The transformation is limited to factors and/or terms that</span>
<span class="sd">    contain logs, so the result depends on the initial state of</span>
<span class="sd">    expansion:</span>

<span class="sd">    &gt;&gt;&gt; eq = (2 + 3*I)*log(x)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(eq, force=True) == eq</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; logcombine(eq.expand(), force=True)</span>
<span class="sd">    log(x**2) + I*log(x**3)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    posify: replace all symbols with symbols having positive assumptions</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">rv</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rv</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">rv</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="k">def</span> <span class="nf">gooda</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="c"># bool to tell whether the leading ``a`` in ``a*log(x)``</span>
            <span class="c"># could appear as log(x**a)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span> <span class="ow">and</span>  <span class="c"># -1 *could* go, but we disallow</span>
                <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">force</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">goodlog</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="c"># bool to tell whether log ``l``&#39;s argument can combine with others</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">or</span> <span class="n">force</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>

        <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">log1</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">rv</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span> <span class="ow">and</span> <span class="n">goodlog</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="n">log1</span><span class="p">[()]</span><span class="o">.</span><span class="n">append</span><span class="p">(([],</span> <span class="n">a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ot</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">co</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">lo</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ai</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">ai</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">)</span>
                        <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">ai</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">ai</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span> <span class="ow">and</span> <span class="n">goodlog</span><span class="p">(</span><span class="n">ai</span><span class="p">):</span>
                        <span class="n">lo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">gooda</span><span class="p">(</span><span class="n">ai</span><span class="p">):</span>
                        <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ot</span><span class="p">,</span> <span class="n">co</span><span class="p">,</span> <span class="n">lo</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">lo</span><span class="p">:</span>
                    <span class="n">log1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ot</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">co</span><span class="p">,</span> <span class="n">lo</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="c"># if there is only one log at each coefficient and none have</span>
        <span class="c"># an exponent to place inside the log then there is nothing to do</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">logs</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">log1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">log1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="c"># collapse multi-logs as far as possible in a canonical way</span>
        <span class="c"># TODO: see if x*log(a)+x*log(a)*log(b) -&gt; x*log(a)*(1+log(b))?</span>
        <span class="c"># -- in this case, it&#39;s unambiguous, but if it were were a log(c) in</span>
        <span class="c"># each term then it&#39;s arbitrary whether they are grouped by log(a) or</span>
        <span class="c"># by log(c). So for now, just leave this alone; it&#39;s probably better to</span>
        <span class="c"># let the user decide</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">logs</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">))</span>
            <span class="k">while</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">li</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">li</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">),</span> <span class="n">e</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>  <span class="c"># it should be, but check to be sure</span>
                <span class="n">log1</span><span class="p">[(</span><span class="n">c</span><span class="p">,)]</span><span class="o">.</span><span class="n">append</span><span class="p">(([],</span> <span class="n">l</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">l</span><span class="p">)</span>

        <span class="c"># logs that have the same coefficient can multiply</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">log1</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">log1</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">logcombine</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                <span class="n">l</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)]),</span>
                <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">))</span>

        <span class="c"># logs that have oppositely signed coefficients can divide</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">log1</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">log1</span><span class="p">:</span>  <span class="c"># already popped as -k</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">k</span> <span class="ow">in</span> <span class="n">log1</span><span class="p">:</span>
                <span class="c"># figure out which has the minus sign; the one with</span>
                <span class="c"># more op counts should be the one</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span>
                <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">count_ops</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">den</span><span class="o">.</span><span class="n">count_ops</span><span class="p">():</span>
                    <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">den</span><span class="p">,</span> <span class="n">num</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">den</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bottom_up</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">bottom_up</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nonbasic</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply ``F`` to all expressions in an expression tree from the</span>
<span class="sd">    bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;</span>
<span class="sd">    if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rv</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">bottom_up</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">nonbasic</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">args</span> <span class="o">!=</span> <span class="n">rv</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nonbasic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">return</span> <span class="n">rv</span>


<div class="viewcode-block" id="besselsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.besselsimp">[docs]</a><span class="k">def</span> <span class="nf">besselsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplify bessel-type functions.</span>

<span class="sd">    This routine tries to simplify bessel-type functions. Currently it only</span>
<span class="sd">    works on the Bessel J and I functions, however. It works by looking at all</span>
<span class="sd">    such functions in turn, and eliminating factors of &quot;I&quot; and &quot;-1&quot; (actually</span>
<span class="sd">    their polar equivalents) in front of the argument. Then, functions of</span>
<span class="sd">    half-integer order are rewritten using trigonometric functions and</span>
<span class="sd">    functions of integer order (&gt; 1) are rewritten using functions</span>
<span class="sd">    of low order.  Finally, if the expression was changed, compute</span>
<span class="sd">    factorization of the result with factor().</span>

<span class="sd">    &gt;&gt;&gt; from sympy import besselj, besseli, besselsimp, polar_lift, I, S</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import z, nu</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besselj(nu, z*polar_lift(-1)))</span>
<span class="sd">    exp(I*pi*nu)*besselj(nu, z)</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besseli(nu, z*polar_lift(-I)))</span>
<span class="sd">    exp(-I*pi*nu/2)*besselj(nu, z)</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besseli(S(-1)/2, z))</span>
<span class="sd">    sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))</span>
<span class="sd">    3*z*besseli(0, z)/2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">besselj</span><span class="p">,</span> <span class="n">bessely</span><span class="p">,</span> <span class="n">besseli</span><span class="p">,</span> <span class="n">besselk</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">Dummy</span>
    <span class="c"># TODO</span>
    <span class="c"># - better algorithm?</span>
    <span class="c"># - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...</span>
    <span class="c"># - use contiguity relations?</span>

    <span class="k">def</span> <span class="nf">replacer</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">factors</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">to</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">repl</span>

    <span class="k">def</span> <span class="nf">torewrite</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="n">to</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">tofunc</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tofunc</span>

    <span class="k">def</span> <span class="nf">tominus</span><span class="p">(</span><span class="n">fro</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">tofunc</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">*</span><span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tofunc</span>

    <span class="n">orig_expr</span> <span class="o">=</span> <span class="n">expr</span>

    <span class="n">ifactors</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besselj</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span>
        <span class="n">torewrite</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">besseli</span><span class="p">),</span> <span class="n">ifactors</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besseli</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span>
        <span class="n">torewrite</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">besselj</span><span class="p">),</span> <span class="n">ifactors</span><span class="p">))</span>

    <span class="n">minusfactors</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besselj</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">tominus</span><span class="p">(</span><span class="n">besselj</span><span class="p">),</span> <span class="n">minusfactors</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besseli</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">tominus</span><span class="p">(</span><span class="n">besseli</span><span class="p">),</span> <span class="n">minusfactors</span><span class="p">))</span>

    <span class="n">z0</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expander</span><span class="p">(</span><span class="n">fro</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nu</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exptrigsimp</span><span class="p">(</span><span class="n">trigsimp</span><span class="p">(</span><span class="n">unpolarify</span><span class="p">(</span>
                        <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z0</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">besselj</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">jn</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                            <span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">z</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">repl</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besselj</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">bessely</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">bessely</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besseli</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besselk</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besselk</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">orig_expr</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">expr</span>
</div>
<span class="k">def</span> <span class="nf">exptrigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies exponential / trigonometric / hyperbolic functions.</span>
<span class="sd">    When ``simplify`` is True (default) the expression obtained after the</span>
<span class="sd">    simplification step will be then be passed through simplify to</span>
<span class="sd">    precondition it so the final transformations will be applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import exptrigsimp, exp, cosh, sinh</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import z</span>

<span class="sd">    &gt;&gt;&gt; exptrigsimp(exp(z) + exp(-z))</span>
<span class="sd">    2*cosh(z)</span>
<span class="sd">    &gt;&gt;&gt; exptrigsimp(cosh(z) - sinh(z))</span>
<span class="sd">    exp(-z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="n">hyper_as_trig</span><span class="p">,</span> <span class="n">TR2i</span>

    <span class="k">def</span> <span class="nf">exp_trig</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="c"># select the better of e, and e rewritten in terms of exp or trig</span>
        <span class="c"># functions</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">_trigs</span><span class="p">):</span>
            <span class="n">choices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
        <span class="n">choices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">cos</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="o">*</span><span class="n">choices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">count_ops</span><span class="p">)</span>
    <span class="n">newexpr</span> <span class="o">=</span> <span class="n">bottom_up</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">exp_trig</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

    <span class="c"># conversion from exp to hyperbolic</span>
    <span class="n">ex</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">)</span>
    <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">ei</span> <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">ex</span> <span class="k">if</span> <span class="mi">1</span><span class="o">/</span><span class="n">ei</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ex</span><span class="p">]</span>
    <span class="c">## sinh and cosh</span>
    <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">ex</span><span class="p">:</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">ei</span><span class="o">**-</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">e2</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">subs</span><span class="p">((</span><span class="n">e2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ei</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">subs</span><span class="p">((</span><span class="n">e2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ei</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="c">## exp ratios to tan and tanh</span>
    <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">ex</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ei</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">et</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>
        <span class="n">etinv</span> <span class="o">=</span> <span class="n">d</span><span class="o">/</span><span class="n">n</span>  <span class="c"># not 1/et or else recursion errors arise</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ei</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">ei</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span> <span class="k">else</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">etinv</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">t</span><span class="p">)</span>
                <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">etinv</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">t</span><span class="p">)</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="c"># sin/cos and sinh/cosh ratios to tan and tanh, respectively</span>
    <span class="k">if</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">):</span>
        <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">hyper_as_trig</span><span class="p">(</span><span class="n">newexpr</span><span class="p">)</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">TR2i</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">newexpr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">):</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="n">TR2i</span><span class="p">(</span><span class="n">newexpr</span><span class="p">)</span>

    <span class="c"># can we ever generate an I where there was none previously?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">newexpr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">newexpr</span>
    <span class="k">return</span> <span class="n">expr</span>


<span class="k">def</span> <span class="nf">_is_Expr</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;_eapply helper to tell whether ``e`` and all its args</span>
<span class="sd">    are Exprs.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_Expr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_eapply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply ``func`` to ``e`` if all args are Exprs else only</span>
<span class="sd">    apply it to those args that *are* Exprs.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span>
    <span class="k">if</span> <span class="n">_is_Expr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
        <span class="n">_eapply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ei</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">cond</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">cond</span><span class="p">(</span><span class="n">ei</span><span class="p">))</span> <span class="k">else</span> <span class="n">ei</span>
        <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">futrig</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return simplified ``e`` using Fu-like transformations.</span>
<span class="sd">    This is not the &quot;Fu&quot; algorithm. This is called by default</span>
<span class="sd">    from ``trigsimp``. By default, hyperbolics subexpressions</span>
<span class="sd">    will be simplified, but this can be disabled by setting</span>
<span class="sd">    ``hyper=False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import trigsimp, tan, sinh, tanh</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import futrig</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(1/tan(x)**2)</span>
<span class="sd">    tan(x)**(-2)</span>

<span class="sd">    &gt;&gt;&gt; futrig(sinh(x)/tanh(x))</span>
<span class="sd">    cosh(x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="n">hyper_as_trig</span>

    <span class="n">e</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="n">old</span> <span class="o">=</span> <span class="n">e</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">bottom_up</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_futrig</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;hyper&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">):</span>
        <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">hyper_as_trig</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">_futrig</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">old</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
        <span class="c"># redistribute leading coeff on 2-arg Add</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">e</span>


<span class="k">def</span> <span class="nf">_futrig</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper for futrig.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.strategies.tree</span> <span class="kn">import</span> <span class="n">greedy</span>
    <span class="kn">from</span> <span class="nn">sympy.strategies.core</span> <span class="kn">import</span> <span class="n">identity</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">TR1</span><span class="p">,</span> <span class="n">TR2</span><span class="p">,</span> <span class="n">TR3</span><span class="p">,</span> <span class="n">TR2i</span><span class="p">,</span> <span class="n">TR14</span><span class="p">,</span> <span class="n">TR5</span><span class="p">,</span> <span class="n">TR10</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">TR10i</span><span class="p">,</span>
        <span class="n">TR8</span><span class="p">,</span> <span class="n">TR6</span><span class="p">,</span> <span class="n">TR15</span><span class="p">,</span> <span class="n">TR16</span><span class="p">,</span> <span class="n">TR111</span><span class="p">,</span> <span class="n">TR5</span><span class="p">,</span> <span class="n">TRmorrie</span><span class="p">,</span> <span class="n">TR11</span><span class="p">,</span> <span class="n">TR14</span><span class="p">,</span> <span class="n">TR22</span><span class="p">,</span>
        <span class="n">TR12</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">_nodes</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="n">Lops</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">count_ops</span><span class="p">(),</span> <span class="n">_nodes</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Add</span><span class="p">)</span>
    <span class="n">trigs</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">)</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">identity</span><span class="p">,</span>
        <span class="p">(</span>
        <span class="n">TR3</span><span class="p">,</span>  <span class="c"># canonical angles</span>
        <span class="n">TR1</span><span class="p">,</span>  <span class="c"># sec-csc -&gt; cos-sin</span>
        <span class="n">TR12</span><span class="p">,</span>  <span class="c"># expand tan of sum</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trigs</span><span class="p">),</span>
        <span class="n">TR2</span><span class="p">,</span>  <span class="c"># tan-cot -&gt; sin-cos</span>
        <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span><span class="n">_mexpand</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trigs</span><span class="p">)],</span>
        <span class="n">TR2i</span><span class="p">,</span>  <span class="c"># sin-cos ratio -&gt; tan</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">factor</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">normal</span><span class="p">()),</span> <span class="n">x</span><span class="p">,</span> <span class="n">trigs</span><span class="p">),</span>
        <span class="n">TR14</span><span class="p">,</span>  <span class="c"># factored identities</span>
        <span class="n">TR5</span><span class="p">,</span>  <span class="c"># sin-pow -&gt; cos_pow</span>
        <span class="n">TR10</span><span class="p">,</span>  <span class="c"># sin-cos of sums -&gt; sin-cos prod</span>
        <span class="n">TR11</span><span class="p">,</span> <span class="n">TR6</span><span class="p">,</span> <span class="c"># reduce double angles and rewrite cos pows</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trigs</span><span class="p">),</span>
        <span class="n">TR14</span><span class="p">,</span>  <span class="c"># factored powers of identities</span>
        <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span><span class="n">_mexpand</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trigs</span><span class="p">)],</span>
        <span class="n">TRmorrie</span><span class="p">,</span>
        <span class="n">TR10i</span><span class="p">,</span>  <span class="c"># sin-cos products &gt; sin-cos of sums</span>
        <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="n">TR8</span><span class="p">],</span>  <span class="c"># sin-cos products -&gt; sin-cos of sums</span>
        <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">TR2i</span><span class="p">(</span><span class="n">TR2</span><span class="p">(</span><span class="n">x</span><span class="p">))],</span>  <span class="c"># tan -&gt; sin-cos -&gt; tan</span>
        <span class="p">[</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">,</span> <span class="n">TR5</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trigs</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span>
                <span class="n">expand_mul</span><span class="p">,</span> <span class="n">TR15</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trigs</span><span class="p">)],</span> <span class="c"># pos/neg powers of sin</span>
        <span class="p">[</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="n">_eapply</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">,</span> <span class="n">TR6</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trigs</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="n">_eapply</span><span class="p">(</span>
                <span class="n">expand_mul</span><span class="p">,</span> <span class="n">TR16</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trigs</span><span class="p">)],</span> <span class="c"># pos/neg powers of cos</span>
        <span class="n">TR111</span><span class="p">,</span>  <span class="c"># tan, sin, cos to neg power -&gt; cot, csc, sec</span>
        <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="n">TR2i</span><span class="p">],</span>  <span class="c"># sin-cos ratio to tan</span>
        <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span>
            <span class="n">expand_mul</span><span class="p">,</span> <span class="n">TR22</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trigs</span><span class="p">)],</span>  <span class="c"># tan-cot to sec-csc</span>
        <span class="n">TR1</span><span class="p">,</span> <span class="n">TR2</span><span class="p">,</span> <span class="n">TR2i</span><span class="p">,</span>
        <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_eapply</span><span class="p">(</span>
            <span class="n">factor_terms</span><span class="p">,</span> <span class="n">TR12</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trigs</span><span class="p">)],</span>  <span class="c"># expand tan of sum</span>
        <span class="p">)]</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">greedy</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">objective</span><span class="o">=</span><span class="n">Lops</span><span class="p">)(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">e</span>


<span class="k">def</span> <span class="nf">sum_simplify</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function for Sum simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.summations</span> <span class="kn">import</span> <span class="n">Sum</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">s_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># Sum Terms</span>
    <span class="n">o_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># Other Terms</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">other</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n_sum_terms</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Sum</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">n_sum_terms</span> <span class="o">=</span> <span class="n">n_sum_terms</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_number</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">constant</span> <span class="o">=</span> <span class="n">constant</span> <span class="o">*</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span> <span class="o">*</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_sum_terms</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Insert the constant inside the Sum</span>
                <span class="n">s_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">constant</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">limits</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">other</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_sum_terms</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span> <span class="o">*</span> <span class="n">Sum</span><span class="p">(</span><span class="n">constant</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">limits</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Sum</span><span class="p">):</span>
            <span class="n">s_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_term1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_t</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s_term2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_add</span><span class="p">(</span><span class="n">s_term1</span><span class="p">,</span> <span class="n">s_term2</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="n">Sum</span><span class="p">):</span>
                            <span class="n">s_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_add</span><span class="p">(</span><span class="n">s_term1</span><span class="p">,</span> <span class="n">s_term2</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                            <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">o_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">s_term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">sum_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for Sum simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.summations</span> <span class="kn">import</span> <span class="n">Sum</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x2</span> <span class="o">==</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">y2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">product_simplify</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function for Product simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.products</span> <span class="kn">import</span> <span class="n">Product</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">p_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># Product Terms</span>
    <span class="n">o_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># Other Terms</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Product</span><span class="p">):</span>
            <span class="n">p_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_term1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_t</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">p_term2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">product_mul</span><span class="p">(</span><span class="n">p_term1</span><span class="p">,</span> <span class="n">p_term2</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="n">Product</span><span class="p">):</span>
                            <span class="n">p_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">product_mul</span><span class="p">(</span><span class="n">p_term1</span><span class="p">,</span> <span class="n">p_term2</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                            <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">o_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">p_term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">product_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for Product simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.products</span> <span class="kn">import</span> <span class="n">Product</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x2</span> <span class="o">==</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">y2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

<span class="c">#-------------------- the old trigsimp routines ---------------------</span>
<span class="n">_trigs</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">trigsimp_old</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reduces expression by using known trig identities</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    deep:</span>
<span class="sd">    - Apply trigsimp inside all objects with arguments</span>

<span class="sd">    recursive:</span>
<span class="sd">    - Use common subexpression elimination (cse()) and apply</span>
<span class="sd">    trigsimp recursively (this is quite expensive if the</span>
<span class="sd">    expression is large)</span>

<span class="sd">    method:</span>
<span class="sd">    - Determine the method to use. Valid choices are &#39;matching&#39; (default),</span>
<span class="sd">    &#39;groebner&#39;, &#39;combined&#39;, &#39;fu&#39; and &#39;futrig&#39;. If &#39;matching&#39;, simplify the</span>
<span class="sd">    expression recursively by pattern matching. If &#39;groebner&#39;, apply an</span>
<span class="sd">    experimental groebner basis algorithm. In this case further options</span>
<span class="sd">    are forwarded to ``trigsimp_groebner``, please refer to its docstring.</span>
<span class="sd">    If &#39;combined&#39;, first run the groebner basis algorithm with small</span>
<span class="sd">    default parameters, then run the &#39;matching&#39; algorithm. &#39;fu&#39; runs the</span>
<span class="sd">    collection of trigonometric transformations described by Fu, et al.</span>
<span class="sd">    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms</span>
<span class="sd">    that mimic the behavior of `trigsimp`.</span>

<span class="sd">    compare:</span>
<span class="sd">    - show input and output from `trigsimp` and `futrig` when different,</span>
<span class="sd">    but returns the `trigsimp` value.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; e = 2*sin(x)**2 + 2*cos(x)**2</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(e, old=True)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(log(e), old=True)</span>
<span class="sd">    log(2*sin(x)**2 + 2*cos(x)**2)</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(log(e), deep=True, old=True)</span>
<span class="sd">    log(2)</span>

<span class="sd">    Using `method=&quot;groebner&quot;` (or `&quot;combined&quot;`) can sometimes lead to a lot</span>
<span class="sd">    more simplification:</span>

<span class="sd">    &gt;&gt;&gt; e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(e, old=True)</span>
<span class="sd">    (-sin(x) + 1)/cos(x) - cos(x)/(sin(x) - 1)</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(e, method=&quot;groebner&quot;, old=True)</span>
<span class="sd">    2/cos(x)</span>

<span class="sd">    &gt;&gt;&gt; trigsimp(1/cot(x)**2, compare=True, old=True)</span>
<span class="sd">          futrig: tan(x)**2</span>
<span class="sd">    cot(x)**(-2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">tan</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="n">fu</span>

    <span class="n">old</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;first&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">_trigs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="n">trigsyms</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="o">*</span><span class="n">_trigs</span><span class="p">)])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trigsyms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c"># remove hollow factoring</span>
                    <span class="n">was</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">opts</span><span class="p">[</span><span class="s">&#39;first&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">vnew</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">vnew</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                        <span class="n">vnew</span> <span class="o">=</span> <span class="n">was</span>
                    <span class="n">expr</span> <span class="o">*=</span> <span class="n">vnew</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">trigsyms</span><span class="p">:</span>
                        <span class="n">r</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                            <span class="n">opts</span><span class="p">[</span><span class="s">&#39;first&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="n">expr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                                <span class="k">break</span>
                    <span class="n">old</span> <span class="o">=</span> <span class="n">expr</span>

    <span class="n">recursive</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;recursive&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">deep</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;deep&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;method&#39;</span><span class="p">,</span> <span class="s">&#39;matching&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">groebnersimp</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">traverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">trigsimp_groebner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trigsimp_groebner</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

    <span class="n">trigsimpfunc</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;matching&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span>
        <span class="s">&#39;groebner&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">groebnersimp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)),</span>
        <span class="s">&#39;combined&#39;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">groebnersimp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                                       <span class="n">d</span><span class="p">,</span> <span class="n">polynomial</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">hints</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">tan</span><span class="p">]),</span>
                                   <span class="n">d</span><span class="p">))</span>
                   <span class="p">}[</span><span class="n">method</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">cse</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">trigsimpfunc</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deep</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sub</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">trigsimpfunc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">g</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">trigsimpfunc</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;compare&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">futrig</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">futrig:&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_dotrig</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to tell whether ``a`` and ``b`` have the same sorts</span>
<span class="sd">    of symbols in them -- no need to test hyperbolic patterns against</span>
<span class="sd">    expressions that have no hyperbolics in them.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">func</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">)</span> <span class="ow">or</span>
        <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">))</span>


<span class="n">_trigpat</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">def</span> <span class="nf">_trigpats</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">_trigpat</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a b c&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Wild</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c"># for the simplifications like sinh/cosh -&gt; tanh:</span>
    <span class="c"># DO NOT REORDER THE FIRST 14 since these are assumed to be in this</span>
    <span class="c"># order in _match_div_rewrite.</span>
    <span class="n">matchers_division</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span>
            <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span>
            <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span>

        <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">tanh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
            <span class="n">tanh</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">matchers_add</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">sinh</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">cosh</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c"># for cos(x)**2 + sin(x)**2 -&gt; 1</span>
    <span class="n">matchers_identity</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">((</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">c</span><span class="p">)))),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sinh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">c</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">((</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">c</span><span class="p">)))),</span>

    <span class="p">)</span>

    <span class="c"># Reduce any lingering artifacts, such as sin(x)**2 changing</span>
    <span class="c"># to 1-cos(x)**2 when sin(x)**2 was &quot;simpler&quot;</span>
    <span class="n">artifacts</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">),</span>

        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sinh</span><span class="p">),</span>

        <span class="c"># same as above but with noncommutative prefactor</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sinh</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">_trigpat</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">matchers_division</span><span class="p">,</span> <span class="n">matchers_add</span><span class="p">,</span>
        <span class="n">matchers_identity</span><span class="p">,</span> <span class="n">artifacts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_trigpat</span>


<span class="k">def</span> <span class="nf">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">rexp</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">rexph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper for _match_div_rewrite.</span>

<span class="sd">    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)</span>
<span class="sd">    and g(b_) are both positive or if c_ is an integer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># assert expr.is_Mul and expr.is_commutative and f != g</span>
    <span class="n">fargs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">gargs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">fargs</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">e</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">g</span><span class="p">:</span>
                    <span class="n">gargs</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">e</span>
                    <span class="k">continue</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">common</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fargs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">gargs</span><span class="p">)</span>
    <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">while</span> <span class="n">common</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">fe</span> <span class="o">=</span> <span class="n">fargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">ge</span> <span class="o">=</span> <span class="n">gargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fe</span> <span class="o">==</span> <span class="n">rexp</span><span class="p">(</span><span class="n">ge</span><span class="p">):</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">**</span><span class="n">rexph</span><span class="p">(</span><span class="n">fe</span><span class="p">))</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">fe</span>
            <span class="n">gargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ge</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">while</span> <span class="n">fargs</span><span class="p">:</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">fargs</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">gargs</span><span class="p">:</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">gargs</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="n">_idn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
<span class="n">_midn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span>
<span class="n">_one</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

<span class="k">def</span> <span class="nf">_match_div_rewrite</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;helper for __trigsimp&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span>
            <span class="n">_midn</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span>
            <span class="n">_idn</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">cot</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span>
            <span class="n">_idn</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span>
            <span class="n">_midn</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">_midn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">cot</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span>
            <span class="n">_midn</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">_midn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">cot</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span>
            <span class="n">_idn</span><span class="p">,</span> <span class="n">_one</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="c"># i in (6, 7) is skipped</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span>
            <span class="n">_midn</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
         <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span>
            <span class="n">_idn</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">coth</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span>
            <span class="n">_idn</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">11</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span>
            <span class="n">_midn</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">_midn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">12</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">coth</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span>
            <span class="n">_midn</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">_midn</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">_replace_mul_fpowxgpow</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">coth</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span>
            <span class="n">_idn</span><span class="p">,</span> <span class="n">_one</span><span class="p">,</span> <span class="n">_idn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">expr</span>


<span class="k">def</span> <span class="nf">_trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c"># protect the cache from non-trig patterns; we only allow</span>
    <span class="c"># trig patterns to enter the cache</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">_trigs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">__trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr</span>


<span class="nd">@cacheit</span>
<span class="k">def</span> <span class="nf">__trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;recursive helper for trigsimp&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="n">TR10i</span>

    <span class="k">if</span> <span class="n">_trigpat</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">_trigpats</span><span class="p">()</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">matchers_division</span><span class="p">,</span> <span class="n">matchers_add</span><span class="p">,</span> \
    <span class="n">matchers_identity</span><span class="p">,</span> <span class="n">artifacts</span> <span class="o">=</span> <span class="n">_trigpat</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="c"># do some simplifications like sin/cos -&gt; tan:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
            <span class="n">com</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">com</span><span class="p">),</span> <span class="n">deep</span><span class="p">)</span><span class="o">*</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">ok1</span><span class="p">,</span> <span class="n">ok2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matchers_division</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_dotrig</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">newexpr</span> <span class="o">=</span> <span class="n">_match_div_rewrite</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newexpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">newexpr</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">newexpr</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="c"># use SymPy matching instead</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">and</span> <span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
                        <span class="n">ok</span> <span class="o">=</span> <span class="n">ok1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">ok</span> <span class="o">=</span> <span class="n">ok2</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="c"># if &quot;a&quot; contains any of trig or hyperbolic funcs with</span>
                    <span class="c"># argument &quot;b&quot; then skip the simplification</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">res</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span>
                            <span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">)):</span>
                        <span class="k">continue</span>
                    <span class="c"># simplify and finish:</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                    <span class="k">break</span>  <span class="c"># process below</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">com</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">com</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">matchers_identity</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">term</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">*</span><span class="n">nc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span> <span class="o">!=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">expand</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">count_ops</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">matchers_add</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_dotrig</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">TR10i</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">):</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                    <span class="c"># if &quot;d&quot; contains any trig or hyperbolic funcs with</span>
                    <span class="c"># argument &quot;a&quot; or &quot;b&quot; then skip the simplification;</span>
                    <span class="c"># this isn&#39;t perfect -- see tests</span>
                    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span> <span class="ow">in</span> <span class="n">res</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">res</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
                        <span class="n">w</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span>
                            <span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">)):</span>
                        <span class="k">continue</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="c"># Reduce any lingering artifacts, such as sin(x)**2 changing</span>
        <span class="c"># to 1 - cos(x)**2 when sin(x)**2 was &quot;simpler&quot;</span>
        <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">artifacts</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_dotrig</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c"># Substitute a new wild that excludes some function(s)</span>
            <span class="c"># to help influence a better match. This is because</span>
            <span class="c"># sometimes, for example, &#39;a&#39; would match sec(x)**2</span>
            <span class="n">a_t</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">ex</span><span class="p">])</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_t</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_t</span><span class="p">)</span>

            <span class="n">m</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
            <span class="n">was</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">while</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">was</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                <span class="n">was</span> <span class="o">=</span> <span class="n">expr</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> \
                        <span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span> <span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                <span class="n">m</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">deep</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_trigsimp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">_trigs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new</span> <span class="o">==</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">fnew</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fnew</span> <span class="o">!=</span> <span class="n">new</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">new</span><span class="p">,</span> <span class="n">factor</span><span class="p">(</span><span class="n">new</span><span class="p">)],</span> <span class="n">key</span><span class="o">=</span><span class="n">count_ops</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># if all exp that were introduced disappeared then accept it</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">-</span> <span class="n">e</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">new</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">expr</span>
<span class="c">#------------------- end of old trigsimp routines --------------------</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Aug 04, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>