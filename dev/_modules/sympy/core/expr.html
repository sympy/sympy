

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.core.expr &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.core.expr</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">C</span>
<span class="kn">from</span> <span class="nn">.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">.basic</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">.singleton</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">.evalf</span> <span class="kn">import</span> <span class="n">EvalfMixin</span><span class="p">,</span> <span class="n">pure_complex</span>
<span class="kn">from</span> <span class="nn">.decorators</span> <span class="kn">import</span> <span class="n">_sympifyit</span><span class="p">,</span> <span class="n">call_highest_priority</span>
<span class="kn">from</span> <span class="nn">.cache</span> <span class="kn">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">.compatibility</span> <span class="kn">import</span> <span class="nb">reduce</span><span class="p">,</span> <span class="n">as_int</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">,</span> <span class="nb">xrange</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath.libmp</span> <span class="kn">import</span> <span class="n">mpf_log</span><span class="p">,</span> <span class="n">prec_to_dps</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getmro</span>


<div class="viewcode-block" id="Expr"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr">[docs]</a><span class="k">class</span> <span class="nc">Expr</span><span class="p">(</span><span class="n">Basic</span><span class="p">,</span> <span class="n">EvalfMixin</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_diff_wrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is it allowed to take derivative wrt to this instance.</span>

<span class="sd">        This determines if it is allowed to take derivatives wrt this object.</span>
<span class="sd">        Subclasses such as Symbol, Function and Derivative should return True</span>
<span class="sd">        to enable derivatives wrt them. The implementation in Derivative</span>
<span class="sd">        separates the Symbol and non-Symbol _diff_wrt=True variables and</span>
<span class="sd">        temporarily converts the non-Symbol vars in Symbols when performing</span>
<span class="sd">        the differentiation.</span>

<span class="sd">        Note, see the docstring of Derivative for how this should work</span>
<span class="sd">        mathematically.  In particular, note that expr.subs(yourclass, Symbol)</span>
<span class="sd">        should be well-defined on a structural level, or this will lead to</span>
<span class="sd">        inconsistent results.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Expr</span>
<span class="sd">        &gt;&gt;&gt; e = Expr()</span>
<span class="sd">        &gt;&gt;&gt; e._diff_wrt</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; class MyClass(Expr):</span>
<span class="sd">        ...     _diff_wrt = True</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; (2*MyClass()).diff(MyClass())</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_ordered_factors</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>

            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="p">])</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="n">args</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">coeff</span>

<div class="viewcode-block" id="Expr.rcall"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.rcall">[docs]</a>    <span class="k">def</span> <span class="nf">rcall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply on the argument recursively through the expression tree.</span>

<span class="sd">        This method is used to simulate a common abuse of notation for</span>
<span class="sd">        operators. For instance in SymPy the the following will not work:</span>

<span class="sd">        ``(x+Lambda(y, 2*y))(z) == x+2*z``,</span>

<span class="sd">        however you can use</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Lambda</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x,y,z</span>
<span class="sd">        &gt;&gt;&gt; (x + Lambda(y, 2*y)).rcall(z)</span>
<span class="sd">        x + 2*z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_recursive_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_call</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">,</span> <span class="n">on_args</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">the_call_method_is_overridden</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">getmro</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)):</span>
                <span class="k">if</span> <span class="s">&#39;__call__&#39;</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">cls</span> <span class="o">!=</span> <span class="n">Expr</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">)</span> <span class="ow">and</span> <span class="n">the_call_method_is_overridden</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>  <span class="c"># XXX When you call a Symbol it is</span>
                <span class="k">return</span> <span class="n">expr_to_call</span>               <span class="c"># transformed into an UndefFunction</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expr_to_call</span><span class="p">(</span><span class="o">*</span><span class="n">on_args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">expr_to_call</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">Expr</span><span class="o">.</span><span class="n">_recursive_call</span><span class="p">(</span>
                <span class="n">sub</span><span class="p">,</span> <span class="n">on_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">expr_to_call</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr_to_call</span>

    <span class="c"># ***************</span>
    <span class="c"># * Arithmetics *</span>
    <span class="c"># ***************</span>
    <span class="c"># Expr and its sublcasses use _op_priority to determine which object</span>
    <span class="c"># passed to a binary special method (__mul__, etc.) will handle the</span>
    <span class="c"># operation. In general, the &#39;call_highest_priority&#39; decorator will choose</span>
    <span class="c"># the object with the highest _op_priority to handle the call.</span>
    <span class="c"># Custom subclasses that want to define their own binary special methods</span>
    <span class="c"># should set an _op_priority value that is higher than the default.</span>
    <span class="c">#</span>
    <span class="c"># **NOTE**:</span>
    <span class="c"># This is a temporary fix, and will eventually be replaced with</span>
    <span class="c"># something better and more powerful.  See issue 2411.</span>
    <span class="n">_op_priority</span> <span class="o">=</span> <span class="mf">10.0</span>

    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__radd__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__add__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rsub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__sub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rmul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__mul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rpow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__pow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rdiv__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__div__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>

    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>
    <span class="n">__rtruediv__</span> <span class="o">=</span> <span class="n">__rdiv__</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rmod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__mod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Although we only need to round to the units position, we&#39;ll</span>
        <span class="c"># get one more digit so the extra testing below can be avoided</span>
        <span class="c"># unless the rounded value rounded to an integer, e.g. if an</span>
        <span class="c"># expression were equal to 1.9 and we rounded to the unit position</span>
        <span class="c"># we would get a 2 and would not know if this rounded up or not</span>
        <span class="c"># without doing a test (as done below). But if we keep an extra</span>
        <span class="c"># digit we know that 1.9 is not the same as 1 and there is no</span>
        <span class="c"># need for further testing: our int value is correct. If the value</span>
        <span class="c"># were 1.99, however, this would round to 2.0 and our int value is</span>
        <span class="c"># off by one. So...if our round value is the same as the int value</span>
        <span class="c"># (regardless of how much extra work we do to calculate extra decimal</span>
        <span class="c"># places) we need to test whether we are off by one.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t convert complex to int&quot;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="c"># off-by-one check</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">isign</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">()</span>
            <span class="c"># in the following (self - i).evalf(2) will not always work while</span>
            <span class="c"># (self - r).evalf(2) and the use of subs does; if the test that</span>
            <span class="c"># was added when this comment was added passes, it might be safe</span>
            <span class="c"># to simply use sign to compute this rather than doing this by hand:</span>
            <span class="n">diff_sign</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">diff_sign</span> <span class="o">!=</span> <span class="n">isign</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="n">isign</span>
        <span class="k">return</span> <span class="n">i</span>
    <span class="n">__long__</span> <span class="o">=</span> <span class="n">__int__</span>

    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Don&#39;t bother testing if it&#39;s a number; if it&#39;s not this is going</span>
        <span class="c"># to fail, and if it is we still need to check that it evalf&#39;ed to</span>
        <span class="c"># a number.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t convert complex to float&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t convert expression to float&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>  <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">GreaterThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>  <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">LessThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>  <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">StrictGreaterThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>  <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">StrictLessThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_mpmath</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;_mpf_&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;_mpc_&quot;</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_mpc_</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
            <span class="k">return</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;expected mpmath number (mpf or mpc)&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Expr.is_number"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_number">[docs]</a>    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if &#39;self&#39; has no free symbols.</span>
<span class="sd">        It will be faster than `if not self.free_symbols`, however, since</span>
<span class="sd">        `is_number` will fail as soon as it hits a free symbol.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import log, Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        &gt;&gt;&gt; x.is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2*x).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2 + log(2)).is_number</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (2 + Integral(2, x)).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2 + Integral(2, (x, 1, 2))).is_number</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_basic_args</span><span class="p">())</span>
</div>
    <span class="k">def</span> <span class="nf">_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">re_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">im_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">re_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">im_max</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self evaluated, if possible, replacing free symbols with</span>
<span class="sd">        random complex values, if necessary.</span>

<span class="sd">        The random complex value for each free symbol is generated</span>
<span class="sd">        by the random_complex_number routine giving real and imaginary</span>
<span class="sd">        parts in the range given by the re_min, re_max, im_min, and im_max</span>
<span class="sd">        values. The returned value is evaluated to a precision of n</span>
<span class="sd">        (if given) else the maximum of 15 and the precision needed</span>
<span class="sd">        to get more than 1 digit of precision. If the expression</span>
<span class="sd">        could not be evaluated to a number, or could not be evaluated</span>
<span class="sd">        to more than 1 digit of precision, then None is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; x._random()                         # doctest: +SKIP</span>
<span class="sd">        0.0392918155679172 + 0.916050214307199*I</span>
<span class="sd">        &gt;&gt;&gt; x._random(2)                        # doctest: +SKIP</span>
<span class="sd">        -0.77 - 0.87*I</span>
<span class="sd">        &gt;&gt;&gt; (x + y/2)._random(2)                # doctest: +SKIP</span>
<span class="sd">        -0.57 + 0.16*I</span>
<span class="sd">        &gt;&gt;&gt; sqrt(2)._random(2)</span>
<span class="sd">        1.4</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        sympy.utilities.randtest.random_complex_number</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">free</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.randtest</span> <span class="kn">import</span> <span class="n">random_complex_number</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">re_min</span><span class="p">,</span> <span class="n">re_max</span><span class="p">,</span> <span class="n">im_min</span><span class="p">,</span> <span class="n">im_max</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="n">random_complex_number</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">zi</span> <span class="ow">in</span> <span class="n">free</span><span class="p">])))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c"># if an out of range value resulted in evalf problems</span>
                <span class="c"># then return None -- XXX is there a way to know how to</span>
                <span class="c"># select a good random number for a given expression?</span>
                <span class="c"># e.g. when calculating n! negative values for n should not</span>
                <span class="c"># be used</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">nmag</span><span class="p">,</span> <span class="s">&#39;_prec&#39;</span><span class="p">):</span>
            <span class="c"># e.g. exp_polar(2*I*pi) doesn&#39;t evaluate but is_number is True</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">nmag</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># increase the precision up to the default maximum</span>
            <span class="c"># precision to see if we can get any significance</span>

            <span class="c"># get the prec steps (patterned after giant_steps in</span>
            <span class="c"># libintmath) which approximately doubles the prec</span>
            <span class="c"># each step</span>
            <span class="kn">from</span> <span class="nn">sympy.core.evalf</span> <span class="kn">import</span> <span class="n">DEFAULT_MAXPREC</span> <span class="k">as</span> <span class="n">target</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">Li</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">Li</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">Li</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
                        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Li</span><span class="p">)</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># evaluate</span>
            <span class="k">for</span> <span class="n">prec</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
                <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">nmag</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">nmag</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">)</span>

        <span class="c"># never got any significance</span>
        <span class="k">return</span> <span class="bp">None</span>

<div class="viewcode-block" id="Expr.is_constant"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_constant">[docs]</a>    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">wrt</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self is constant, False if not, or None if</span>
<span class="sd">        the constancy could not be determined conclusively.</span>

<span class="sd">        If an expression has no free symbols then it is a constant. If</span>
<span class="sd">        there are free symbols it is possible that the expression is a</span>
<span class="sd">        constant, perhaps (but not necessarily) zero. To test such</span>
<span class="sd">        expressions, two strategies are tried:</span>

<span class="sd">        1) numerical evaluation at two random points. If two such evaluations</span>
<span class="sd">        give two different values and the values have a precision greater than</span>
<span class="sd">        1 then self is not constant. If the evaluations agree or could not be</span>
<span class="sd">        obtained with any precision, no decision is made. The numerical testing</span>
<span class="sd">        is done only if ``wrt`` is different than the free symbols.</span>

<span class="sd">        2) differentiation with respect to variables in &#39;wrt&#39; (or all free</span>
<span class="sd">        symbols if omitted) to see if the expression is constant or not. This</span>
<span class="sd">        will not always lead to an expression that is zero even though an</span>
<span class="sd">        expression is constant (see added test in test_expr.py). If</span>
<span class="sd">        all derivatives are zero then self is constant with respect to the</span>
<span class="sd">        given symbols.</span>

<span class="sd">        If neither evaluation nor differentiation can prove the expression is</span>
<span class="sd">        constant, None is returned unless two numerical values happened to be</span>
<span class="sd">        the same and the flag ``failing_number`` is True -- in that case the</span>
<span class="sd">        numerical value will be returned.</span>

<span class="sd">        If flag simplify=False is passed, self will not be simplified;</span>
<span class="sd">        the default is True since self should be simplified before testing.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import cos, sin, Sum, S, pi</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import a, n, x, y</span>
<span class="sd">        &gt;&gt;&gt; x.is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; S(2).is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, 10)).is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant()  # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(n) # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; eq = a*cos(x)**2 + a*sin(x)**2 - a</span>
<span class="sd">        &gt;&gt;&gt; eq.is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; eq.subs({x:pi, a:2}) == eq.subs({x:pi, a:3}) == 0</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (0**x).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x.is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (x**x).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; one = cos(x)**2 + sin(x)**2</span>
<span class="sd">        &gt;&gt;&gt; one.is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c"># Except for expressions that contain units, only one of these should</span>
        <span class="c"># be necessary since if something is</span>
        <span class="c"># known to be a number it should also know that there are no</span>
        <span class="c"># free symbols. But is_number quits as soon as it hits a non-number</span>
        <span class="c"># whereas free_symbols goes until all free symbols have been collected,</span>
        <span class="c"># thus is_number should be faster. But a double check on free symbols</span>
        <span class="c"># is made just in case there is a discrepancy between the two.</span>
        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">free</span><span class="p">:</span>
            <span class="c"># if the following assertion fails then that object&#39;s free_symbols</span>
            <span class="c"># method needs attention: if an expression is a number it cannot</span>
            <span class="c"># have free symbols</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">free</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># if we are only interested in some symbols and they are not in the</span>
        <span class="c"># free symbols then this expression is constant wrt those symbols</span>
        <span class="n">wrt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wrt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrt</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wrt</span> <span class="o">&amp;</span> <span class="n">free</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">wrt</span> <span class="o">=</span> <span class="n">wrt</span> <span class="ow">or</span> <span class="n">free</span>

        <span class="c"># simplify unless this has already been done</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="c"># is_zero should be a quick assumptions check; it can be wrong for</span>
        <span class="c"># numbers (see test_is_not_constant test), giving False when it</span>
        <span class="c"># shouldn&#39;t, but hopefully it will never give True unless it is sure.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># try numerical evaluation to see if we get two different values</span>
        <span class="n">failing_number</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">wrt</span> <span class="o">==</span> <span class="n">free</span><span class="p">:</span>
            <span class="c"># try 0 and 1</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">))))</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="c"># try random real</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="c"># try random complex</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>
                    <span class="n">failing_number</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_number</span> <span class="k">else</span> <span class="n">b</span>

        <span class="c"># now we will test each wrt symbol (or all free symbols) to see if the</span>
        <span class="c"># expression depends on them or not using differentiation. This is</span>
        <span class="c"># not sufficient for all expressions, however, so we don&#39;t return</span>
        <span class="c"># False if we get a derivative other than 0 with free symbols.</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wrt</span><span class="p">:</span>
            <span class="n">deriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">deriv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">deriv</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">deriv</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;failing_number&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">failing_number</span>
                    <span class="k">elif</span> <span class="n">deriv</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                        <span class="c"># dead line provided _random returns None in such cases</span>
                        <span class="k">return</span> <span class="bp">None</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Expr.equals"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.equals">[docs]</a>    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">failing_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self == other, False if it doesn&#39;t, or None. If</span>
<span class="sd">        failing_expression is True then the expression which did not simplify</span>
<span class="sd">        to a 0 will be returned instead of None.</span>

<span class="sd">        If ``self`` is a Number (or complex number) that is not zero, then</span>
<span class="sd">        the result is False.</span>

<span class="sd">        If ``self`` is a number and has not evaluated to zero, evalf will be</span>
<span class="sd">        used to test whether the expression evaluates to zero. If it does so</span>
<span class="sd">        and the result has significance (i.e. the precision is either -1, for</span>
<span class="sd">        a Rational result, or is greater than 1) then the evalf value will be</span>
<span class="sd">        used to return True or False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">nsimplify</span><span class="p">,</span> <span class="n">simplify</span>
        <span class="kn">from</span> <span class="nn">sympy.solvers.solvers</span> <span class="kn">import</span> <span class="n">solve</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="kn">import</span> <span class="n">NotAlgebraic</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.numberfields</span> <span class="kn">import</span> <span class="n">minimal_polynomial</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># they aren&#39;t the same so see if we can make the difference 0;</span>
        <span class="c"># don&#39;t worry about doing simplification steps one at a time</span>
        <span class="c"># because if the expression ever goes to 0 then the subsequent</span>
        <span class="c"># simplification steps that are done will be very fast.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">((</span><span class="bp">self</span> <span class="o">-</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="n">radical</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">diff</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">diff</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Add</span><span class="p">):</span>
            <span class="c"># if there is no expanding to be done after simplifying</span>
            <span class="c"># then this can&#39;t be a zero</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">constant</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">failing_number</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">free_symbols</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_number</span><span class="p">):</span>
            <span class="c"># e.g. unless the right simplification is done, a symbolic</span>
            <span class="c"># zero is possible (see expression of issue 3730: without</span>
            <span class="c"># simplification constant will be None).</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">ndiff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">_random</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ndiff</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># sometimes we can use a simplified result to give a clue as to</span>
        <span class="c"># what the expression should be; if the expression is *not* zero</span>
        <span class="c"># then we should have been able to compute that and so now</span>
        <span class="c"># we can just consider the cases where the approximation appears</span>
        <span class="c"># to be zero -- we try to prove it via minimal_polynomial.</span>
        <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">approx</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">approx</span><span class="p">:</span>
                <span class="c"># try to prove via self-consistency</span>
                <span class="n">surds</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">diff</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Pow</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">]</span>
                <span class="c"># it seems to work better to try big ones first</span>
                <span class="n">surds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">surds</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c"># simplify is False here -- this expression has already</span>
                        <span class="c"># been identified as being hard to identify as zero;</span>
                        <span class="c"># we will handle the checking ourselves using nsimplify</span>
                        <span class="c"># to see if we are in the right ballpark or not and if so</span>
                        <span class="c"># *then* the simplification will be attempted.</span>
                        <span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">sol</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
                                <span class="k">return</span> <span class="bp">True</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nsimplify</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">simplify</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span>
                                    <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">):</span>
                                <span class="k">return</span> <span class="bp">True</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>

                <span class="c"># try to prove with minimal_polynomial but know when</span>
                <span class="c"># *not* to use this or else it can take a long time.</span>
                <span class="c"># Pernici noted the following:</span>
                <span class="c"># &gt;&gt;&gt; q = -73*sqrt(3) + 1 + 128*sqrt(5) + 1315*sqrt(2)</span>
                <span class="c"># &gt;&gt;&gt; p = expand(q**3)**Rational(1, 3)</span>
                <span class="c"># &gt;&gt;&gt; minimal_polynomial(p - q)  # hangs for at least 15 minutes</span>
                <span class="k">if</span> <span class="bp">False</span><span class="p">:</span>  <span class="c"># change False to condition that assures non-hang</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">mp</span> <span class="o">=</span> <span class="n">minimal_polynomial</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mp</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">True</span>
                        <span class="k">return</span> <span class="bp">False</span>
                    <span class="k">except</span> <span class="n">NotAlgebraic</span><span class="p">:</span>
                        <span class="k">pass</span>

        <span class="c"># diff has not simplified to zero; constant is either None, True</span>
        <span class="c"># or the number with significance (prec != 1) that was randomly</span>
        <span class="c"># calculated twice as the same value.</span>
        <span class="k">if</span> <span class="n">constant</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">constant</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">failing_expression</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">diff</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_is_positive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># check to see that we can get a value</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
                <span class="k">if</span> <span class="n">n2</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># no significance</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_eval_is_negative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># check to see that we can get a value</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
                <span class="k">if</span> <span class="n">n2</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># no significance</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_eval_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evaluation over an interval.  For most functions this is:</span>

<span class="sd">        self.subs(x, b) - self.subs(x, a),</span>

<span class="sd">        possibly using limit() if NaN is returned from subs.</span>

<span class="sd">        If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),</span>
<span class="sd">        respectively.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series</span> <span class="kn">import</span> <span class="n">limit</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Both interval ends cannot be None.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">A</span>

        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">):</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">_eval_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c"># subclass to compute self**other for cases when</span>
        <span class="c"># other is not NaN, 0, or 1</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_eval_conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_imaginary</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span>

    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">conjugate</span> <span class="k">as</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">conjugate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_antihermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">transpose</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">transpose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_antihermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_conjugate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_transpose</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conjugate</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">adjoint</span>
        <span class="k">return</span> <span class="n">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_order</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse and configure the ordering of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.orderings</span> <span class="kn">import</span> <span class="n">monomial_key</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;rev-&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="n">monom_key</span> <span class="o">=</span> <span class="n">monomial_key</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="n">monom</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monom</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="o">=</span> <span class="n">term</span>

            <span class="n">monom</span> <span class="o">=</span> <span class="n">neg</span><span class="p">(</span><span class="n">monom_key</span><span class="p">(</span><span class="n">monom</span><span class="p">))</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">e</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ncpart</span> <span class="p">])</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="nb">bool</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">im</span><span class="p">),</span> <span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">,</span> <span class="n">coeff</span>

        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span>

<div class="viewcode-block" id="Expr.as_ordered_factors"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_ordered_factors">[docs]</a>    <span class="k">def</span> <span class="nf">as_ordered_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of ordered factors (if Mul) else [self].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Expr.as_ordered_terms"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_ordered_terms">[docs]</a>    <span class="k">def</span> <span class="nf">as_ordered_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform an expression to an ordered list of terms.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()</span>
<span class="sd">        [sin(x)**2*cos(x), sin(x)**2, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_terms</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">is_Order</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">):</span>
            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_terms</span><span class="p">,</span> <span class="n">_order</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="nb">repr</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                    <span class="n">_terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>

            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> \
                <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_order</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">gens</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">term</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ordered</span> <span class="p">]</span>
</div>
<div class="viewcode-block" id="Expr.as_terms"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_terms">[docs]</a>    <span class="k">def</span> <span class="nf">as_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform an expression to a list of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">S</span>
        <span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">decompose_power</span>

        <span class="n">gens</span><span class="p">,</span> <span class="n">terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([]),</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">_term</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">coeff</span> <span class="o">*=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                        <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">decompose_power</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

                        <span class="n">cpart</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ncpart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">coeff</span><span class="o">.</span><span class="n">imag</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ncpart</span><span class="p">)</span>

            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="n">gens</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="n">k</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">),</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gens</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">monom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span>

            <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">cpart</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">monom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">base</span><span class="p">]]</span> <span class="o">=</span> <span class="n">exp</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">monom</span><span class="p">),</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">gens</span>
</div>
<div class="viewcode-block" id="Expr.removeO"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.removeO">[docs]</a>    <span class="k">def</span> <span class="nf">removeO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the additive O(..) symbol if there is one&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Expr.getO"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.getO">[docs]</a>    <span class="k">def</span> <span class="nf">getO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the additive O(..) symbol if there is one, else None.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Expr.getn"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.getn">[docs]</a>    <span class="k">def</span> <span class="nf">getn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the order of the expression.</span>

<span class="sd">        The order is determined either from the O(...) term. If there</span>
<span class="sd">        is no O(...) term, it returns None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import O</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1 + x + O(x**2)).getn()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (1 + x).getn()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">expr</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>  <span class="c"># x**n*log(x)**n or x**n/log(x)**n</span>
                <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
                    <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                        <span class="n">syms</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">oi</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;not sure of order of </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">o</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.count_ops"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.count_ops">[docs]</a>    <span class="k">def</span> <span class="nf">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;wrapper for count_ops that returns the operation count.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.function</span> <span class="kn">import</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.args_cnc"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.args_cnc">[docs]</a>    <span class="k">def</span> <span class="nf">args_cnc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cset</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">split_1</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return [commutative factors, non-commutative factors] of self.</span>

<span class="sd">        self is treated as a Mul and the ordering of the factors is maintained.</span>
<span class="sd">        If ``cset`` is True the commutative factors will be returned in a set.</span>
<span class="sd">        If there were repeated factors (as may happen with an unevaluated Mul)</span>
<span class="sd">        then an error will be raised unless it is explicitly supressed by</span>
<span class="sd">        setting ``warn`` to False.</span>

<span class="sd">        Note: -1 is always separated from a Number unless split_1 is False.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, oo</span>
<span class="sd">        &gt;&gt;&gt; A, B = symbols(&#39;A B&#39;, commutative=0)</span>
<span class="sd">        &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*y).args_cnc()</span>
<span class="sd">        [[-1, 2, x, y], []]</span>
<span class="sd">        &gt;&gt;&gt; (-2.5*x).args_cnc()</span>
<span class="sd">        [[-1, 2.5, x], []]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*A*B*y).args_cnc()</span>
<span class="sd">        [[-1, 2, x, y], [A, B]]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*A*B*y).args_cnc(split_1=False)</span>
<span class="sd">        [[-2, x, y], [A, B]]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*y).args_cnc(cset=True)</span>
<span class="sd">        [set([-1, 2, x, y]), []]</span>

<span class="sd">        The arg is always treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (-2 + x + A).args_cnc()</span>
<span class="sd">        [[], [x - 2 + A]]</span>
<span class="sd">        &gt;&gt;&gt; (-oo).args_cnc() # -oo is a singleton</span>
<span class="sd">        [[-1, oo], []]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mi</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">split_1</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">and</span>
                <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">cset</span><span class="p">:</span>
            <span class="n">clen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clen</span> <span class="ow">and</span> <span class="n">warn</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">clen</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;repeated commutative arguments: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                                 <span class="p">[</span><span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Expr.coeff"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.coeff">[docs]</a>    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coefficient from the term(s) containing ``x**n`` or None. If ``n``</span>
<span class="sd">        is zero then all terms independent of ``x`` will be returned.</span>

<span class="sd">        When x is noncommutative, the coeff to the left (default) or right of x</span>
<span class="sd">        can be returned. The keyword &#39;right&#39; is ignored when x is commutative.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        as_coefficient: separate the expression into a coefficient and factor</span>
<span class="sd">        as_coeff_Add: separate the additive constant from an expression</span>
<span class="sd">        as_coeff_Mul: separate the multiplicative constant from an expression</span>
<span class="sd">        as_independent: separate x-dependent terms/factors from others</span>
<span class="sd">        sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly</span>
<span class="sd">        sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        You can select terms that have an explicit negative in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x + 2*y).coeff(-1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (x - 2*y).coeff(-1)</span>
<span class="sd">        2*y</span>

<span class="sd">        You can select terms with no Rational coefficient:</span>

<span class="sd">        &gt;&gt;&gt; (x + 2*y).coeff(1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(1)</span>
<span class="sd">        0</span>

<span class="sd">        You can select terms independent of x by making n=0; in this case</span>
<span class="sd">        expr.as_independent(x)[0] is returned (and 0 will be returned instead</span>
<span class="sd">        of None):</span>

<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x, 0)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; eq = ((x + 1)**3).expand() + 1</span>
<span class="sd">        &gt;&gt;&gt; eq</span>
<span class="sd">        x**3 + 3*x**2 + 3*x + 2</span>
<span class="sd">        &gt;&gt;&gt; [eq.coeff(x, i) for i in reversed(range(4))]</span>
<span class="sd">        [1, 3, 3, 2]</span>
<span class="sd">        &gt;&gt;&gt; eq -= 2</span>
<span class="sd">        &gt;&gt;&gt; [eq.coeff(x, i) for i in reversed(range(4))]</span>
<span class="sd">        [1, 3, 3, 0]</span>

<span class="sd">        You can select terms that have a numerical term in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x - 2*y).coeff(2)</span>
<span class="sd">        -y</span>
<span class="sd">        &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">        &gt;&gt;&gt; (x + sqrt(2)*x).coeff(sqrt(2))</span>
<span class="sd">        x</span>

<span class="sd">        The matching is exact:</span>

<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x**2)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x**3)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; (z*(x + y)**2).coeff((x + y)**2)</span>
<span class="sd">        z</span>
<span class="sd">        &gt;&gt;&gt; (z*(x + y)**2).coeff(x + y)</span>
<span class="sd">        0</span>

<span class="sd">        In addition, no factoring is done, so 1 + z*(1 + y) is not obtained</span>
<span class="sd">        from the following:</span>

<span class="sd">        &gt;&gt;&gt; (x + z*(x + x*y)).coeff(x)</span>
<span class="sd">        1</span>

<span class="sd">        If such factoring is desired, factor_terms can be used first:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import factor_terms</span>
<span class="sd">        &gt;&gt;&gt; factor_terms(x + z*(x + x*y)).coeff(x)</span>
<span class="sd">        z*(y + 1) + 1</span>

<span class="sd">        &gt;&gt;&gt; n, m, o = symbols(&#39;n m o&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; n.coeff(n)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (3*n).coeff(n)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n) # = (1 + m)*n*m</span>
<span class="sd">        1 + m</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m</span>
<span class="sd">        m</span>

<span class="sd">        If there is more than one possible coefficient 0 is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + m*n).coeff(n)</span>
<span class="sd">        0</span>

<span class="sd">        If there is only one possible coefficient, it is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + x*m*n).coeff(m*n)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (n*m + x*m*n).coeff(m*n, right=1)</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="n">co</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
                <span class="k">return</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># continue with the full method, looking for this power of x:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span>

        <span class="k">def</span> <span class="nf">incommon</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">l1</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">l1</span><span class="p">[:]</span>

        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Find where list sub appears in list l. When ``first`` is True</span>
<span class="sd">            the first occurance from the left is returned, else the last</span>
<span class="sd">            occurance is returned. Return None if sub is not in l.</span>

<span class="sd">            &gt;&gt; l = range(5)*2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3])</span>
<span class="sd">            2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3], first=0)</span>
<span class="sd">            7</span>
<span class="sd">            &gt;&gt; find(l, [2, 4])</span>
<span class="sd">            None</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sub</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sub</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span>

        <span class="n">co</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">self_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="n">x_c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="k">if</span> <span class="n">self_c</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">self_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">elif</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="n">nc</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">elif</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># both nc</span>
            <span class="n">xargs</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c"># find the parts that pass the commutative terms</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">resid</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
            <span class="c"># now check the non-comm parts</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">co</span><span class="p">]),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="n">beg</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">beg</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="n">gcdc</span> <span class="o">=</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">co</span><span class="p">)):</span>
                            <span class="n">gcdc</span> <span class="o">=</span> <span class="n">gcdc</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">gcdc</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gcdc</span><span class="p">)</span> <span class="o">+</span> <span class="n">beg</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">m</span><span class="p">:]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span>
                <span class="nb">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">+</span> <span class="n">ii</span><span class="p">]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="c"># look for single match</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span><span class="p">:</span>
                        <span class="n">hit</span> <span class="o">=</span> <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                    <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hit</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>

            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
</div>
<div class="viewcode-block" id="Expr.as_expr"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_expr">[docs]</a>    <span class="k">def</span> <span class="nf">as_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a polynomial to a SymPy expression.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; f = (x**2 + x*y).as_poly(x, y)</span>
<span class="sd">        &gt;&gt;&gt; f.as_expr()</span>
<span class="sd">        x**2 + x*y</span>

<span class="sd">        &gt;&gt;&gt; sin(x).as_expr()</span>
<span class="sd">        sin(x)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Expr.as_coefficient"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">as_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts symbolic coefficient at the given expression. In</span>
<span class="sd">        other words, this functions separates &#39;self&#39; into the product</span>
<span class="sd">        of &#39;expr&#39; and &#39;expr&#39;-free coefficient. If such separation</span>
<span class="sd">        is not possible it will return None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import E, pi, sin, I, Poly</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        &gt;&gt;&gt; E.as_coefficient(E)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (2*E).as_coefficient(E)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (2*sin(E)*E).as_coefficient(E)</span>

<span class="sd">        Two terms have E in them so a sum is returned. (If one were</span>
<span class="sd">        desiring the coefficient of the term exactly matching E then</span>
<span class="sd">        the constant from the returned expression could be selected.</span>
<span class="sd">        Or, for greater precision, a method of Poly can be used to</span>
<span class="sd">        indicate the desired term from which the coefficient is</span>
<span class="sd">        desired.)</span>

<span class="sd">        &gt;&gt;&gt; (2*E + x*E).as_coefficient(E)</span>
<span class="sd">        x + 2</span>
<span class="sd">        &gt;&gt;&gt; _.args[0]  # just want the exact match</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; p = Poly(2*E + x*E); p</span>
<span class="sd">        Poly(x*E + 2*E, x, E, domain=&#39;ZZ&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p.coeff_monomial(E)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; p.nth(0,1)</span>
<span class="sd">        2</span>

<span class="sd">        Since the following cannot be written as a product containing</span>
<span class="sd">        E as a factor, None is returned. (If the coefficient ``2*x`` is</span>
<span class="sd">        desired then the ``coeff`` method should be used.)</span>

<span class="sd">        &gt;&gt;&gt; (2*E*x + x).as_coefficient(E)</span>
<span class="sd">        &gt;&gt;&gt; (2*E*x + x).coeff(E)</span>
<span class="sd">        2*x</span>

<span class="sd">        &gt;&gt;&gt; (E*(x + 1) + x).as_coefficient(E)</span>

<span class="sd">        &gt;&gt;&gt; (2*pi*I).as_coefficient(pi*I)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (2*I).as_coefficient(pi*I)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        coeff: return sum of terms have a given factor</span>
<span class="sd">        as_coeff_Add: separate the additive constant from an expression</span>
<span class="sd">        as_coeff_Mul: separate the multiplicative constant from an expression</span>
<span class="sd">        as_independent: separate x-dependent terms/factors from others</span>
<span class="sd">        sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly</span>
<span class="sd">        sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="Expr.as_independent"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_independent">[docs]</a>    <span class="k">def</span> <span class="nf">as_independent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">,</span> <span class="o">**</span><span class="n">hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mostly naive separation of a Mul or Add into arguments that are not</span>
<span class="sd">        are dependent on deps. To obtain as complete a separation of variables</span>
<span class="sd">        as possible, use a separation method first, e.g.:</span>

<span class="sd">        * separatevars() to change Mul, Add and Pow (including exp) into Mul</span>
<span class="sd">        * .expand(mul=True) to change Add or Mul into Add</span>
<span class="sd">        * .expand(log=True) to change log expr into an Add</span>

<span class="sd">        The only non-naive thing that is done here is to respect noncommutative</span>
<span class="sd">        ordering of variables.</span>

<span class="sd">        The returned tuple (i, d) has the following interpretation:</span>

<span class="sd">        * i will has no variable that appears in deps</span>
<span class="sd">        * d will be 1 or else have terms that contain variables that are in deps</span>
<span class="sd">        * if self is an Add then self = i + d</span>
<span class="sd">        * if self is a Mul then self = i*d</span>
<span class="sd">        * if self is anything else, either tuple (self, S.One) or (S.One, self)</span>
<span class="sd">          is returned.</span>

<span class="sd">        To force the expression to be treated as an Add, use the hint as_Add=True</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        -- self is an Add</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos, exp</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(x)</span>
<span class="sd">        (0, x*y + x)</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x)</span>
<span class="sd">        (y + z, 2*x*sin(x) + x)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x, y)</span>
<span class="sd">        (z, 2*x*sin(x) + x + y)</span>

<span class="sd">        -- self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; (x*sin(x)*cos(y)).as_independent(x)</span>
<span class="sd">        (cos(y), x*sin(x))</span>

<span class="sd">        non-commutative terms cannot always be separated out when self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; n1, n2, n3 = symbols(&#39;n1 n2 n3&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; (n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (n1, n1*n2)</span>
<span class="sd">        &gt;&gt;&gt; (n2*n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (0, n1*n2 + n2*n1)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n1)</span>
<span class="sd">        (1, n1*n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n2)</span>
<span class="sd">        (n1, n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; ((x-n1)*(x-y)).as_independent(x)</span>
<span class="sd">        (1, (x - y)*(x - n1))</span>

<span class="sd">        -- self is anything else:</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(x)</span>
<span class="sd">        (1, sin(x))</span>
<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(y)</span>
<span class="sd">        (sin(x), 1)</span>
<span class="sd">        &gt;&gt;&gt; exp(x+y).as_independent(x)</span>
<span class="sd">        (1, exp(x + y))</span>

<span class="sd">        -- force self to be treated as an Add:</span>

<span class="sd">        &gt;&gt;&gt; (3*x).as_independent(x, as_Add=True)</span>
<span class="sd">        (0, 3*x)</span>

<span class="sd">        -- force self to be treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (3+x).as_independent(x, as_Add=False)</span>
<span class="sd">        (1, x + 3)</span>
<span class="sd">        &gt;&gt;&gt; (-3+x).as_independent(x, as_Add=False)</span>
<span class="sd">        (1, x - 3)</span>

<span class="sd">        Note how the below differs from the above in making the</span>
<span class="sd">        constant on the dep term positive.</span>

<span class="sd">        &gt;&gt;&gt; (y*(-3+x)).as_independent(x)</span>
<span class="sd">        (y, x - 3)</span>

<span class="sd">        -- use .as_independent() for true independence testing instead</span>
<span class="sd">           of .has(). The former considers only symbols in the free</span>
<span class="sd">           symbols while the latter considers all symbols</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; I = Integral(x, (x, 1, 2))</span>
<span class="sd">        &gt;&gt;&gt; I.has(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x in I.free_symbols</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; I.as_independent(x) == (I, 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (I + x).as_independent(x) == (I, x)</span>
<span class="sd">        True</span>

<span class="sd">        Note: when trying to get independent terms, a separation method</span>
<span class="sd">        might need to be used first. In this case, it is important to keep</span>
<span class="sd">        track of what you send to this routine so you know how to interpret</span>
<span class="sd">        the returned values</span>

<span class="sd">        &gt;&gt;&gt; from sympy import separatevars, log</span>
<span class="sd">        &gt;&gt;&gt; separatevars(exp(x+y)).as_independent(x)</span>
<span class="sd">        (exp(y), exp(x))</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; separatevars(x + x*y).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).expand(mul=True).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; a, b=symbols(&#39;a b&#39;,positive=True)</span>
<span class="sd">        &gt;&gt;&gt; (log(a*b).expand(log=True)).as_independent(b)</span>
<span class="sd">        (log(a), log(b))</span>

<span class="sd">        See also: .separatevars(), .expand(log=True),</span>
<span class="sd">                  .as_two_terms(), .as_coeff_add(), .as_coeff_mul()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">sift</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="c"># sift out deps into symbolic and other and ignore</span>
        <span class="c"># all symbols but those that are in the free symbols</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>  <span class="c"># Symbol.is_Symbol is True</span>
                <span class="n">sym</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;return the standard has() if there are no literal symbols, else</span>
<span class="sd">            check to see that symbol-deps are in the free symbols.&quot;&quot;&quot;</span>
            <span class="n">has_other</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">has_other</span>
            <span class="k">return</span> <span class="n">has_other</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">sym</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;as_Add&#39;</span><span class="p">,</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Add</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Mul</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">func</span> <span class="ow">or</span>
                <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Add</span> <span class="ow">and</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">want</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">want</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">depend</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">True</span><span class="p">]</span>
        <span class="n">indep</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">False</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span>  <span class="c"># all terms were treated as commutative</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span>
                    <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># handle noncommutative by stopping at first dependent term</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">has</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">depend</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nc</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                    <span class="k">break</span>
                <span class="n">indep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.as_real_imag"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_real_imag">[docs]</a>    <span class="k">def</span> <span class="nf">as_real_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs complex expansion on &#39;self&#39; and returns a tuple</span>
<span class="sd">           containing collected both real and imaginary parts. This</span>
<span class="sd">           method can&#39;t be confused with re() and im() functions,</span>
<span class="sd">           which does not perform complex expansion at evaluation.</span>

<span class="sd">           However it is possible to expand both re() and im()</span>
<span class="sd">           functions and get exactly the same results as with</span>
<span class="sd">           a single call to this function.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import symbols, I</span>

<span class="sd">           &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;, real=True)</span>

<span class="sd">           &gt;&gt;&gt; (x + y*I).as_real_imag()</span>
<span class="sd">           (x, y)</span>

<span class="sd">           &gt;&gt;&gt; from sympy.abc import z, w</span>

<span class="sd">           &gt;&gt;&gt; (z + w*I).as_real_imag()</span>
<span class="sd">           (re(z) - im(w), re(w) + im(z))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">C</span><span class="o">.</span><span class="n">im</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Expr.as_powers_dict"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_powers_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_powers_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self as a dictionary of factors with each factor being</span>
<span class="sd">        treated as a power. The keys are the bases of the factors and the</span>
<span class="sd">        values, the corresponding exponents. The resulting dictionary should</span>
<span class="sd">        be used with caution if the expression is a Mul and contains non-</span>
<span class="sd">        commutative factors since the order that they appeared will be lost in</span>
<span class="sd">        the dictionary.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()]))</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="Expr.as_coefficients_dict"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coefficients_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_coefficients_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping terms to their Rational coefficient.</span>
<span class="sd">        Since the dictionary is a defaultdict, inquiries about terms which</span>
<span class="sd">        were not present will return a coefficient of 0. If an expression is</span>
<span class="sd">        not an Add it is considered to have a single term.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import a, x</span>
<span class="sd">        &gt;&gt;&gt; (3*x + a*x + 4).as_coefficients_dict()</span>
<span class="sd">        {1: 4, x: 3, a*x: 1}</span>
<span class="sd">        &gt;&gt;&gt; _[a]</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; (3*a*x).as_coefficients_dict()</span>
<span class="sd">        {a*x: 3}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">m</span><span class="p">:</span> <span class="n">c</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
    <span class="k">def</span> <span class="nf">as_base_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># a -&gt; b ** e</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

<div class="viewcode-block" id="Expr.as_coeff_mul"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_mul">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as a Mul, ``m``.</span>

<span class="sd">        c should be a Rational multiplied by any terms of the Mul that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other terms of m; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is a Mul or not but</span>
<span class="sd">        you want to treat self as a Mul or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as a Mul.</span>

<span class="sd">        - if you know self is a Mul and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail;</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use ``self.as_independent(*deps)``</span>

<span class="sd">        &gt;&gt;&gt; from sympy import S</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (S(3)).as_coeff_mul()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul()</span>
<span class="sd">        (3, (x, y))</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, ())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
</div>
<div class="viewcode-block" id="Expr.as_coeff_add"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_add">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as an Add, ``a``.</span>

<span class="sd">        c should be a Rational added to any terms of the Add that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other terms of ``a``; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is an Add or not but</span>
<span class="sd">        you want to treat self as an Add or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as an Add.</span>

<span class="sd">        - if you know self is an Add and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail.</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use ``self.as_independent(*deps)``</span>

<span class="sd">        &gt;&gt;&gt; from sympy import S</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (S(3)).as_coeff_add()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3 + x).as_coeff_add()</span>
<span class="sd">        (3, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3 + x + y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3 + y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, ())</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
</div>
<div class="viewcode-block" id="Expr.primitive"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.primitive">[docs]</a>    <span class="k">def</span> <span class="nf">primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the positive Rational that can be extracted non-recursively</span>
<span class="sd">        from every term of self (i.e., self is treated like an Add). This is</span>
<span class="sd">        like the as_coeff_Mul() method but primitive always extracts a positive</span>
<span class="sd">        Rational (never a negative or a Float).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (3*(x + 1)**2).primitive()</span>
<span class="sd">        (3, (x + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; a = (6*x + 2); a.primitive()</span>
<span class="sd">        (2, 3*x + 1)</span>
<span class="sd">        &gt;&gt;&gt; b = (x/2 + 3); b.primitive()</span>
<span class="sd">        (1/2, x + 6)</span>
<span class="sd">        &gt;&gt;&gt; (a*b).primitive() == (1, a*b)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="Expr.as_content_primitive"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_content_primitive">[docs]</a>    <span class="k">def</span> <span class="nf">as_content_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radical</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method should recursively remove a Rational from all arguments</span>
<span class="sd">        and return that (content) and the new self (primitive). The content</span>
<span class="sd">        should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.</span>
<span class="sd">        The primitive need no be in canonical form and should try to preserve</span>
<span class="sd">        the underlying structure if possible (i.e. expand_mul should not be</span>
<span class="sd">        applied to self).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        &gt;&gt;&gt; eq = 2 + 2*x + 2*y*(3 + 3*y)</span>

<span class="sd">        The as_content_primitive function is recursive and retains structure:</span>

<span class="sd">        &gt;&gt;&gt; eq.as_content_primitive()</span>
<span class="sd">        (2, x + 3*y*(y + 1) + 1)</span>

<span class="sd">        Integer powers will have Rationals extracted from the base:</span>

<span class="sd">        &gt;&gt;&gt; ((2 + 6*x)**2).as_content_primitive()</span>
<span class="sd">        (4, (3*x + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; ((2 + 6*x)**(2*y)).as_content_primitive()</span>
<span class="sd">        (1, (2*(3*x + 1))**(2*y))</span>

<span class="sd">        Terms may end up joining once their as_content_primitives are added:</span>

<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (11, x*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (9, x*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (1, 6.0*x*(y + 1) + 3*z*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()</span>
<span class="sd">        (121, x**2*(y + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()</span>
<span class="sd">        (1, 121.0*x**2*(y + 1)**2)</span>

<span class="sd">        Radical content can also be factored out of the primitive:</span>

<span class="sd">        &gt;&gt;&gt; (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)</span>
<span class="sd">        (2, sqrt(2)*(1 + 2*sqrt(5)))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Expr.as_numer_denom"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_numer_denom">[docs]</a>    <span class="k">def</span> <span class="nf">as_numer_denom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; expression -&gt; a/b -&gt; a, b</span>

<span class="sd">        This is just a stub that should be defined by</span>
<span class="sd">        an object&#39;s class methods to get anything else.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        normal: return a/b instead of a, b</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
</div>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>

<div class="viewcode-block" id="Expr.extract_multiplicatively"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.extract_multiplicatively">[docs]</a>    <span class="k">def</span> <span class="nf">extract_multiplicatively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None if it&#39;s not possible to make self in the form</span>
<span class="sd">           c * something in a nice way, i.e. preserving the properties</span>
<span class="sd">           of arguments of self.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import symbols, Rational</span>

<span class="sd">           &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;, real=True)</span>

<span class="sd">           &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**2 * y)</span>
<span class="sd">           x*y**2</span>

<span class="sd">           &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**4 * y)</span>

<span class="sd">           &gt;&gt;&gt; (2*x).extract_multiplicatively(2)</span>
<span class="sd">           x</span>

<span class="sd">           &gt;&gt;&gt; (2*x).extract_multiplicatively(3)</span>

<span class="sd">           &gt;&gt;&gt; (Rational(1,2)*x).extract_multiplicatively(3)</span>
<span class="sd">           x/6</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">cc</span><span class="p">,</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">quotient</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">/</span> <span class="n">c</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_NumberSymbol</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">quotient</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">,</span> <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">newarg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newarg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                <span class="n">newarg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newarg</span>
                    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.extract_additively"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.extract_additively">[docs]</a>    <span class="k">def</span> <span class="nf">extract_additively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self - c if it&#39;s possible to subtract c from self and</span>
<span class="sd">        make all matching coefficients move towards zero, else return None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; e = 2*x + 3</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(x + 1)</span>
<span class="sd">        x + 2</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(3*x)</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(4)</span>
<span class="sd">        &gt;&gt;&gt; (y*(x + 1)).extract_additively(x + 1)</span>
<span class="sd">        &gt;&gt;&gt; ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)</span>
<span class="sd">        (x + 1)*(x + 2*y) + 3</span>

<span class="sd">        Sometimes auto-expansion will return a less simplified result</span>
<span class="sd">        than desired; gcd_terms might be used in such cases:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import gcd_terms</span>
<span class="sd">        &gt;&gt;&gt; (4*x*(y + 1) + y).extract_additively(x)</span>
<span class="sd">        4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y</span>
<span class="sd">        &gt;&gt;&gt; gcd_terms(_)</span>
<span class="sd">        x*(4*y + 3) + y</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        extract_multiplicatively</span>
<span class="sd">        coeff</span>
<span class="sd">        as_coefficient</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">co</span> <span class="o">-</span> <span class="n">c</span>
            <span class="c"># XXX should we match types? i.e should 3 - .1 succeed?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">co</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">co</span> <span class="ow">or</span>
                    <span class="n">co</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">co</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">diff</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="n">co</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">xa</span> <span class="o">+</span> <span class="n">t</span>

        <span class="c"># handle the args[0].is_Number case separately</span>
        <span class="c"># since we will have trouble looking for the coeff of</span>
        <span class="c"># a number.</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="c"># whole term as a term factor</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">xa0</span> <span class="o">=</span> <span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
            <span class="k">if</span> <span class="n">xa0</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">co</span><span class="o">*</span><span class="n">c</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">xa0</span> <span class="o">+</span> <span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">diff</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">None</span>
            <span class="c"># term-wise</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">sh</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">xa2</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">xa</span> <span class="o">+</span> <span class="n">xa2</span>

        <span class="c"># whole term as a term factor</span>
        <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">xa0</span> <span class="o">=</span> <span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
        <span class="k">if</span> <span class="n">xa0</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">co</span><span class="o">*</span><span class="n">c</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">xa0</span> <span class="o">+</span> <span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">diff</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">None</span>
        <span class="c"># term-wise</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="n">ac</span><span class="p">,</span> <span class="n">at</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">coc</span><span class="p">,</span> <span class="n">cot</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">coc</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">ac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="bp">self</span> <span class="o">-=</span> <span class="n">co</span><span class="o">*</span><span class="n">at</span>
            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cot</span> <span class="o">+</span> <span class="n">xa</span><span class="p">)</span><span class="o">*</span><span class="n">at</span><span class="p">)</span>
        <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">coeffs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.could_extract_minus_sign"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.could_extract_minus_sign">[docs]</a>    <span class="k">def</span> <span class="nf">could_extract_minus_sign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Canonical way to choose an element in the set {e, -e} where</span>
<span class="sd">           e is any expression. If the canonical element is e, we have</span>
<span class="sd">           e.could_extract_minus_sign() == True, else</span>
<span class="sd">           e.could_extract_minus_sign() == False.</span>

<span class="sd">           For any expression, the set ``{e.could_extract_minus_sign(),</span>
<span class="sd">           (-e).could_extract_minus_sign()}`` must be ``{True, False}``.</span>

<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">           &gt;&gt;&gt; (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()</span>
<span class="sd">           True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">negative_self</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span>
        <span class="n">self_has_minus</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">negative_self_has_minus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">negative_self</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self_has_minus</span> <span class="o">!=</span> <span class="n">negative_self_has_minus</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self_has_minus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c"># We choose the one with less arguments with minus signs</span>
                <span class="n">all_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="bp">False</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()])</span>
                <span class="n">positive_args</span> <span class="o">=</span> <span class="n">all_args</span> <span class="o">-</span> <span class="n">negative_args</span>
                <span class="k">if</span> <span class="n">positive_args</span> <span class="o">&gt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="n">positive_args</span> <span class="o">&lt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="c"># We choose the one with an odd number of minus signs</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
                <span class="n">arg_signs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_signs</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">negative_args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="c"># As a last resort, we choose the one with greater value of .sort_key()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">negative_self</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Expr.extract_branch_factor"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.extract_branch_factor">[docs]</a>    <span class="k">def</span> <span class="nf">extract_branch_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_half</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.</span>
<span class="sd">        Return (z, n).</span>

<span class="sd">        &gt;&gt;&gt; from sympy import exp_polar, I, pi</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(I*pi).extract_branch_factor()</span>
<span class="sd">        (exp_polar(I*pi), 0)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(2*I*pi).extract_branch_factor()</span>
<span class="sd">        (1, 1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-pi*I).extract_branch_factor()</span>
<span class="sd">        (exp_polar(I*pi), -1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(3*pi*I + x).extract_branch_factor()</span>
<span class="sd">        (exp_polar(x + I*pi), 1)</span>
<span class="sd">        &gt;&gt;&gt; (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()</span>
<span class="sd">        (y*exp_polar(2*pi*x), -1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-I*pi/2).extract_branch_factor()</span>
<span class="sd">        (exp_polar(-I*pi/2), 0)</span>

<span class="sd">        If allow_half is True, also extract exp_polar(I*pi):</span>

<span class="sd">        &gt;&gt;&gt; exp_polar(I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 1/2)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(2*I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(3*I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 3/2)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, -1/2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">,</span> <span class="n">Add</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">exps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp_polar</span><span class="p">:</span>
                <span class="n">exps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">exp</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">*=</span> <span class="n">arg</span>
        <span class="n">piimult</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">exps</span><span class="p">:</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">exps</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">exps</span> <span class="o">+=</span> <span class="n">exp</span><span class="o">.</span><span class="n">args</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">piimult</span> <span class="o">+=</span> <span class="n">coeff</span>
                    <span class="k">continue</span>
            <span class="n">extras</span> <span class="o">+=</span> <span class="p">[</span><span class="n">exp</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">piimult</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">piimult</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">piimult</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="o">*</span><span class="n">piimult</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="c"># round down to nearest multiple of 2</span>
        <span class="n">branchfact</span> <span class="o">=</span> <span class="n">ceiling</span><span class="p">(</span><span class="n">coeff</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">branchfact</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">-</span> <span class="n">branchfact</span>
        <span class="k">if</span> <span class="n">allow_half</span><span class="p">:</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span>
        <span class="n">newexp</span> <span class="o">=</span> <span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">tail</span><span class="p">))</span> <span class="o">+</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">extras</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newexp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">*=</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">newexp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">n</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Expr.is_polynomial"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_polynomial">[docs]</a>    <span class="k">def</span> <span class="nf">is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if self is a polynomial in syms and False otherwise.</span>

<span class="sd">        This checks if self is an exact polynomial in syms.  This function</span>
<span class="sd">        returns False for expressions that are &quot;polynomials&quot; with symbolic</span>
<span class="sd">        exponents.  Thus, you should be able to apply polynomial algorithms to</span>
<span class="sd">        expressions for which this returns True, and Poly(expr, \*syms) should</span>
<span class="sd">        work if and only if expr.is_polynomial(\*syms) returns True. The</span>
<span class="sd">        polynomial does not have to be in expanded form.  If no symbols are</span>
<span class="sd">        given, all free symbols in the expression will be used.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, polynomial=True).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (2**x + 1).is_polynomial(x)</span>
<span class="sd">        False</span>


<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, nonnegative=True, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_polynomial(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a polynomial to</span>
<span class="sd">        become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, factor, cancel</span>
<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)</span>
<span class="sd">        &gt;&gt;&gt; a.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; b = (y**2 + 2*y + 1)/(y + 1)</span>
<span class="sd">        &gt;&gt;&gt; b.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; cancel(b)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; cancel(b).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        See also .is_rational_function()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c"># constant polynomial</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_polynomial</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Expr.is_rational_function"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_rational_function">[docs]</a>    <span class="k">def</span> <span class="nf">is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether function is a ratio of two polynomials in the given</span>
<span class="sd">        symbols, syms. When syms is not given, all free symbols will be used.</span>
<span class="sd">        The rational function does not have to be in expanded or in any kind of</span>
<span class="sd">        canonical form.</span>

<span class="sd">        This function returns False for expressions that are &quot;rational</span>
<span class="sd">        functions&quot; with symbolic exponents.  Thus, you should be able to call</span>
<span class="sd">        .as_numer_denom() and apply polynomial algorithms to the result for</span>
<span class="sd">        expressions for which this returns True.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, rational_function=True).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; (x/y).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x**2).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x/sin(y)).is_rational_function(y)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_rational_function(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a rational function</span>
<span class="sd">        to become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, factor</span>
<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; a.is_rational_function(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        (y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_rational_function(y)</span>
<span class="sd">        True</span>

<span class="sd">        See also is_algebraic_expr().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c"># constant rational function</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_rational_function</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Expr.is_algebraic_expr"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_algebraic_expr">[docs]</a>    <span class="k">def</span> <span class="nf">is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This tests whether a given expression is algebraic or not, in the</span>
<span class="sd">        given symbols, syms. When syms is not given, all free symbols</span>
<span class="sd">        will be used. The rational function does not have to be in expanded</span>
<span class="sd">        or in any kind of canonical form.</span>

<span class="sd">        This function returns False for expressions that are &quot;algebraic</span>
<span class="sd">        expressions&quot; with symbolic exponents. This is a simple extension to the</span>
<span class="sd">        is_rational_function, including rational exponentiation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, sqrt</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sqrt(1 + x).is_rational_function()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; sqrt(1 + x).is_algebraic_expr()</span>
<span class="sd">        True</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be an algebraic</span>
<span class="sd">        expression to become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, factor</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(sin(x)**2 + 2*sin(x) + 1)/(sin(x) + 1)</span>
<span class="sd">        &gt;&gt;&gt; a.is_algebraic_expr(x)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_algebraic_expr()</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        is_rational_function()</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        - http://en.wikipedia.org/wiki/Algebraic_expression</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c"># constant algebraic expression</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_algebraic_expr</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>

    <span class="c">###################################################################################</span>
    <span class="c">##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################</span>
    <span class="c">###################################################################################</span>
</div>
<div class="viewcode-block" id="Expr.series"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.series">[docs]</a>    <span class="k">def</span> <span class="nf">series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&quot;+&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Series expansion of &quot;self&quot; around ``x = x0`` yielding either terms of</span>
<span class="sd">        the series one by one (the lazy series given when n=None), else</span>
<span class="sd">        all the terms at once when n != None.</span>

<span class="sd">        Note: when n != None, if an O() term is returned then the x in the</span>
<span class="sd">        in it and the entire expression represents x - x0, the displacement</span>
<span class="sd">        from x0. (If there is no O() term then the series was exact and x has</span>
<span class="sd">        it&#39;s normal meaning.) This is currently necessary since sympy&#39;s O()</span>
<span class="sd">        can only represent terms at x0=0. So instead of::</span>

<span class="sd">          cos(x).series(x0=1, n=2) --&gt; (1 - x)*sin(1) + cos(1) + O((x - 1)**2)</span>

<span class="sd">        which graphically looks like this::</span>

<span class="sd">               |</span>
<span class="sd">              .|.         . .</span>
<span class="sd">             . | \      .     .</span>
<span class="sd">            ---+----------------------</span>
<span class="sd">               |   . .          . .</span>
<span class="sd">               |    \</span>
<span class="sd">              x=0</span>

<span class="sd">        the following is returned instead::</span>

<span class="sd">        -x*sin(1) + cos(1) + O(x**2)</span>

<span class="sd">        whose graph is this::</span>

<span class="sd">               \ |</span>
<span class="sd">              . .|        . .</span>
<span class="sd">             .   \      .     .</span>
<span class="sd">            -----+\------------------.</span>
<span class="sd">                 | . .          . .</span>
<span class="sd">                 |  \</span>
<span class="sd">                x=0</span>

<span class="sd">        which is identical to ``cos(x + 1).series(n=2)``.</span>

<span class="sd">        Usage:</span>
<span class="sd">            Returns the series expansion of &quot;self&quot; around the point ``x = x0``</span>
<span class="sd">            with respect to ``x`` up to O(x**n) (default n is 6).</span>

<span class="sd">            If ``x=None`` and ``self`` is univariate, the univariate symbol will</span>
<span class="sd">            be supplied, otherwise an error will be raised.</span>

<span class="sd">            &gt;&gt;&gt; from sympy import cos, exp</span>
<span class="sd">            &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">            &gt;&gt;&gt; cos(x).series()</span>
<span class="sd">            1 - x**2/2 + x**4/24 + O(x**6)</span>
<span class="sd">            &gt;&gt;&gt; cos(x).series(n=4)</span>
<span class="sd">            1 - x**2/2 + O(x**4)</span>
<span class="sd">            &gt;&gt;&gt; e = cos(x + exp(y))</span>
<span class="sd">            &gt;&gt;&gt; e.series(y, n=2)</span>
<span class="sd">            cos(x + 1) - y*sin(x + 1) + O(y**2)</span>
<span class="sd">            &gt;&gt;&gt; e.series(x, n=2)</span>
<span class="sd">            cos(exp(y)) - x*sin(exp(y)) + O(x**2)</span>

<span class="sd">            If ``n=None`` then a generator of the series terms will be returned.</span>

<span class="sd">            &gt;&gt;&gt; term=cos(x).series(n=None)</span>
<span class="sd">            &gt;&gt;&gt; [next(term) for i in range(2)]</span>
<span class="sd">            [1, -x**2/2]</span>

<span class="sd">            For ``dir=+`` (default) the series is calculated from the right and</span>
<span class="sd">            for ``dir=-`` the series from the left. For smooth functions this</span>
<span class="sd">            flag will not alter the results.</span>

<span class="sd">            &gt;&gt;&gt; abs(x).series(dir=&quot;+&quot;)</span>
<span class="sd">            x</span>
<span class="sd">            &gt;&gt;&gt; abs(x).series(dir=&quot;-&quot;)</span>
<span class="sd">            -x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">collect</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;x must be given for multivariate functions.&#39;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="c">## it seems like the following should be doable, but several failures</span>
        <span class="c">## then occur. Is this related to issue 1747 et al See also XPOS below.</span>
        <span class="c">#if x.is_positive is x.is_negative is None:</span>
        <span class="c">#    # replace x with an x that has a positive assumption</span>
        <span class="c">#    xpos = C.Dummy(&#39;x&#39;, positive=True)</span>
        <span class="c">#    rv = self.subs(x, xpos).series(xpos, x0, n, dir)</span>
        <span class="c">#    if n is None:</span>
        <span class="c">#        return (s.subs(xpos, x) for s in rv)</span>
        <span class="c">#    else:</span>
        <span class="c">#        return rv.subs(xpos, x)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s">&#39;+-&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dir must be &#39;+&#39; or &#39;-&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="ow">in</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">]:</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="p">{</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span> <span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span> <span class="s">&#39;-&#39;</span><span class="p">}[</span><span class="n">x0</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
            <span class="c"># don&#39;t include the order term since it will eat the larger terms</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>

        <span class="c"># use rep to shift origin to x0 and change sign (if dir is negative)</span>
        <span class="c"># and undo the process with rep2</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="n">x0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="o">-</span><span class="n">x0</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># lseries...</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">)</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
            <span class="c"># nseries...</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">and</span> <span class="n">x0</span><span class="p">:</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># when O() can handle x0 != 0 this can be removed</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span>

        <span class="c"># from here on it&#39;s x0=0 and dir=&#39;+&#39; handling</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># nseries handling</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">o</span><span class="p">:</span>
                <span class="c"># make sure the requested order is returned</span>
                <span class="n">ngot</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">ngot</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c"># leave o in its current form (e.g. with x*log(x)) so</span>
                    <span class="c"># it eats terms properly, then replace it below</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s1</span> <span class="o">+=</span> <span class="n">o</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">C</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ngot</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">s1</span> <span class="o">+=</span> <span class="n">C</span><span class="o">.</span><span class="n">Order</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ngot</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c"># increase the requested number of terms to get the desired</span>
                    <span class="c"># number keep increasing (up to 9) until the received order</span>
                    <span class="c"># is different than the original order and then predict how</span>
                    <span class="c"># many additional terms are needed</span>
                    <span class="k">for</span> <span class="n">more</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
                        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="n">more</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
                        <span class="n">newn</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">newn</span> <span class="o">!=</span> <span class="n">ngot</span><span class="p">:</span>
                            <span class="n">ndo</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">ngot</span><span class="p">)</span><span class="o">*</span><span class="n">more</span><span class="o">/</span><span class="p">(</span><span class="n">newn</span> <span class="o">-</span> <span class="n">ngot</span><span class="p">)</span>
                            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">ndo</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
                            <span class="k">while</span> <span class="n">s1</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">ndo</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
                                <span class="n">ndo</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Could not calculate </span><span class="si">%s</span><span class="s"> terms for </span><span class="si">%s</span><span class="s">&#39;</span>
                                         <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="bp">self</span><span class="p">))</span>
                    <span class="n">s1</span> <span class="o">+=</span> <span class="n">C</span><span class="o">.</span><span class="n">Order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">==</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">o</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c"># lseries handling</span>
            <span class="k">def</span> <span class="nf">yield_lseries</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return terms of lseries one at a time.&quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">si</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">si</span>
                        <span class="k">continue</span>
                    <span class="c"># yield terms 1 at a time if possible</span>
                    <span class="c"># by increasing order until all the</span>
                    <span class="c"># terms have been returned</span>
                    <span class="n">yielded</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Order</span><span class="p">(</span><span class="n">si</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
                    <span class="n">ndid</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ndo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">do</span> <span class="o">=</span> <span class="p">(</span><span class="n">si</span> <span class="o">-</span> <span class="n">yielded</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                        <span class="n">o</span> <span class="o">*=</span> <span class="n">x</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">do</span> <span class="ow">or</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">do</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">do</span>
                        <span class="k">if</span> <span class="n">ndid</span> <span class="o">==</span> <span class="n">ndo</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">yielded</span> <span class="o">+=</span> <span class="n">do</span>

            <span class="k">return</span> <span class="n">yield_lseries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span><span class="o">.</span><span class="n">_eval_lseries</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Expr.taylor_term"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.taylor_term">[docs]</a>    <span class="k">def</span> <span class="nf">taylor_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">previous_terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;General method for the taylor term.</span>

<span class="sd">        This method is slow, because it differentiates n-times. Subclasses can</span>
<span class="sd">        redefine it to make it faster by using the &quot;previous_terms&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">C</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.lseries"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.lseries">[docs]</a>    <span class="k">def</span> <span class="nf">lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for series yielding an iterator of the terms of the series.</span>

<span class="sd">        Note: an infinite series will yield an infinite iterator. The following,</span>
<span class="sd">        for exaxmple, will never terminate. It will just keep printing terms</span>
<span class="sd">        of the sin(x) series::</span>

<span class="sd">          for term in sin(x).lseries(x):</span>
<span class="sd">              print term</span>

<span class="sd">        The advantage of lseries() over nseries() is that many times you are</span>
<span class="sd">        just interested in the next term in the series (i.e. the first term for</span>
<span class="sd">        example), but you don&#39;t know how many you should ask for in nseries()</span>
<span class="sd">        using the &quot;n&quot; parameter.</span>

<span class="sd">        See also nseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c"># default implementation of lseries is using nseries(), and adaptively</span>
        <span class="c"># increasing the &quot;n&quot;. As you can see, it is not very efficient, because</span>
        <span class="c"># we are calculating the series over and over again. Subclasses should</span>
        <span class="c"># override this method and implement much more efficient yielding of</span>
        <span class="c"># terms.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="k">while</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">e</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">series</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">yield</span> <span class="n">series</span> <span class="o">-</span> <span class="n">e</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">series</span>

<div class="viewcode-block" id="Expr.nseries"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.nseries">[docs]</a>    <span class="k">def</span> <span class="nf">nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper to _eval_nseries if assumptions allow, else to series.</span>

<span class="sd">        If x is given, x0 is 0, dir=&#39;+&#39;, and self has x, then _eval_nseries is</span>
<span class="sd">        called. This calculates &quot;n&quot; terms in the innermost expressions and</span>
<span class="sd">        then builds up the final series just by &quot;cross-multiplying&quot; everything</span>
<span class="sd">        out.</span>

<span class="sd">        Advantage -- it&#39;s fast, because we don&#39;t have to determine how many</span>
<span class="sd">        terms we need to calculate in advance.</span>

<span class="sd">        Disadvantage -- you may end up with less terms than you may have</span>
<span class="sd">        expected, but the O(x**n) term appended will always be correct and</span>
<span class="sd">        so the result, though perhaps shorter, will also be correct.</span>

<span class="sd">        If any of those assumptions is not met, this is treated like a</span>
<span class="sd">        wrapper to series which will try harder to return the correct</span>
<span class="sd">        number of terms.</span>

<span class="sd">        See also lseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">x0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">!=</span> <span class="s">&#39;+&#39;</span><span class="p">:</span>  <span class="c"># {see XPOS above} or (x.is_positive == x.is_negative == None):</span>
            <span class="k">assert</span> <span class="n">logx</span> <span class="ow">is</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return terms of series for self up to O(x**n) at x=0</span>
<span class="sd">        from the positive direction.</span>

<span class="sd">        This is a method that should be overridden in subclasses. Users should</span>
<span class="sd">        never call this method directly (use .nseries() instead), so you don&#39;t</span>
<span class="sd">        have to write docstrings for _eval_nseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                     The _eval_nseries method should be added to</span>
<span class="s">                     </span><span class="si">%s</span><span class="s"> to give terms up to O(x**n) at x=0</span>
<span class="s">                     from the positive direction so it is available when</span>
<span class="s">                     nseries calls it.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
                     <span class="p">)</span>

<div class="viewcode-block" id="Expr.limit"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.limit">[docs]</a>    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute limit x-&gt;xlim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series.limits</span> <span class="kn">import</span> <span class="n">limit</span>
        <span class="k">return</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.compute_leading_term"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.compute_leading_term">[docs]</a>    <span class="k">def</span> <span class="nf">compute_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">skip_abs</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        as_leading_term is only allowed for results of .series()</span>
<span class="sd">        This is a wrapper to compute a series first.</span>
<span class="sd">        If skip_abs is true, the absolute term is assumed to be zero.</span>
<span class="sd">        (This is necessary because sometimes it cannot be simplified</span>
<span class="sd">        to zero without a lot of work, but is still known to be zero.</span>
<span class="sd">        See log._eval_nseries for an example.)</span>
<span class="sd">        If skip_log is true, log(x) is treated as an independent symbol.</span>
<span class="sd">        (This is needed for the gruntz algorithm.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series.gruntz</span> <span class="kn">import</span> <span class="n">calculate_series</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cancel</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">logx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;logx&#39;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">skip_abs</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">skip_abs</span><span class="p">,</span> <span class="n">logx</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_abs</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
    <span class="nd">@cacheit</span>
<div class="viewcode-block" id="Expr.as_leading_term"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_leading_term">[docs]</a>    <span class="k">def</span> <span class="nf">as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leading (nonzero) term of the series expansion of self.</span>

<span class="sd">        The _eval_as_leading_term routines are used to do this, and they must</span>
<span class="sd">        always return a non-zero value.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1 + x + x**2).as_leading_term(x)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (1/x**2 + x + x**2).as_leading_term(x)</span>
<span class="sd">        x**(-2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">powsimp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expecting a Symbol but got </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;as_leading_term(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Expr.as_coeff_exponent"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_exponent">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; ``c*x**e -&gt; c,e`` where x can be any symbolic expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">collect</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
</div>
<div class="viewcode-block" id="Expr.leadterm"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.leadterm">[docs]</a>    <span class="k">def</span> <span class="nf">leadterm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leading term a*x**b as a tuple (a, b).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1+x+x**2).leadterm(x)</span>
<span class="sd">        (1, 0)</span>
<span class="sd">        &gt;&gt;&gt; (1/x**2+x+x**2).leadterm(x)</span>
<span class="sd">        (1, -2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_exponent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                cannot compute leadterm(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">). The coefficient</span>
<span class="s">                should have been free of x but got </span><span class="si">%s</span><span class="s">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span>
</div>
<div class="viewcode-block" id="Expr.as_coeff_Mul"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_Mul">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficiently extract the coefficient of a product. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Expr.as_coeff_Add"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_Add">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficiently extract the coefficient of a summation. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="bp">self</span>

    <span class="c">###################################################################################</span>
    <span class="c">##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################</span>
    <span class="c">###################################################################################</span>
</div>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="n">new_symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">symbols</span><span class="p">))</span>  <span class="c"># e.g. x, 2, y, z</span>
        <span class="n">assumptions</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&quot;evaluate&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="c">###########################################################################</span>
    <span class="c">###################### EXPRESSION EXPANSION METHODS #######################</span>
    <span class="c">###########################################################################</span>

    <span class="c"># Relevant subclasses should override _eval_expand_hint() methods.  See</span>
    <span class="c"># the docstring of expand() for more info.</span>

    <span class="k">def</span> <span class="nf">_eval_expand_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">real</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="o">*</span><span class="n">imag</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_expand_hint</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.</span>

<span class="sd">        Returns ``(expr, hit)``, where expr is the (possibly) expanded</span>
<span class="sd">        ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and</span>
<span class="sd">        ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">__class__</span>
        <span class="c"># XXX: Hack to support non-Basic args</span>
        <span class="c">#              |</span>
        <span class="c">#              V</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s">&#39;args&#39;</span><span class="p">,</span> <span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">sargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">arg</span><span class="p">,</span> <span class="n">arghit</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="n">hit</span> <span class="o">|=</span> <span class="n">arghit</span>
                <span class="n">sargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">sargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">):</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">)(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newexpr</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hit</span><span class="p">)</span>

    <span class="nd">@cacheit</span>
<div class="viewcode-block" id="Expr.expand"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">power_base</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">mul</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand an expression using hints.</span>

<span class="sd">        See the docstring of the expand() function in sympy.core.function for</span>
<span class="sd">        more information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">fraction</span>

        <span class="n">hints</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">power_base</span><span class="o">=</span><span class="n">power_base</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="n">power_exp</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="n">mul</span><span class="p">,</span>
           <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="n">multinomial</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="n">basic</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;frac&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>
        <span class="k">elif</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;denom&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;numer&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span><span class="o">/</span><span class="n">d</span>

        <span class="c"># Although the hints are sorted here, an earlier hint may get applied</span>
        <span class="c"># at a given node in the expression tree before another because of how</span>
        <span class="c"># the hints are applied.  e.g. expand(log(x*(y + z))) -&gt; log(x*y +</span>
        <span class="c"># x*z) because while applying log at the top level, log and mul are</span>
        <span class="c"># applied at the deeper level in the tree so that when the log at the</span>
        <span class="c"># upper level gets applied, the mul has already been applied at the</span>
        <span class="c"># lower level.</span>

        <span class="c"># Additionally, because hints are only applied once, the expression</span>
        <span class="c"># may not be expanded all the way.   For example, if mul is applied</span>
        <span class="c"># before multinomial, x*(x + 1)**2 won&#39;t be expanded all the way.  For</span>
        <span class="c"># now, we just use a special case to make multinomial run before mul,</span>
        <span class="c"># so that at least polynomials will be expanded all the way.  In the</span>
        <span class="c"># future, smarter heuristics should be applied.</span>
        <span class="c"># TODO: Smarter heuristics</span>

        <span class="k">def</span> <span class="nf">_expand_hint_key</span><span class="p">(</span><span class="n">hint</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Make multinomial come before mul&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">hint</span> <span class="o">==</span> <span class="s">&#39;mul&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;mulz&#39;</span>
            <span class="k">return</span> <span class="n">hint</span>

        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hints</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">_expand_hint_key</span><span class="p">):</span>
            <span class="n">use_hint</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">use_hint</span><span class="p">:</span>
                <span class="n">hint</span> <span class="o">=</span> <span class="s">&#39;_eval_expand_&#39;</span> <span class="o">+</span> <span class="n">hint</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">was</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;multinomial&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s">&#39;_eval_expand_multinomial&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;mul&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s">&#39;_eval_expand_mul&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;log&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s">&#39;_eval_expand_log&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">modulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">modulus</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">modulus</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">modulus</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">or</span> <span class="n">modulus</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;modulus must be a positive integer, got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">modulus</span><span class="p">)</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

                <span class="n">coeff</span> <span class="o">%=</span> <span class="n">modulus</span>

                <span class="k">if</span> <span class="n">coeff</span><span class="p">:</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">tail</span><span class="p">)</span>

            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="c">###########################################################################</span>
    <span class="c">################### GLOBAL ACTION VERB WRAPPER METHODS ####################</span>
    <span class="c">###########################################################################</span>
</div>
<div class="viewcode-block" id="Expr.integrate"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the integrate function in sympy.integrals&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.integrals</span> <span class="kn">import</span> <span class="n">integrate</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.simplify"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the simplify function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">simplify</span>
        <span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">count_ops</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="n">measure</span> <span class="ow">or</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.nsimplify"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.nsimplify">[docs]</a>    <span class="k">def</span> <span class="nf">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="p">[],</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the nsimplify function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">nsimplify</span>
        <span class="k">return</span> <span class="n">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">full</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.separate"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.separate">[docs]</a>    <span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the separate function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">separate</span>
        <span class="k">return</span> <span class="n">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.collect"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.collect">[docs]</a>    <span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the collect function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">collect</span>
        <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.together"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.together">[docs]</a>    <span class="k">def</span> <span class="nf">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the together function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">together</span>
        <span class="k">return</span> <span class="n">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.apart"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.apart">[docs]</a>    <span class="k">def</span> <span class="nf">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the apart function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">apart</span>
        <span class="k">return</span> <span class="n">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.ratsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.ratsimp">[docs]</a>    <span class="k">def</span> <span class="nf">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the ratsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">ratsimp</span>
        <span class="k">return</span> <span class="n">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.trigsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.trigsimp">[docs]</a>    <span class="k">def</span> <span class="nf">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the trigsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">trigsimp</span>
        <span class="k">return</span> <span class="n">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.radsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.radsimp">[docs]</a>    <span class="k">def</span> <span class="nf">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the radsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">radsimp</span>
        <span class="k">return</span> <span class="n">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.powsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.powsimp">[docs]</a>    <span class="k">def</span> <span class="nf">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the powsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">powsimp</span>
        <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">,</span> <span class="n">combine</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.combsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.combsimp">[docs]</a>    <span class="k">def</span> <span class="nf">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the combsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">combsimp</span>
        <span class="k">return</span> <span class="n">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.factor"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.factor">[docs]</a>    <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the factor() function in sympy.polys.polytools&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.refine"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.refine">[docs]</a>    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the refine function in sympy.assumptions&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.assumptions</span> <span class="kn">import</span> <span class="n">refine</span>
        <span class="k">return</span> <span class="n">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.cancel"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the cancel function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">cancel</span>
        <span class="k">return</span> <span class="n">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.invert"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.invert">[docs]</a>    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the invert function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">invert</span>
        <span class="k">return</span> <span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.round"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.round">[docs]</a>    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return x rounded to the given decimal place.</span>

<span class="sd">        If a complex number would results, apply round to the real</span>
<span class="sd">        and imaginary components of the number.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy import pi, E, I, S, Add, Mul, Number</span>
<span class="sd">        &gt;&gt;&gt; S(10.5).round()</span>
<span class="sd">        11.</span>
<span class="sd">        &gt;&gt;&gt; pi.round()</span>
<span class="sd">        3.</span>
<span class="sd">        &gt;&gt;&gt; pi.round(2)</span>
<span class="sd">        3.14</span>
<span class="sd">        &gt;&gt;&gt; (2*pi + E*I).round()</span>
<span class="sd">        6. + 3.*I</span>

<span class="sd">        The round method has a chopping effect:</span>

<span class="sd">        &gt;&gt;&gt; (2*pi + I/10).round()</span>
<span class="sd">        6.</span>
<span class="sd">        &gt;&gt;&gt; (pi/10 + 2*I).round()</span>
<span class="sd">        2.*I</span>
<span class="sd">        &gt;&gt;&gt; (pi/10 + E*I).round(2)</span>
<span class="sd">        0.31 + 2.72*I</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Do not confuse the Python builtin function, round, with the</span>
<span class="sd">        SymPy method of the same name. The former always returns a float</span>
<span class="sd">        (or raises an error if applied to a complex value) while the</span>
<span class="sd">        latter returns either a Number or a complex number:</span>

<span class="sd">        &gt;&gt;&gt; isinstance(round(S(123), -2), Number)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; isinstance(S(123).round(-2), Number)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; isinstance((3*I).round(), Mul)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; isinstance((1 + 3*I).round(), Add)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is not a number&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">i</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="o">*</span><span class="n">r</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">precs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">_prec</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">)]</span>
        <span class="n">dps</span> <span class="o">=</span> <span class="n">prec_to_dps</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">precs</span><span class="p">))</span> <span class="k">if</span> <span class="n">precs</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="n">_mag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">allow</span> <span class="o">=</span> <span class="n">digits_needed</span> <span class="o">=</span> <span class="n">mag_first_dig</span> <span class="o">+</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">allow</span> <span class="o">&gt;</span> <span class="n">dps</span><span class="p">:</span>
            <span class="n">allow</span> <span class="o">=</span> <span class="n">dps</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c"># magnitude needed to bring digit p to units place</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mag</span><span class="p">)</span>  <span class="c"># add the half for rounding</span>
        <span class="n">i10</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">mag</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">n</span><span class="p">((</span><span class="n">dps</span> <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">digits_needed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">i10</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">mag</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">/=</span> <span class="n">mag</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rv</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
            <span class="c"># use str or else it won&#39;t be a float</span>
            <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rv</span><span class="p">),</span> <span class="n">digits_needed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">allow</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="AtomicExpr"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.AtomicExpr">[docs]</a><span class="k">class</span> <span class="nc">AtomicExpr</span><span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parent class for object which are both atoms and Exprs.</span>

<span class="sd">    For example: Symbol, Number, Rational, Integer, ...</span>
<span class="sd">    But not: Add, Mul, Pow, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_Atom</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<span class="k">def</span> <span class="nf">_mag</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return integer ``i`` such that .1 &lt;= x/10**i &lt; 1</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    &gt;&gt;&gt; from sympy.core.expr import _mag</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Float</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(.1))</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(.01))</span>
<span class="sd">    -1</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(1234))</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log10</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">log</span>
    <span class="n">xpos</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">n</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xpos</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">xpos</span><span class="p">)))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">mpf_log</span><span class="p">(</span><span class="n">xpos</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="mi">53</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
    <span class="c"># check that we aren&#39;t off by 1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xpos</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">mag_first_dig</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">xpos</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">mag_first_dig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>
        <span class="n">mag_first_dig</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">mag_first_dig</span>

<span class="kn">from</span> <span class="nn">.mul</span> <span class="kn">import</span> <span class="n">Mul</span>
<span class="kn">from</span> <span class="nn">.add</span> <span class="kn">import</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">.power</span> <span class="kn">import</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">.function</span> <span class="kn">import</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">expand_mul</span>
<span class="kn">from</span> <span class="nn">.mod</span> <span class="kn">import</span> <span class="n">Mod</span>
<span class="kn">from</span> <span class="nn">.exprtools</span> <span class="kn">import</span> <span class="n">factor_terms</span>
<span class="kn">from</span> <span class="nn">.numbers</span> <span class="kn">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Rational</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Aug 04, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>