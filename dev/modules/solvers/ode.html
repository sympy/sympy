

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ODE &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="../index.html" />
    <link rel="next" title="PDE" href="pde.html" />
    <link rel="prev" title="Stats" href="../stats.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pde.html" title="PDE"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ode">
<span id="ode-docs"></span><h1>ODE<a class="headerlink" href="#ode" title="Permalink to this headline">¶</a></h1>
<div class="section" id="user-functions">
<h2>User Functions<a class="headerlink" href="#user-functions" title="Permalink to this headline">¶</a></h2>
<p>These are functions that are imported into the global namespace with <tt class="docutils literal"><span class="pre">from</span>
<span class="pre">sympy</span> <span class="pre">import</span> <span class="pre">*</span></tt>.  These functions (unlike <a class="reference internal" href="#hint-functions">Hint Functions</a>, below) are
intended for use by ordinary users of SymPy.</p>
<div class="section" id="dsolve">
<h3><tt class="xref py py-func docutils literal"><span class="pre">dsolve()</span></tt><a class="headerlink" href="#dsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.dsolve">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">dsolve</tt><big>(</big><em>eq</em>, <em>func=None</em>, <em>hint='default'</em>, <em>simplify=True</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#dsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.dsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves any (supported) kind of ordinary differential equation.</p>
<p><strong>Usage</strong></p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span> <span class="pre">hint)</span></tt> -&gt; Solve ordinary differential equation
<tt class="docutils literal"><span class="pre">eq</span></tt> for function <tt class="docutils literal"><span class="pre">f(x)</span></tt>, using method <tt class="docutils literal"><span class="pre">hint</span></tt>.</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">eq</span></tt> can be any supported ordinary differential equation (see the</dt>
<dd><a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><tt class="xref py py-mod docutils literal"><span class="pre">ode</span></tt></a> docstring for supported methods).
This can either be an <a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><tt class="xref py py-class docutils literal"><span class="pre">Equality</span></tt></a>,
or an expression, which is assumed to be equal to <tt class="docutils literal"><span class="pre">0</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">f(x)</span></tt> is a function of one variable whose derivatives in that</dt>
<dd>variable make up the ordinary differential equation <tt class="docutils literal"><span class="pre">eq</span></tt>.  In
many cases it is not necessary to provide this; it will be
autodetected (and an error raised if it couldn&#8217;t be detected).</dd>
<dt><tt class="docutils literal"><span class="pre">hint</span></tt> is the solving method that you want dsolve to use.  Use</dt>
<dd><tt class="docutils literal"><span class="pre">classify_ode(eq,</span> <span class="pre">f(x))</span></tt> to get all of the possible hints for an
ODE.  The default hint, <tt class="docutils literal"><span class="pre">default</span></tt>, will use whatever hint is
returned first by <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>.  See
Hints below for more options that you can use for hint.</dd>
<dt><tt class="docutils literal"><span class="pre">simplify</span></tt> enables simplification by</dt>
<dd><a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a>.  See its docstring for more
information.  Turn this off, for example, to disable solving of
solutions for <tt class="docutils literal"><span class="pre">func</span></tt> or simplification of arbitrary constants.
It will still integrate with this hint. Note that the solution may
contain more arbitrary constants than the order of the ODE with
this option enabled.</dd>
</dl>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>Aside from the various solving methods, there are also some meta-hints
that you can pass to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">default</span></tt>:</dt>
<dd>This uses whatever hint is returned first by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>. This is the
default argument to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">all</span></tt>:</dt>
<dd><p class="first">To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> apply all
relevant classification hints, use <tt class="docutils literal"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&quot;all&quot;)</span></tt>.  This will return a dictionary of
<tt class="docutils literal"><span class="pre">hint:solution</span></tt> terms.  If a hint causes dsolve to raise the
<tt class="docutils literal"><span class="pre">NotImplementedError</span></tt>, value of that hint&#8217;s key will be the
exception object raised.  The dictionary will also include
some special keys:</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">order</span></tt>: The order of the ODE.  See also
<a class="reference internal" href="solvers.html#sympy.solvers.deutils.ode_order" title="sympy.solvers.deutils.ode_order"><tt class="xref py py-meth docutils literal"><span class="pre">ode_order()</span></tt></a> in
<tt class="docutils literal"><span class="pre">deutils.py</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">best</span></tt>: The simplest hint; what would be returned by
<tt class="docutils literal"><span class="pre">best</span></tt> below.</li>
<li><tt class="docutils literal"><span class="pre">best_hint</span></tt>: The hint that would produce the solution
given by <tt class="docutils literal"><span class="pre">best</span></tt>.  If more than one hint produces the best
solution, the first one in the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> is chosen.</li>
<li><tt class="docutils literal"><span class="pre">default</span></tt>: The solution that would be returned by default.
This is the one produced by the hint that appears first in
the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>.</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">all_Integral</span></tt>:</dt>
<dd>This is the same as <tt class="docutils literal"><span class="pre">all</span></tt>, except if a hint also has a
corresponding <tt class="docutils literal"><span class="pre">_Integral</span></tt> hint, it only returns the
<tt class="docutils literal"><span class="pre">_Integral</span></tt> hint.  This is useful if <tt class="docutils literal"><span class="pre">all</span></tt> causes
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> to hang because of a
difficult or impossible integral.  This meta-hint will also be
much faster than <tt class="docutils literal"><span class="pre">all</span></tt>, because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt></a> is an expensive
routine.</dd>
<dt><tt class="docutils literal"><span class="pre">best</span></tt>:</dt>
<dd>To have <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> try all methods
and return the simplest one.  This takes into account whether
the solution is solvable in the function, whether it contains
any Integral classes (i.e.  unevaluatable integrals), and
which one is the shortest in size.</dd>
</dl>
<p>See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> docstring for
more info on hints, and the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><tt class="xref py py-mod docutils literal"><span class="pre">ode</span></tt></a> docstring for
a list of all supported hints.</p>
</div></blockquote>
<p><strong>Tips</strong></p>
<blockquote>
<div><ul>
<li><p class="first">You can declare the derivative of an unknown function this way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span> <span class="c"># x is the independent variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="c"># f is a function of x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># f_ will be the derivative of f with respect to x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">See <tt class="docutils literal"><span class="pre">test_ode.py</span></tt> for many tests, which serves also as a set of
examples for how to use <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.</p>
</li>
<li><p class="first"><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> always returns an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><tt class="xref py py-class docutils literal"><span class="pre">Equality</span></tt></a> class (except for the
case when the hint is <tt class="docutils literal"><span class="pre">all</span></tt> or <tt class="docutils literal"><span class="pre">all_Integral</span></tt>).  If possible, it
solves the solution explicitly for the function being solved for.
Otherwise, it returns an implicit solution.</p>
</li>
<li><p class="first">Arbitrary constants are symbols named <tt class="docutils literal"><span class="pre">C1</span></tt>, <tt class="docutils literal"><span class="pre">C2</span></tt>, and so on.</p>
</li>
<li><p class="first">Because all solutions should be mathematically equivalent, some
hints may return the exact same result for an ODE. Often, though,
two different hints will return the same solution formatted
differently.  The two should be equivalent. Also note that sometimes
the values of the arbitrary constants in two different solutions may
not be the same, because one constant may have &#8220;absorbed&#8221; other
constants into it.</p>
</li>
<li><p class="first">Do <tt class="docutils literal"><span class="pre">help(ode.ode_&lt;hintname&gt;)</span></tt> to get help more information on a
specific hint, where <tt class="docutils literal"><span class="pre">&lt;hintname&gt;</span></tt> is the name of a hint without
<tt class="docutils literal"><span class="pre">_Integral</span></tt>.</p>
</li>
</ul>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">f(x) == C1*sin(3*x) + C2*cos(3*x)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_reduced&#39;</span><span class="p">)</span>
<span class="go">f(x) == C1/(C2*x - 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">[f(x) == -acos(C1/cos(x)) + 2*pi, f(x) == acos(C1/cos(x))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">[f(x) == -acos(-sqrt(C1/cos(x)**2)) + 2*pi, f(x) == -acos(sqrt(C1/cos(x)**2)) + 2*pi,</span>
<span class="go">f(x) == acos(-sqrt(C1/cos(x)**2)), f(x) == acos(sqrt(C1/cos(x)**2))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;best&#39;</span><span class="p">)</span>
<span class="go">f(x) == C1/(C2*x - 1)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="classify-ode">
<h3><tt class="xref py py-func docutils literal"><span class="pre">classify_ode()</span></tt><a class="headerlink" href="#classify-ode" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.classify_ode">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">classify_ode</tt><big>(</big><em>eq</em>, <em>func=None</em>, <em>dict=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#classify_ode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.classify_ode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of possible <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>
classifications for an ODE.</p>
<p>The tuple is ordered so that first item is the classification that
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> uses to solve the ODE by default.  In
general, classifications at the near the beginning of the list will
produce better solutions faster than those near the end, thought there are
always exceptions.  To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> use a
different classification, use <tt class="docutils literal"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&lt;classification&gt;)</span></tt>.  See also the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> docstring for different meta-hints
you can use.</p>
<p>If <tt class="docutils literal"><span class="pre">dict</span></tt> is true, <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> will
return a dictionary of <tt class="docutils literal"><span class="pre">hint:match</span></tt> expression terms. This is intended
for internal use by <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.  Note that
because dictionaries are ordered arbitrarily, this will most likely not be
in the same order as the tuple.</p>
<p>You can get help on different hints by executing
<tt class="docutils literal"><span class="pre">help(ode.ode_hintname)</span></tt>, where <tt class="docutils literal"><span class="pre">hintname</span></tt> is the name of the hint
without <tt class="docutils literal"><span class="pre">_Integral</span></tt>.</p>
<p>See <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><tt class="xref py py-data docutils literal"><span class="pre">allhints</span></tt></a> or the
<a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><tt class="xref py py-mod docutils literal"><span class="pre">ode</span></tt></a> docstring for a list of all supported hints
that can be returned from <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>.</p>
<p class="rubric">Notes</p>
<p>These are remarks on hint names.</p>
<p><tt class="docutils literal"><span class="pre">_Integral</span></tt></p>
<blockquote>
<div><p>If a classification has <tt class="docutils literal"><span class="pre">_Integral</span></tt> at the end, it will return the
expression with an unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><tt class="xref py py-class docutils literal"><span class="pre">Integral</span></tt></a>
class in it.  Note that a hint may do this anyway if
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt></a> cannot do the integral,
though just using an <tt class="docutils literal"><span class="pre">_Integral</span></tt> will do so much faster.  Indeed, an
<tt class="docutils literal"><span class="pre">_Integral</span></tt> hint will always be faster than its corresponding hint
without <tt class="docutils literal"><span class="pre">_Integral</span></tt> because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt></a> is an expensive routine.
If <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> hangs, it is probably because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt></a> is hanging on a tough or
impossible integral.  Try using an <tt class="docutils literal"><span class="pre">_Integral</span></tt> hint or
<tt class="docutils literal"><span class="pre">all_Integral</span></tt> to get it return something.</p>
<p>Note that some hints do not have <tt class="docutils literal"><span class="pre">_Integral</span></tt> counterparts.  This is
because <tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt> is not used in solving
the ODE for those method. For example, <span class="math">\(n\)</span>th order linear homogeneous
ODEs with constant coefficients do not require integration to solve,
so there is no <tt class="docutils literal"><span class="pre">nth_linear_homogeneous_constant_coeff_Integrate</span></tt>
hint. You can easily evaluate any unevaluated
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><tt class="xref py py-class docutils literal"><span class="pre">Integral</span></tt></a>s in an expression by doing
<tt class="docutils literal"><span class="pre">expr.doit()</span></tt>.</p>
</div></blockquote>
<p>Ordinals</p>
<blockquote>
<div>Some hints contain an ordinal such as <tt class="docutils literal"><span class="pre">1st_linear</span></tt>.  This is to help
differentiate them from other hints, as well as from other methods
that may not be implemented yet. If a hint has <tt class="docutils literal"><span class="pre">nth</span></tt> in it, such as
the <tt class="docutils literal"><span class="pre">nth_linear</span></tt> hints, this means that the method used to applies
to ODEs of any order.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">indep</span></tt> and <tt class="docutils literal"><span class="pre">dep</span></tt></p>
<blockquote>
<div>Some hints contain the words <tt class="docutils literal"><span class="pre">indep</span></tt> or <tt class="docutils literal"><span class="pre">dep</span></tt>.  These reference
the independent variable and the dependent function, respectively. For
example, if an ODE is in terms of <span class="math">\(f(x)\)</span>, then <tt class="docutils literal"><span class="pre">indep</span></tt> will refer to
<span class="math">\(x\)</span> and <tt class="docutils literal"><span class="pre">dep</span></tt> will refer to <span class="math">\(f\)</span>.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">subs</span></tt></p>
<blockquote>
<div>If a hints has the word <tt class="docutils literal"><span class="pre">subs</span></tt> in it, it means the the ODE is solved
by substituting the expression given after the word <tt class="docutils literal"><span class="pre">subs</span></tt> for a
single dummy variable.  This is usually in terms of <tt class="docutils literal"><span class="pre">indep</span></tt> and
<tt class="docutils literal"><span class="pre">dep</span></tt> as above.  The substituted expression will be written only in
characters allowed for names of Python objects, meaning operators will
be spelled out.  For example, <tt class="docutils literal"><span class="pre">indep</span></tt>/<tt class="docutils literal"><span class="pre">dep</span></tt> will be written as
<tt class="docutils literal"><span class="pre">indep_div_dep</span></tt>.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">coeff</span></tt></p>
<blockquote>
<div>The word <tt class="docutils literal"><span class="pre">coeff</span></tt> in a hint refers to the coefficients of something
in the ODE, usually of the derivative terms.  See the docstring for
the individual methods for more info (<tt class="docutils literal"><span class="pre">help(ode)</span></tt>).  This is
contrast to <tt class="docutils literal"><span class="pre">coefficients</span></tt>, as in <tt class="docutils literal"><span class="pre">undetermined_coefficients</span></tt>,
which refers to the common name of a method.</div></blockquote>
<p><tt class="docutils literal"><span class="pre">_best</span></tt></p>
<blockquote>
<div>Methods that have more than one fundamental way to solve will have a
hint for each sub-method and a <tt class="docutils literal"><span class="pre">_best</span></tt> meta-classification. This
will evaluate all hints and return the best, using the same
considerations as the normal <tt class="docutils literal"><span class="pre">best</span></tt> meta-hint.</div></blockquote>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">classify_ode</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(&#39;separable&#39;, &#39;1st_linear&#39;, &#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_homogeneous&#39;, &#39;separable_Integral&#39;,</span>
<span class="go">&#39;1st_linear_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="checkodesol">
<h3><tt class="xref py py-func docutils literal"><span class="pre">checkodesol()</span></tt><a class="headerlink" href="#checkodesol" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.checkodesol">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">checkodesol</tt><big>(</big><em>ode</em>, <em>sol</em>, <em>func=None</em>, <em>order='auto'</em>, <em>solve_for_func=True</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#checkodesol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.checkodesol" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes <tt class="docutils literal"><span class="pre">sol</span></tt> into <tt class="docutils literal"><span class="pre">ode</span></tt> and checks that the result is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>This only works when <tt class="docutils literal"><span class="pre">func</span></tt> is one function, like <span class="math">\(f(x)\)</span>.  <tt class="docutils literal"><span class="pre">sol</span></tt> can
be a single solution or a list of solutions.  Each solution may be an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><tt class="xref py py-class docutils literal"><span class="pre">Equality</span></tt></a> that the solution satisfies,
e.g. <tt class="docutils literal"><span class="pre">Eq(f(x),</span> <span class="pre">C1),</span> <span class="pre">Eq(f(x)</span> <span class="pre">+</span> <span class="pre">C1,</span> <span class="pre">0)</span></tt>; or simply an
<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><tt class="xref py py-class docutils literal"><span class="pre">Expr</span></tt></a>, e.g. <tt class="docutils literal"><span class="pre">f(x)</span> <span class="pre">-</span> <span class="pre">C1</span></tt>. In most cases it
will not be necessary to explicitly identify the function, but if the
function cannot be inferred from the original equation it can be supplied
through the <tt class="docutils literal"><span class="pre">func</span></tt> argument.</p>
<p>If a sequence of solutions is passed, the same sort of container will be
used to return the result for each solution.</p>
<p>It tries the following methods, in order, until it finds zero equivalence:</p>
<ol class="arabic simple">
<li>Substitute the solution for <span class="math">\(f\)</span> in the original equation.  This only
works if <tt class="docutils literal"><span class="pre">ode</span></tt> is solved for <span class="math">\(f\)</span>.  It will attempt to solve it first
unless <tt class="docutils literal"><span class="pre">solve_for_func</span> <span class="pre">==</span> <span class="pre">False</span></tt>.</li>
<li>Take <span class="math">\(n\)</span> derivatives of the solution, where <span class="math">\(n\)</span> is the order of
<tt class="docutils literal"><span class="pre">ode</span></tt>, and check to see if that is equal to the solution.  This only
works on exact ODEs.</li>
<li>Take the 1st, 2nd, ..., <span class="math">\(n\)</span>th derivatives of the solution, each time
solving for the derivative of <span class="math">\(f\)</span> of that order (this will always be
possible because <span class="math">\(f\)</span> is a linear operator). Then back substitute each
derivative into <tt class="docutils literal"><span class="pre">ode</span></tt> in reverse order.</li>
</ol>
<p>This function returns a tuple.  The first item in the tuple is <tt class="docutils literal"><span class="pre">True</span></tt> if
the substitution results in <tt class="docutils literal"><span class="pre">0</span></tt>, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise. The second
item in the tuple is what the substitution results in.  It should always
be <tt class="docutils literal"><span class="pre">0</span></tt> if the first item is <tt class="docutils literal"><span class="pre">True</span></tt>. Note that sometimes this function
will <tt class="docutils literal"><span class="pre">False</span></tt>, but with an expression that is identically equal to <tt class="docutils literal"><span class="pre">0</span></tt>,
instead of returning <tt class="docutils literal"><span class="pre">True</span></tt>.  This is because
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.simplify" title="sympy.simplify.simplify.simplify"><tt class="xref py py-meth docutils literal"><span class="pre">simplify()</span></tt></a> cannot reduce the expression
to <tt class="docutils literal"><span class="pre">0</span></tt>.  If an expression returned by this function vanishes
identically, then <tt class="docutils literal"><span class="pre">sol</span></tt> really is a solution to <tt class="docutils literal"><span class="pre">ode</span></tt>.</p>
<p>If this function seems to hang, it is probably because of a hard
simplification.</p>
<p>To use this function to test, test the first item of the tuple.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">checkodesol</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">(True, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, 2)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="homogeneous-order">
<h3><tt class="xref py py-func docutils literal"><span class="pre">homogeneous_order()</span></tt><a class="headerlink" href="#homogeneous-order" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.homogeneous_order">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">homogeneous_order</tt><big>(</big><em>eq</em>, <em>*symbols</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#homogeneous_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.homogeneous_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order <span class="math">\(n\)</span> if <span class="math">\(g\)</span> is homogeneous and <tt class="docutils literal"><span class="pre">None</span></tt> if it is not
homogeneous.</p>
<p>Determines if a function is homogeneous and if so of what order.  A
function <span class="math">\(f(x, y, \cdots)\)</span> is homogeneous of order <span class="math">\(n\)</span> if <span class="math">\(f(t x, t y,
\cdots) = t^n f(x, y, \cdots)\)</span>.</p>
<p>If the function is of two variables, <span class="math">\(F(x, y)\)</span>, then <span class="math">\(f\)</span> being homogeneous
of any order is equivalent to being able to rewrite <span class="math">\(F(x, y)\)</span> as <span class="math">\(G(x/y)\)</span>
or <span class="math">\(H(y/x)\)</span>.  This fact is used to solve 1st order ordinary differential
equations whose coefficients are homogeneous of the same order (see the
docstrings of
<tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></tt>).</p>
<p>Symbols can be functions, but every argument of the function must be a
symbol, and the arguments of the function that appear in the expression
must match those given in the list of symbols.  If a declared function
appears with different arguments than given in the list of symbols,
<tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">homogeneous_order</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="infinitesimals">
<h3><tt class="xref py py-func docutils literal"><span class="pre">infinitesimals()</span></tt><a class="headerlink" href="#infinitesimals" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.infinitesimals">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">infinitesimals</tt><big>(</big><em>eq</em>, <em>func=None</em>, <em>order=None</em>, <em>hint='default'</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#infinitesimals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.infinitesimals" title="Permalink to this definition">¶</a></dt>
<dd><p>The infinitesimal functions of an ordinary differential equation, <span class="math">\(\xi(x,y)\)</span>
and <span class="math">\(\eta(x,y)\)</span>, are the infinitesimals of the Lie group of point transformations
for which the differential equation is invariant. So, the ODE <span class="math">\(y'=f(x,y)\)</span>
would admit a Lie group <span class="math">\(x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)\)</span>,
<span class="math">\(y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)\)</span> such that <span class="math">\((y^*)'=f(x^*, y^*)\)</span>.
A change of coordinates, to <span class="math">\(r(x,y)\)</span> and <span class="math">\(s(x,y)\)</span>, can be performed so this Lie group
becomes the translation group, <span class="math">\(r^*=r\)</span> and <span class="math">\(s^*=s+\varepsilon\)</span>.
They are tangents to the coordinate curves of the new system.</p>
<p>Consider the transformation <span class="math">\((x, y) \to (X, Y)\)</span> such that the
differential equation remains invariant. <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span> are the tangents to
the transformed coordinates <span class="math">\(X\)</span> and <span class="math">\(Y\)</span>, at <span class="math">\(\varepsilon=0\)</span>.</p>
<div class="math">
\[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \xi,
\left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \eta,\]</div>
<p>The infinitesimals can be found by solving the following PDE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;xi&#39;</span><span class="p">,</span> <span class="s">&#39;eta&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c"># dy/dx = h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">h</span>
<span class="gp">... </span><span class="o">-</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">/d               d           \                     d              2       d</span>
<span class="go">|--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(x</span>
<span class="go">\dy              dx          /                     dy                     dy</span>

<span class="go">                    d             d</span>
<span class="go">i(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0</span>
<span class="go">                    dx            dx</span>
</pre></div>
</div>
<p>Solving the above mentioned PDE is not trivial, and can be solved only by
making intelligent assumptions for <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span> (heuristics). Once an
infinitesimal is found, the attempt to find more heuristics stops. This is done to
optimise the speed of solving the differential equation. If a list of all the
infinitesimals is needed, <tt class="docutils literal"><span class="pre">hint</span></tt> should be flagged as <tt class="docutils literal"><span class="pre">all</span></tt>, which gives
the complete list of infinitesimals. If the infinitesimals for a particular
heuristic needs to be found, it can be passed as a flag to <tt class="docutils literal"><span class="pre">hint</span></tt>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">infinitesimals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinitesimals</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0}]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="checkinfsol">
<h3><tt class="xref py py-func docutils literal"><span class="pre">checkinfsol()</span></tt><a class="headerlink" href="#checkinfsol" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.checkinfsol">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">checkinfsol</tt><big>(</big><em>eq</em>, <em>infinitesimals</em>, <em>func=None</em>, <em>order=None</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#checkinfsol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.checkinfsol" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check if the given infinitesimals are the
actual infinitesimals of the given first order differential equation.
This method is specific to the Lie Group Solver of ODEs.</p>
<p>As of now, it simply checks, by substituting the infinitesimals in the
partial differential equation.</p>
<div class="math">
\[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x}\right)*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]</div>
<p>where <span class="math">\(\eta\)</span>, and <span class="math">\(\xi\)</span> are the infinitesimals and <span class="math">\(h(x,y) = \frac{dy}{dx}\)</span></p>
<p>The infinitesimals should be given in the form of a list of dicts
<tt class="docutils literal"><span class="pre">[{xi(x,</span> <span class="pre">y):</span> <span class="pre">inf,</span> <span class="pre">eta(x,</span> <span class="pre">y):</span> <span class="pre">inf}]</span></tt>, corresponding to the
output of the function infinitesimals. It returns a list
of values of the form <tt class="docutils literal"><span class="pre">[(True/False,</span> <span class="pre">sol)]</span></tt> where <tt class="docutils literal"><span class="pre">sol</span></tt> is the value
obtained after substituting the infinitesimals in the PDE. If it
is <tt class="docutils literal"><span class="pre">True</span></tt>, then <tt class="docutils literal"><span class="pre">sol</span></tt> would be 0.</p>
</dd></dl>

</div>
</div>
<div class="section" id="hint-functions">
<h2>Hint Functions<a class="headerlink" href="#hint-functions" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> and others.  Unlike <a class="reference internal" href="#user-functions">User Functions</a>,
above, these are not intended for every-day use by ordinary SymPy users.
Instead, functions such as <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> should be used.
Nonetheless, these functions contain useful information in their docstrings on
the various ODE solving methods. For this reason, they are documented here.</p>
<div class="section" id="allhints">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">allhints</span></tt><a class="headerlink" href="#allhints" title="Permalink to this headline">¶</a></h3>
<dl class="data">
<dt id="sympy.solvers.ode.allhints">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">allhints</tt><em class="property"> = ('separable', '1st_exact', '1st_linear', 'Bernoulli', 'Riccati_special_minus2', '1st_homogeneous_coeff_best', '1st_homogeneous_coeff_subs_indep_div_dep', '1st_homogeneous_coeff_subs_dep_div_indep', 'almost_linear', 'linear_coefficients', 'separable_reduced', 'nth_linear_constant_coeff_homogeneous', 'nth_linear_euler_eq_homogeneous', 'nth_linear_constant_coeff_undetermined_coefficients', 'nth_linear_constant_coeff_variation_of_parameters', 'Liouville', 'separable_Integral', '1st_exact_Integral', '1st_linear_Integral', 'Bernoulli_Integral', '1st_homogeneous_coeff_subs_indep_div_dep_Integral', '1st_homogeneous_coeff_subs_dep_div_indep_Integral', 'almost_linear_Integral', 'linear_coefficients_Integral', 'separable_reduced_Integral', 'nth_linear_constant_coeff_variation_of_parameters_Integral', 'Liouville_Integral')</em><a class="headerlink" href="#sympy.solvers.ode.allhints" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a list of hints in the order that they should be preferred by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>. In general, hints earlier in the
list should produce simpler solutions than those later in the list (for
ODEs that fit both).  For now, the order of this list is based on empirical
observations by the developers of SymPy.</p>
<p>The hint used by <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> for a specific ODE
can be overridden (see the docstring).</p>
<p>In general, <tt class="docutils literal"><span class="pre">_Integral</span></tt> hints are grouped at the end of the list, unless
there is a method that returns an unevaluable integral most of the time
(which go near the end of the list anyway).  <tt class="docutils literal"><span class="pre">default</span></tt>, <tt class="docutils literal"><span class="pre">all</span></tt>,
<tt class="docutils literal"><span class="pre">best</span></tt>, and <tt class="docutils literal"><span class="pre">all_Integral</span></tt> meta-hints should not be included in this
list, but <tt class="docutils literal"><span class="pre">_best</span></tt> and <tt class="docutils literal"><span class="pre">_Integral</span></tt> hints should be included.</p>
</dd></dl>

</div>
<div class="section" id="odesimp">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">odesimp</span></tt><a class="headerlink" href="#odesimp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.odesimp">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">odesimp</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#odesimp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.odesimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies ODEs, including trying to solve for <tt class="docutils literal"><span class="pre">func</span></tt> and running
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><tt class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></tt></a>.</p>
<p>It may use knowledge of the type of solution that the hint returns to
apply additional simplifications.</p>
<p>It also attempts to integrate any <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><tt class="xref py py-class docutils literal"><span class="pre">Integral</span></tt></a>s
in the expression, if the hint is not an <tt class="docutils literal"><span class="pre">_Integral</span></tt> hint.</p>
<p>This function should have no effect on expressions returned by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>, as
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> already calls
<a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a>, but the individual hint functions
do not call <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a> (because the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> wrapper does).  Therefore, this
function is designed for mainly internal use.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">odesimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,u2,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">                        x</span>
<span class="go">                       ----</span>
<span class="go">                       f(x)</span>
<span class="go">                         /</span>
<span class="go">                        |</span>
<span class="go">                        |   /        1   \</span>
<span class="go">                        |  -|u2 + -------|</span>
<span class="go">                        |   |        /1 \|</span>
<span class="go">                        |   |     sin|--||</span>
<span class="go">                        |   \        \u2//</span>
<span class="go">log(f(x)) = log(C1) +   |  ---------------- d(u2)</span>
<span class="go">                        |          2</span>
<span class="go">                        |        u2</span>
<span class="go">                        |</span>
<span class="go">                       /</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="gp">... </span><span class="p">))</span> 
<span class="go">    x</span>
<span class="go">--------- = C1</span>
<span class="go">   /f(x)\</span>
<span class="go">tan|----|</span>
<span class="go">   \2*x /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constant-renumber">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">constant_renumber</span></tt><a class="headerlink" href="#constant-renumber" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.constant_renumber">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">constant_renumber</tt><big>(</big><em>expr</em>, <em>symbolname</em>, <em>startnumber</em>, <em>endnumber</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#constant_renumber"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.constant_renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber arbitrary constants in <tt class="docutils literal"><span class="pre">expr</span></tt> to have numbers 1 through <span class="math">\(N\)</span>
where <span class="math">\(N\)</span> is <tt class="docutils literal"><span class="pre">endnumber</span> <span class="pre">-</span> <span class="pre">startnumber</span> <span class="pre">+</span> <span class="pre">1</span></tt> at most.</p>
<p>This is a simple function that goes through and renumbers any
<a class="reference internal" href="../core.html#sympy.core.symbol.Symbol" title="sympy.core.symbol.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> with a name in the form <tt class="docutils literal"><span class="pre">symbolname</span>
<span class="pre">+</span> <span class="pre">num</span></tt> where <tt class="docutils literal"><span class="pre">num</span></tt> is in the range from <tt class="docutils literal"><span class="pre">startnumber</span></tt> to
<tt class="docutils literal"><span class="pre">endnumber</span></tt>.</p>
<p>Symbols are renumbered based on <tt class="docutils literal"><span class="pre">.sort_key()</span></tt>, so they should be
numbered roughly in the order that they appear in the final, printed
expression.  Note that this ordering is based in part on hashes, so it can
produce different results on different machines.</p>
<p>The structure of this function is very similar to that of
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><tt class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></tt></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">constant_renumber</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,C:5&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Only constants in the given range (inclusive) are renumbered;
the renumbering always starts from 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + C2 + C4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">C0 + 2*C1 + C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C2</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">C1 + 3*C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">                2</span>
<span class="go">C1*x + C2 + C3*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">                2</span>
<span class="go">C1 + C2*x + C3*x</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constantsimp">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">constantsimp</span></tt><a class="headerlink" href="#constantsimp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.constantsimp">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">constantsimp</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#constantsimp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.constantsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies an expression with arbitrary constants in it.</p>
<p>This function is written specifically to work with
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>, and is not intended for general use.</p>
<p>Simplification is done by &#8220;absorbing&#8221; the arbitrary constants in to other
arbitrary constants, numbers, and symbols that they are not independent
of.</p>
<p>The symbols must all have the same name with numbers after it, for
example, <tt class="docutils literal"><span class="pre">C1</span></tt>, <tt class="docutils literal"><span class="pre">C2</span></tt>, <tt class="docutils literal"><span class="pre">C3</span></tt>.  The <tt class="docutils literal"><span class="pre">symbolname</span></tt> here would be
&#8216;<tt class="docutils literal"><span class="pre">C</span></tt>&#8216;, the <tt class="docutils literal"><span class="pre">startnumber</span></tt> would be 1, and the <tt class="docutils literal"><span class="pre">endnumber</span></tt> would be 3.
If the arbitrary constants are independent of the variable <tt class="docutils literal"><span class="pre">x</span></tt>, then the
independent symbol would be <tt class="docutils literal"><span class="pre">x</span></tt>.  There is no need to specify the
dependent function, such as <tt class="docutils literal"><span class="pre">f(x)</span></tt>, because it already has the
independent symbol, <tt class="docutils literal"><span class="pre">x</span></tt>, in it.</p>
<p>Because terms are &#8220;absorbed&#8221; into arbitrary constants and because
constants are renumbered after simplifying, the arbitrary constants in
expr are not necessarily equal to the ones of the same name in the
returned result.</p>
<p>If two or more arbitrary constants are added, multiplied, or raised to the
power of each other, they are first absorbed together into a single
arbitrary constant.  Then the new constant is combined into other terms if
necessary.</p>
<p>Absorption of constants is done with limited assistance:</p>
<ol class="arabic simple">
<li>terms of <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><tt class="xref py py-class docutils literal"><span class="pre">Add</span></tt></a>s are collected to try join
constants so <span class="math">\(e^x (C_1 \cos(x) + C_2 \cos(x))\)</span> will simplify to <span class="math">\(e^x
C_1 \cos(x)\)</span>;</li>
<li>powers with exponents that are <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><tt class="xref py py-class docutils literal"><span class="pre">Add</span></tt></a>s are
expanded so <span class="math">\(e^{C_1 + x}\)</span> will be simplified to <span class="math">\(C_1 e^x\)</span>.</li>
</ol>
<p>Use <a class="reference internal" href="#sympy.solvers.ode.constant_renumber" title="sympy.solvers.ode.constant_renumber"><tt class="xref py py-meth docutils literal"><span class="pre">constant_renumber()</span></tt></a> to renumber constants
after simplification or else arbitrary numbers on constants may appear,
e.g. <span class="math">\(C_1 + C_3 x\)</span>.</p>
<p>In rare cases, a single constant can be &#8220;simplified&#8221; into two constants.
Every differential equation solution should have as many arbitrary
constants as the order of the differential equation.  The result here will
be technically correct, but it may, for example, have <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> in
an expression, when <span class="math">\(C_1\)</span> is actually equal to <span class="math">\(C_2\)</span>.  Use your discretion
in such situations, and also take advantage of the ability to use hints in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">constantsimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;C1,C2,C3,x,y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">C2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + C3*x</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sol-simplicity">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">sol_simplicity</span></tt><a class="headerlink" href="#sol-simplicity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_sol_simplicity">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_sol_simplicity</tt><big>(</big><em>sol</em>, <em>func</em>, <em>trysolving=True</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_sol_simplicity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_sol_simplicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an extended integer representing how simple a solution to an ODE
is.</p>
<p>The following things are considered, in order from most simple to least:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sol</span></tt> is solved for <tt class="docutils literal"><span class="pre">func</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">sol</span></tt> is not solved for <tt class="docutils literal"><span class="pre">func</span></tt>, but can be if passed to solve (e.g.,
a solution returned by <tt class="docutils literal"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">simplify=False</span></tt>).</li>
<li>If <tt class="docutils literal"><span class="pre">sol</span></tt> is not solved for <tt class="docutils literal"><span class="pre">func</span></tt>, then base the result on the
length of <tt class="docutils literal"><span class="pre">sol</span></tt>, as computed by <tt class="docutils literal"><span class="pre">len(str(sol))</span></tt>.</li>
<li>If <tt class="docutils literal"><span class="pre">sol</span></tt> has any unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><tt class="xref py py-class docutils literal"><span class="pre">Integral</span></tt></a>s,
this will automatically be considered less simple than any of the above.</li>
</ul>
<p>This function returns an integer such that if solution A is simpler than
solution B by above metric, then <tt class="docutils literal"><span class="pre">ode_sol_simplicity(sola,</span> <span class="pre">func)</span> <span class="pre">&lt;</span>
<span class="pre">ode_sol_simplicity(solb,</span> <span class="pre">func)</span></tt>.</p>
<p>Currently, the following are the numbers returned, but if the heuristic is
ever improved, this may change.  Only the ordering is guaranteed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Simplicity</th>
<th class="head">Return</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">sol</span></tt> solved for <tt class="docutils literal"><span class="pre">func</span></tt></td>
<td><tt class="docutils literal"><span class="pre">-2</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">sol</span></tt> not solved for <tt class="docutils literal"><span class="pre">func</span></tt> but can be</td>
<td><tt class="docutils literal"><span class="pre">-1</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">sol</span></tt> is not solved nor solvable for
<tt class="docutils literal"><span class="pre">func</span></tt></td>
<td><tt class="docutils literal"><span class="pre">len(str(sol))</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">sol</span></tt> contains an
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><tt class="xref py py-class docutils literal"><span class="pre">Integral</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">oo</span></tt></td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">oo</span></tt> here means the SymPy infinity, which should compare greater than
any integer.</p>
<p>If you already know <a class="reference internal" href="solvers.html#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><tt class="xref py py-meth docutils literal"><span class="pre">solve()</span></tt></a> cannot solve
<tt class="docutils literal"><span class="pre">sol</span></tt>, you can use <tt class="docutils literal"><span class="pre">trysolving=False</span></tt> to skip that step, which is the
only potentially slow step.  For example,
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> with the <tt class="docutils literal"><span class="pre">simplify=False</span></tt> flag
should do this.</p>
<p>If <tt class="docutils literal"><span class="pre">sol</span></tt> is a list of solutions, if the worst solution in the list
returns <tt class="docutils literal"><span class="pre">oo</span></tt> it returns that, otherwise it returns <tt class="docutils literal"><span class="pre">len(str(sol))</span></tt>,
that is, the length of the string representation of the whole list.</p>
<p class="rubric">Examples</p>
<p>This function is designed to be passed to <tt class="docutils literal"><span class="pre">min</span></tt> as the key argument,
such as <tt class="docutils literal"><span class="pre">min(listofsolutions,</span> <span class="pre">key=lambda</span> <span class="pre">i:</span> <span class="pre">ode_sol_simplicity(i,</span>
<span class="pre">f(x)))</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">ode_sol_simplicity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x, C1, C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">C2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]]</span>
<span class="go">[26, 33]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">f(x)/tan(f(x)/(2*x)) == C1</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-exact">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_exact</span></tt><a class="headerlink" href="#st-exact" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_exact">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_exact</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_exact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order exact ordinary differential equations.</p>
<p>A 1st order differential equation is called exact if it is the total
differential of a function. That is, the differential equation</p>
<div class="math">
\[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]</div>
<p>is exact if there is some function <span class="math">\(F(x, y)\)</span> such that <span class="math">\(P(x, y) =
\partial{}F/\partial{}x\)</span> and <span class="math">\(Q(x, y) = \partial{}F/\partial{}y\)</span>.  It can
be shown that a necessary and sufficient condition for a first order ODE
to be exact is that <span class="math">\(\partial{}P/\partial{}y = \partial{}Q/\partial{}x\)</span>.
Then, the solution will be as given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,y,t,x0,y0,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Integral</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">Integral</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">))),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">            x                y</span>
<span class="go">            /                /</span>
<span class="go">           |                |</span>
<span class="go">F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="go">           |                |</span>
<span class="go">          /                /</span>
<span class="go">          x0               y0</span>
</pre></div>
</div>
<p>Where the first partials of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> exist and are continuous in a
simply connected region.</p>
<p>A note: SymPy currently has no way to represent inert substitution on an
expression, so the hint <tt class="docutils literal"><span class="pre">1st_exact_Integral</span></tt> will return an integral
with <span class="math">\(dy\)</span>.  This is supposed to represent the function that you are
solving for.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Exact_differential_equation">http://en.wikipedia.org/wiki/Exact_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 73</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">x*cos(f(x)) + f(x)**3/3 == C1</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-best">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_best</span></tt><a class="headerlink" href="#st-homogeneous-coeff-best" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_best">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_homogeneous_coeff_best</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_best"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the best solution to an ODE from the two hints
<tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></tt> and
<tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></tt>.</p>
<p>This is as determined by <a class="reference internal" href="#sympy.solvers.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode_sol_simplicity"><tt class="xref py py-meth docutils literal"><span class="pre">ode_sol_simplicity()</span></tt></a>.</p>
<p>See the
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></tt></a>
and
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></tt></a>
docstrings for more information on these hints.  Note that there is no
<tt class="docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best_Integral</span></tt> hint.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_best&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-dep-div-indep">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></tt><a class="headerlink" href="#st-homogeneous-coeff-subs-dep-div-indep" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_homogeneous_coeff_subs_dep_div_indep</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_dep_div_indep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math">\(u_1 = \frac{\text{&lt;dependent
variable&gt;}}{\text{&lt;independent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math">\(F(x, y)\)</span> is homogeneous of order <span class="math">\(n\)</span> if <span class="math">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math">\(F(x, y)\)</span> can be rewritten as <span class="math">\(G(y/x)\)</span> or <span class="math">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><tt class="xref py py-meth docutils literal"><span class="pre">homogeneous_order()</span></tt></a>.</p>
<p>If the coefficients <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math">\(y = u_1 x\)</span> (i.e. <span class="math">\(u_1 = y/x\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math">\(x\)</span> and <span class="math">\(u\)</span>.  If
<span class="math">\(h(u_1)\)</span> is the function that results from making the substitution <span class="math">\(u_1 =
f(x)/x\)</span> on <span class="math">\(P(x, f(x))\)</span> and <span class="math">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math">\(Q(x, f(x))\)</span> in the differential equation <span class="math">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> /f(x)\    /f(x)\ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \ x  /    \ x  / dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;</span><span class="p">))</span>
<span class="go">               f(x)</span>
<span class="go">               ----</span>
<span class="go">                x</span>
<span class="go">                 /</span>
<span class="go">                |</span>
<span class="go">                |       -h(u1)</span>
<span class="go">log(x) = C1 +   |  ---------------- d(u1)</span>
<span class="go">                |  u1*h(u1) + g(u1)</span>
<span class="go">                |</span>
<span class="go">               /</span>
</pre></div>
</div>
<p>Where <span class="math">\(u_1 h(u_1) + g(u_1) \ne 0\)</span> and <span class="math">\(x \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best()</span></tt></a> and
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></tt></a>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">                      /          3   \</span>
<span class="go">                      |3*f(x)   f (x)|</span>
<span class="go">                   log|------ + -----|</span>
<span class="go">                      |  x         3 |</span>
<span class="go">                      \           x  /</span>
<span class="go">log(x) = log(C1) - -------------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-indep-div-dep">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></tt><a class="headerlink" href="#st-homogeneous-coeff-subs-indep-div-dep" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_homogeneous_coeff_subs_indep_div_dep</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_indep_div_dep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math">\(u_2 = \frac{\text{&lt;independent
variable&gt;}}{\text{&lt;dependent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math">\(F(x, y)\)</span> is homogeneous of order <span class="math">\(n\)</span> if <span class="math">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math">\(F(x, y)\)</span> can be rewritten as <span class="math">\(G(y/x)\)</span> or <span class="math">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><tt class="xref py py-meth docutils literal"><span class="pre">homogeneous_order()</span></tt></a>.</p>
<p>If the coefficients <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math">\(x = u_2 y\)</span> (i.e. <span class="math">\(u_2 = x/y\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math">\(y\)</span> and <span class="math">\(u_2\)</span>.  If
<span class="math">\(h(u_2)\)</span> is the function that results from making the substitution <span class="math">\(u_2 =
x/f(x)\)</span> on <span class="math">\(P(x, f(x))\)</span> and <span class="math">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math">\(Q(x, f(x))\)</span> in the differential equation <span class="math">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> / x  \    / x  \ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \f(x)/    \f(x)/ dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">))</span>
<span class="go">             x</span>
<span class="go">            ----</span>
<span class="go">            f(x)</span>
<span class="go">              /</span>
<span class="go">             |</span>
<span class="go">             |       -g(u2)</span>
<span class="go">             |  ---------------- d(u2)</span>
<span class="go">             |  u2*g(u2) + h(u2)</span>
<span class="go">             |</span>
<span class="go">            /</span>

<span class="go">f(x) = C1*e</span>
</pre></div>
</div>
<p>Where <span class="math">\(u_2 g(u_2) + h(u_2) \ne 0\)</span> and <span class="math">\(f(x) \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best()</span></tt></a> and
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></tt></a>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-linear">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_linear</span></tt><a class="headerlink" href="#st-linear" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_linear">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_linear</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order linear differential equations.</p>
<p>These are differential equations of the form</p>
<div class="math">
\[dy/dx + P(x) y = Q(x)\text{.}\]</div>
<p>These kinds of differential equations can be solved in a general way.  The
integrating factor <span class="math">\(e^{\int P(x) \,dx}\)</span> will turn the equation into a
separable equation.  The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_linear_Integral&#39;</span><span class="p">))</span>
<span class="go">       /       /                   \</span>
<span class="go">       |      |                    |</span>
<span class="go">       |      |         /          |     /</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |       /            |   /</span>
<span class="go">f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="go">       |      |                    |</span>
<span class="go">       \     /                     /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation">http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 92</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&#39;1st_linear&#39;</span><span class="p">))</span>
<span class="go">f(x) = x*(C1 - cos(x))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bernoulli">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">Bernoulli</span></tt><a class="headerlink" href="#bernoulli" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Bernoulli">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_Bernoulli</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Bernoulli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves Bernoulli differential equations.</p>
<p>These are equations of the form</p>
<div class="math">
\[dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}\]</div>
<p>The substitution <span class="math">\(w = 1/y^{1-n}\)</span> will transform an equation of this form
into one that is linear (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_linear" title="sympy.solvers.ode.ode_1st_linear"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_linear()</span></tt></a>).  The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d                n</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Bernoulli_Integral&#39;</span><span class="p">))</span> 
<span class="go">                                                                               1</span>
<span class="go">                                                                              ----</span>
<span class="go">                                                                             1 - n</span>
<span class="go">       //                /                            \                     \</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       ||               |                  /          |             /       |</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |        (1 - n)* | P(x) dx   |  (-1 + n)* | P(x) dx|</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |                /            |           /         |</span>
<span class="go">f(x) = ||C1 + (-1 + n)* | -Q(x)*e                   dx|*e                   |</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       \\               /                            /                     /</span>
</pre></div>
</div>
<p>Note that the equation is separable when <span class="math">\(n = 1\)</span> (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.ode_separable" title="sympy.solvers.ode.ode_separable"><tt class="xref py py-meth docutils literal"><span class="pre">ode_separable()</span></tt></a>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go"> f(x)</span>
<span class="go">   /</span>
<span class="go">  |                /</span>
<span class="go">  |  1            |</span>
<span class="go">  |  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="go">  |  y            |</span>
<span class="go">  |              /</span>
<span class="go"> /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Bernoulli_differential_equation">http://en.wikipedia.org/wiki/Bernoulli_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 95</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Bernoulli&#39;</span><span class="p">))</span>
<span class="go">                1</span>
<span class="go">f(x) = -------------------</span>
<span class="go">         /     log(x)   1\</span>
<span class="go">       x*|C1 + ------ + -|</span>
<span class="go">         \       x      x/</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="liouville">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">Liouville</span></tt><a class="headerlink" href="#liouville" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Liouville">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_Liouville</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Liouville"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Liouville" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 2nd order Liouville differential equations.</p>
<p>The general form of a Liouville ODE is</p>
<div class="math">
\[\frac{d^2 y}{dx^2} + g(y) \left(\!
\frac{dy}{dx}\!\right)^2 + h(x)
\frac{dy}{dx}\text{.}\]</div>
<p>The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                  2                    2</span>
<span class="go">        /d       \         d          d</span>
<span class="go">g(f(x))*|--(f(x))|  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="go">        \dx      /         dx           2</span>
<span class="go">                                      dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Liouville_Integral&#39;</span><span class="p">))</span>
<span class="go">                                  f(x)</span>
<span class="go">          /                     /</span>
<span class="go">         |                     |</span>
<span class="go">         |     /               |     /</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |  - | h(x) dx        |    | g(y) dy</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |   /                 |   /</span>
<span class="go">C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="go">         |                     |</span>
<span class="go">        /                     /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Goldstein and Braun, &#8220;Advanced Methods for the Solution of Differential
Equations&#8221;, pp. 98</li>
<li><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</a></li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Liouville&#39;</span><span class="p">))</span>
<span class="go">           ________________           ________________</span>
<span class="go">[f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="riccati-special-minus2">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">Riccati_special_minus2</span></tt><a class="headerlink" href="#riccati-special-minus2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Riccati_special_minus2">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_Riccati_special_minus2</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Riccati_special_minus2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Riccati_special_minus2" title="Permalink to this definition">¶</a></dt>
<dd><p>The general Riccati equation has the form</p>
<div class="math">
\[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]</div>
<p>While it does not have a general solution [1], the &#8220;special&#8221; form, <span class="math">\(dy/dx
= a y^2 - b x^c\)</span>, does have solutions in many cases [2].  This routine
returns a solution for <span class="math">\(a(dy/dx) = b y^2 + c y/x + d/x^2\)</span> that is obtained
by using a suitable change of variables to reduce it to the special form
and is valid when neither <span class="math">\(a\)</span> nor <span class="math">\(b\)</span> are zero and either <span class="math">\(c\)</span> or <span class="math">\(d\)</span> is
zero.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">        /                                 /        __________________       \\</span>
<span class="go">        |           __________________    |       /                2        ||</span>
<span class="go">        |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="go">       -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="go">        \                                 \                 2*a             //</span>
<span class="go">f(x) = ------------------------------------------------------------------------</span>
<span class="go">                                        2*b*x</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</a></li>
<li><a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf</a> -
<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</a></li>
</ol>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-homogeneous">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous</span></tt><a class="headerlink" href="#nth-linear-constant-coeff-homogeneous" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_nth_linear_constant_coeff_homogeneous</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em>, <em>returns='sol'</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_homogeneous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math">\(n\)</span>th order linear homogeneous differential equation with
constant coefficients.</p>
<p>This is an equation of the form</p>
<div class="math">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = 0\text{.}\]</div>
<p>These equations can be solved in a general manner, by taking the roots of
the characteristic equation <span class="math">\(a_n m^n + a_{n-1} m^{n-1} + \cdots + a_1 m +
a_0 = 0\)</span>.  The solution will then be the sum of <span class="math">\(C_n x^i e^{r x}\)</span> terms,
for each where <span class="math">\(C_n\)</span> is an arbitrary constant, <span class="math">\(r\)</span> is a root of the
characteristic equation and <span class="math">\(i\)</span> is one of each from 0 to the multiplicity
of the root - 1 (for example, a root 3 of multiplicity 2 would create the
terms <span class="math">\(C_1 e^{3 x} + C_2 x e^{3 x}\)</span>).  The exponential is usually expanded
for complex roots using Euler&#8217;s equation <span class="math">\(e{I x} = \cos(x) + I \sin(x)\)</span>.
Complex roots always come in conjugate pairs in polynomials with real
coefficients, so the two roots will be represented (after simplifying the
constants) as <span class="math">\(e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)\)</span>.</p>
<p>If SymPy cannot find exact roots to the characteristic equation, a
<a class="reference internal" href="../polys/reference.html#sympy.polys.rootoftools.RootOf" title="sympy.polys.rootoftools.RootOf"><tt class="xref py py-class docutils literal"><span class="pre">RootOf</span></tt></a> instance will be return
instead.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">f(x) == C1*exp(x*RootOf(_x**5 + 10*_x - 2, 0)) +</span>
<span class="go">C2*exp(x*RootOf(_x**5 + 10*_x - 2, 1)) +</span>
<span class="go">C3*exp(x*RootOf(_x**5 + 10*_x - 2, 2)) +</span>
<span class="go">C4*exp(x*RootOf(_x**5 + 10*_x - 2, 3)) +</span>
<span class="go">C5*exp(x*RootOf(_x**5 + 10*_x - 2, 4))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is no
<tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous_Integral</span></tt> hint.</p>
<p>The following is for internal use:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'sol'</span></tt> returns the solution to the ODE.</li>
<li><tt class="docutils literal"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'list'</span></tt> returns a list of linearly independent solutions,
for use with non homogeneous solution methods like variation of
parameters and undetermined coefficients.  Note that, though the
solutions should be linearly independent, this function does not
explicitly check that.  You can do <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">simplify(wronskian(sollist))</span>
<span class="pre">!=</span> <span class="pre">0</span></tt> to check for linear independence.  Also, <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">len(sollist)</span> <span class="pre">==</span>
<span class="pre">order</span></tt> will need to pass.</li>
<li><tt class="docutils literal"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'both'</span></tt>, return a dictionary <tt class="docutils literal"><span class="pre">{'sol':</span> <span class="pre">&lt;solution</span> <span class="pre">to</span> <span class="pre">ODE&gt;,</span>
<span class="pre">'list':</span> <span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">linearly</span> <span class="pre">independent</span> <span class="pre">solutions&gt;}</span></tt>.</li>
</ul>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation">http://en.wikipedia.org/wiki/Linear_differential_equation</a> section:
Nonhomogeneous_equation_with_constant_coefficients</li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 211</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">))</span>
<span class="go">                    x                            -2*x</span>
<span class="go">f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-undetermined-coefficients">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></tt><a class="headerlink" href="#nth-linear-constant-coeff-undetermined-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_nth_linear_constant_coeff_undetermined_coefficients</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_undetermined_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math">\(n\)</span>th order linear differential equation with constant
coefficients using the method of undetermined coefficients.</p>
<p>This method works on differential equations of the form</p>
<div class="math">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = P(x)\text{,}\]</div>
<p>where <span class="math">\(P(x)\)</span> is a function that has a finite number of linearly
independent derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the form
<span class="math">\(a x^i e^{b x} \sin(c x + d)\)</span> or <span class="math">\(a x^i e^{b x} \cos(c x + d)\)</span>, where <span class="math">\(i\)</span>
is a non-negative integer and <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, <span class="math">\(c\)</span>, and <span class="math">\(d\)</span> are constants.  For
example any polynomial in <span class="math">\(x\)</span>, functions like <span class="math">\(x^2 e^{2 x}\)</span>, <span class="math">\(x \sin(x)\)</span>,
and <span class="math">\(e^x \cos(x)\)</span> can all be used.  Products of <span class="math">\(\sin\)</span>&#8216;s and <span class="math">\(\cos\)</span>&#8216;s have
a finite number of derivatives, because they can be expanded into <span class="math">\(\sin(a
x)\)</span> and <span class="math">\(\cos(b x)\)</span> terms.  However, SymPy currently cannot do that
expansion, so you will need to manually rewrite the expression in terms of
the above to use this method.  So, for example, you will need to manually
convert <span class="math">\(\sin^2(x)\)</span> into <span class="math">\((1 + \cos(2 x))/2\)</span> to properly apply the method
of undetermined coefficients on it.</p>
<p>This method works by creating a trial function from the expression and all
of its linear independent derivatives and substituting them into the
original ODE.  The coefficients for each term will be a system of linear
equations, which are be solved for and substituted, giving the solution.
If any of the trial functions are linearly dependent on the solution to
the homogeneous equation, they are multiplied by sufficient <span class="math">\(x\)</span> to make
them linearly independent.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients">http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 221</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;</span><span class="p">))</span>
<span class="go">       /             4\</span>
<span class="go">       |            x |  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="go">f(x) = |C1 + C2*x + --|*e   - ---------- + ----------</span>
<span class="go">       \            3 /           25           25</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-variation-of-parameters">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters</span></tt><a class="headerlink" href="#nth-linear-constant-coeff-variation-of-parameters" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_nth_linear_constant_coeff_variation_of_parameters</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_variation_of_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math">\(n\)</span>th order linear differential equation with constant
coefficients using the method of variation of parameters.</p>
<p>This method works on any differential equations of the form</p>
<div class="math">
\[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0
f(x) = P(x)\text{.}\]</div>
<p>This method works by assuming that the particular solution takes the form</p>
<div class="math">
\[\sum_{x=1}^{n} c_i(x) y_i(x)\text{,}\]</div>
<p>where <span class="math">\(y_i\)</span> is the <span class="math">\(i\)</span>th solution to the homogeneous equation.  The
solution is then solved using Wronskian&#8217;s and Cramer&#8217;s Rule.  The
particular solution is given by</p>
<div class="math">
\[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx
\right) y_i(x) \text{,}\]</div>
<p>where <span class="math">\(W(x)\)</span> is the Wronskian of the fundamental system (the system of <span class="math">\(n\)</span>
linearly independent solutions to the homogeneous equation), and <span class="math">\(W_i(x)\)</span>
is the Wronskian of the fundamental system with the <span class="math">\(i\)</span>th column replaced
with <span class="math">\([0, 0, \cdots, 0, P(x)]\)</span>.</p>
<p>This method is general enough to solve any <span class="math">\(n\)</span>th order inhomogeneous
linear differential equation with constant coefficients, but sometimes
SymPy cannot simplify the Wronskian well enough to integrate it.  If this
method hangs, try using the
<tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters_Integral</span></tt> hint and
simplifying the integrals manually.  Also, prefer using
<tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></tt> when it
applies, because it doesn&#8217;t use integration, making it faster and more
reliable.</p>
<p>Warning, using simplify=False with
&#8216;nth_linear_constant_coeff_variation_of_parameters&#8217; in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> may cause it to hang, because it will
not attempt to simplify the Wronskian before integrating.  It is
recommended that you only use simplify=False with
&#8216;nth_linear_constant_coeff_variation_of_parameters_Integral&#8217; for this
method, especially if the solution to the homogeneous equation has
trigonometric functions in it.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Variation_of_parameters">http://en.wikipedia.org/wiki/Variation_of_parameters</a></li>
<li><a class="reference external" href="http://planetmath.org/encyclopedia/VariationOfParameters.html">http://planetmath.org/encyclopedia/VariationOfParameters.html</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 233</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;</span><span class="p">))</span>
<span class="go">       /                     3                \</span>
<span class="go">       |                2   x *(6*log(x) - 11)|  x</span>
<span class="go">f(x) = |C1 + C2*x + C3*x  + ------------------|*e</span>
<span class="go">       \                            36        /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="separable">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">separable</span></tt><a class="headerlink" href="#separable" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_separable">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_separable</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_separable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_separable" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves separable 1st order differential equations.</p>
<p>This is any differential equation that can be written as <span class="math">\(P(y)
\tfrac{dy}{dx} = Q(x)\)</span>.  The solution can then just be found by
rearranging terms and integrating: <span class="math">\(\int P(y) \,dy = \int Q(x) \,dx\)</span>.
This hint uses <a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><tt class="xref py py-meth docutils literal"><span class="pre">sympy.simplify.simplify.separatevars()</span></tt></a> as its back
end, so if a separable equation is not caught by this solver, it is most
likely the fault of that function.
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><tt class="xref py py-meth docutils literal"><span class="pre">separatevars()</span></tt></a> is
smart enough to do most expansion and factoring necessary to convert a
separable equation <span class="math">\(F(x, y)\)</span> into the proper form <span class="math">\(P(x)\cdot{}Q(y)\)</span>.  The
general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">             d</span>
<span class="go">a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="go">             dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">     f(x)</span>
<span class="go">   /                  /</span>
<span class="go">  |                  |</span>
<span class="go">  |  b(y)            | c(x)</span>
<span class="go">  |  ---- dy = C1 +  | ---- dx</span>
<span class="go">  |  d(y)            | a(x)</span>
<span class="go">  |                  |</span>
<span class="go"> /                  /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 52</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">   /   2       \         2</span>
<span class="go">log\3*f (x) - 1/        x</span>
<span class="go">---------------- = C1 + --</span>
<span class="go">       6                2</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="almost-linear">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">almost_linear</span></tt><a class="headerlink" href="#almost-linear" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_almost_linear">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_almost_linear</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_almost_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_almost_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an almost-linear differential equation.</p>
<p>The general form of an almost linear differential equation is</p>
<div class="math">
\[f(x) g(y) y + k(x) l(y) + m(x) = 0
\text{where} l'(y) = g(y)\text{.}\]</div>
<p>This can be solved by substituting <span class="math">\(l(y) = u(y)\)</span>.  Making the given
substitution reduces it to a linear differential equation of the form <span class="math">\(u'
+ P(x) u + Q(x) = 0\)</span>.</p>
<p>The general solution is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="s">&#39;l&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">l</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">     d</span>
<span class="go">f(x)*--(l(y)) + g(x) + k(x)*l(y) = 0</span>
<span class="go">     dy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span> <span class="o">=</span> <span class="s">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">       /     //   -y*g(x)                  \\</span>
<span class="go">       |     ||   --------     for k(x) = 0||</span>
<span class="go">       |     ||     f(x)                   ||  -y*k(x)</span>
<span class="go">       |     ||                            ||  --------</span>
<span class="go">       |     ||       y*k(x)               ||    f(x)</span>
<span class="go">l(y) = |C1 + |&lt;       ------               ||*e</span>
<span class="go">       |     ||        f(x)                ||</span>
<span class="go">       |     ||-g(x)*e                     ||</span>
<span class="go">       |     ||--------------   otherwise  ||</span>
<span class="go">       |     ||     k(x)                   ||</span>
<span class="go">       \     \\                            //</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.ode.ode_1st_linear" title="sympy.solvers.ode.ode_1st_linear"><tt class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_linear()</span></tt></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Joel Moses, &#8220;Symbolic Integration - The Stormy Decade&#8221;, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">f(x) == (C1 - Ei(x))*exp(-x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">                     -x</span>
<span class="go">f(x) = (C1 - Ei(x))*e</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linear-coefficients">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">linear_coefficients</span></tt><a class="headerlink" href="#linear-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_linear_coefficients">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_linear_coefficients</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_linear_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_linear_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation with linear coefficients.</p>
<p>The general form of a differential equation with linear coefficients is</p>
<div class="math">
\[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y +
c_2}\!\right) = 0\text{,}\]</div>
<p>where <span class="math">\(a_1\)</span>, <span class="math">\(b_1\)</span>, <span class="math">\(c_1\)</span>, <span class="math">\(a_2\)</span>, <span class="math">\(b_2\)</span>, <span class="math">\(c_2\)</span> are constants and <span class="math">\(a_1 b_2
- a_2 b_1 \ne 0\)</span>.</p>
<p>This can be solved by substituting:</p>
<div class="math">
\[x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1 b_2}\]\[y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1
    b_2}\text{.}\]</div>
<p>This substitution reduces the equation to a homogeneous differential
equation.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><tt class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_best()</span></tt></a>, <a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><tt class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></tt></a>, <a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><tt class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></tt></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Joel Moses, &#8220;Symbolic Integration - The Stormy Decade&#8221;, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;linear_coefficients&#39;</span><span class="p">)</span>
<span class="go">[f(x) == -x - sqrt(C1 + 7*x**2) - 1, f(x) == -x + sqrt(C1 + 7*x**2) - 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;linear_coefficients&#39;</span><span class="p">))</span>
<span class="go">                  ___________                     ___________</span>
<span class="go">               /         2                     /         2</span>
<span class="go">[f(x) = -x - \/  C1 + 7*x   - 1, f(x) = -x + \/  C1 + 7*x   - 1]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="separable-reduced">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">separable_reduced</span></tt><a class="headerlink" href="#separable-reduced" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_separable_reduced">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_separable_reduced</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_separable_reduced"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_separable_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation that can be reduced to the separable form.</p>
<p>The general form of this equation is</p>
<div class="math">
\[y' + (y/x) H(x^n y) = 0\text{}.\]</div>
<p>This can be solved by substituting <span class="math">\(u(y) = x^n y\)</span>.  The equation then
reduces to the separable form <span class="math">\(\frac{u'}{u (\mathrm{power} - H(u))} -
\frac{1}{x} = 0\)</span>.</p>
<p>The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                 / n     \</span>
<span class="go">d          f(x)*g\x *f(x)/</span>
<span class="go">--(f(x)) + ---------------</span>
<span class="go">dx                x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go"> n</span>
<span class="go">x *f(x)</span>
<span class="go">  /</span>
<span class="go"> |</span>
<span class="go"> |         1</span>
<span class="go"> |    ------------ dy = C1 + log(x)</span>
<span class="go"> |    y*(n - g(y))</span>
<span class="go"> |</span>
<span class="go"> /</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.ode.ode_separable" title="sympy.solvers.ode.ode_separable"><tt class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_separable()</span></tt></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Joel Moses, &#8220;Symbolic Integration - The Stormy Decade&#8221;, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_reduced&#39;</span><span class="p">)</span>
<span class="go">[f(x) == (-sqrt(C1*x**2 + 1) + 1)/x, f(x) == (sqrt(C1*x**2 + 1) + 1)/x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go">             ___________                ___________</span>
<span class="go">            /     2                    /     2</span>
<span class="go">        - \/  C1*x  + 1  + 1         \/  C1*x  + 1  + 1</span>
<span class="go">[f(x) = --------------------, f(x) = ------------------]</span>
<span class="go">                 x                           x</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="lie-heuristics">
<h2>Lie heuristics<a class="headerlink" href="#lie-heuristics" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use of the Lie Group Solver.
Nonetheless, they contain useful information in their docstrings on the algorithms
implemented for the various heuristics.</p>
<div class="section" id="abaco1-simple">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">abaco1_simple</span></tt><a class="headerlink" href="#abaco1-simple" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_abaco1_simple">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">lie_heuristic_abaco1_simple</tt><big>(</big><em>match</em>, <em>comp=False</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_abaco1_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_abaco1_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>The first heuristic uses the following four sets of
assumptions on <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
<div class="math">
\[\xi = 0, \eta = f(x)\]</div>
<div class="math">
\[\xi = 0, \eta = f(y)\]</div>
<div class="math">
\[\xi = f(x), \eta = 0\]</div>
<div class="math">
\[\xi = f(y), \eta = 0\]</div>
<p>The success of this heuristic is determined by algebraic factorisation.
For the first assumption <span class="math">\(\xi = 0\)</span> and <span class="math">\(eta\)</span> to be a function of <span class="math">\(x\)</span>, the PDE</p>
<div class="math">
\[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x})*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi*\frac{\partial h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]</div>
<p>reduces to <span class="math">\(f'(x) - f\frac{\partial h}{\partial y} = 0\)</span>
If <span class="math">\(\frac{\partial h}{\partial y}\)</span> is a function of <span class="math">\(x\)</span>, then this can usually
be integrated easily. A similar idea is applied to the other 3 assumptions as well.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco1-product">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">abaco1_product</span></tt><a class="headerlink" href="#abaco1-product" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_abaco1_product">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">lie_heuristic_abaco1_product</tt><big>(</big><em>match</em>, <em>comp=False</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_abaco1_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_abaco1_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The second heuristic uses the following two assumptions on <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
<div class="math">
\[\eta = 0, \xi = f(x)*g(y)\]</div>
<div class="math">
\[\eta = f(x)*g(y), \xi = 0\]</div>
<p>The first assumption of this heuristic holds good if
<span class="math">\(\frac{1}{h^{2}}\frac{\partial^2}{\partial x \partial y}\log(h)\)</span> is
separable in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, then the separated factors containing <span class="math">\(x\)</span>
is <span class="math">\(f(x)\)</span>, and <span class="math">\(g(y)\)</span> is obtained by</p>
<div class="math">
\[exp^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]</div>
<p>provided <span class="math">\(f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\)</span> is a function
of <span class="math">\(y\)</span> only.</p>
<p>The second assumption holds good if <span class="math">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first assumption
satisifes. After obtaining <span class="math">\(f(x)\)</span> and <span class="math">\(g(y)\)</span>, the coordinates are again
interchanged, to get <span class="math">\(\eta\)</span> as <span class="math">\(f(x)*g(y)\)</span></p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</li>
</ul>
</dd></dl>

</div>
<div class="section" id="bivariate">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">bivariate</span></tt><a class="headerlink" href="#bivariate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_bivariate">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">lie_heuristic_bivariate</tt><big>(</big><em>match</em>, <em>comp=False</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_bivariate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_bivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>The third heuristic assumes the infinitesimals <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span>
to be bi-variate polynomials in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. The assumption made here
for the logic below is that <span class="math">\(h\)</span> is a rational function in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
though that may not be necessary for the infinitesimals to be
bivariate polynomials. The coefficients of the infinitesimals
are found out by substituting them in the PDE and grouping similar terms
that are polynomials and since they form a linear system, solve and check
for non trivial solutions. The degree of the assumed bivariates
are increased till a certain maximum value.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>Lie Groups and Differential Equations
pp. 327 - pp. 329</li>
</ul>
</dd></dl>

</div>
<div class="section" id="chi">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">chi</span></tt><a class="headerlink" href="#chi" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_chi">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">lie_heuristic_chi</tt><big>(</big><em>match</em>, <em>comp=False</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_chi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>The aim of the fourth heuristic is to find the function <span class="math">\(\chi(x, y)\)</span>
that satisifies the PDE <span class="math">\(\frac{d\chi}{dx} + h\frac{d\chi}{dx}
- \frac{\partial h}{\partial y}\chi = 0\)</span>.</p>
<p>This assumes <span class="math">\(\chi\)</span> to be a bivariate polynomial in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. By intution,
<span class="math">\(h\)</span> should be a rational function in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. The method used here is
to substitute a general binomial for <span class="math">\(\chi\)</span> up to a certain maximum degree
is reached. The coefficients of the polynomials, are calculated by by collecting
terms of the same order in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.</p>
<p>After finding <span class="math">\(\chi\)</span>, the next step is to use <span class="math">\(\eta = \xi*h + \chi\)</span>, to
determine <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span>. This can be done by dividing <span class="math">\(\chi\)</span> by <span class="math">\(h\)</span>
which would give <span class="math">\(-\xi\)</span> as the quotient and <span class="math">\(\eta\)</span> as the remainder.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</li>
</ul>
</dd></dl>

</div>
</div>
<div class="section" id="module-sympy.solvers.ode">
<span id="information-on-the-ode-module"></span><h2>Information on the ode module<a class="headerlink" href="#module-sympy.solvers.ode" title="Permalink to this headline">¶</a></h2>
<p>This module contains <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> and different helper
functions that it uses.</p>
<p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> solves ordinary differential equations.
See the docstring on the various functions for their uses.  Note that partial
differential equations support is in <tt class="docutils literal"><span class="pre">pde.py</span></tt>.  Note that hint functions
have docstrings describing their various methods, but they are intended for
internal use.  Use <tt class="docutils literal"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">hint=hint)</span></tt> to solve an ODE using a
specific hint.  See also the docstring on
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.</p>
<p><strong>Functions in this module</strong></p>
<blockquote>
<div><p>These are the user functions in this module:</p>
<ul class="simple">
<li><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> - Solves ODEs.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> - Classifies ODEs into
possible hints for <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><tt class="xref py py-meth docutils literal"><span class="pre">checkodesol()</span></tt></a> - Checks if an equation is the
solution to an ODE.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><tt class="xref py py-meth docutils literal"><span class="pre">homogeneous_order()</span></tt></a> - Returns the
homogeneous order of an expression.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><tt class="xref py py-meth docutils literal"><span class="pre">infinitesimals()</span></tt></a> - Returns the infinitesimals
of the Lie group of point transformations of an ODE, such that it is
invariant.</li>
<li><tt class="xref py py-meth docutils literal"><span class="pre">ode_checkinfsol()</span></tt> - Checks if the given infinitesimals
are the actual infinitesimals of a first order ODE.</li>
</ul>
<p>These are the non-solver helper functions that are for internal use.  The
user should use the various options to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> to obtain the functionality provided
by these functions:</p>
<ul class="simple">
<li><a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a> - Does all forms of ODE
simplification.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode_sol_simplicity"><tt class="xref py py-meth docutils literal"><span class="pre">ode_sol_simplicity()</span></tt></a> - A key function for
comparing solutions by simplicity.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><tt class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></tt></a> - Simplifies arbitrary
constants.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.constant_renumber" title="sympy.solvers.ode.constant_renumber"><tt class="xref py py-meth docutils literal"><span class="pre">constant_renumber()</span></tt></a> - Renumber arbitrary
constants.</li>
<li><tt class="xref py py-meth docutils literal"><span class="pre">_handle_Integral()</span></tt> - Evaluate unevaluated
Integrals.</li>
</ul>
<p>See also the docstrings of these functions.</p>
</div></blockquote>
<p><strong>Currently implemented solver methods</strong></p>
<p>The following methods are implemented for solving ordinary differential
equations.  See the docstrings of the various hint functions for more
information on each (run <tt class="docutils literal"><span class="pre">help(ode)</span></tt>):</p>
<blockquote>
<div><ul class="simple">
<li>1st order separable differential equations.</li>
<li>1st order differential equations whose coefficients or <span class="math">\(dx\)</span> and <span class="math">\(dy\)</span> are
functions homogeneous of the same order.</li>
<li>1st order exact differential equations.</li>
<li>1st order linear differential equations.</li>
<li>1st order Bernoulli differential equations.</li>
<li>2nd order Liouville differential equations.</li>
<li><span class="math">\(n\)</span>th order linear homogeneous differential equation with constant
coefficients.</li>
<li><span class="math">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of undetermined coefficients.</li>
<li><span class="math">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of variation of parameters.</li>
</ul>
</div></blockquote>
<p><strong>Philosophy behind this module</strong></p>
<p>This module is designed to make it easy to add new ODE solving methods without
having to mess with the solving code for other methods.  The idea is that
there is a <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> function, which takes in
an ODE and tells you what hints, if any, will solve the ODE.  It does this
without attempting to solve the ODE, so it is fast.  Each solving method is a
hint, and it has its own function, named <tt class="docutils literal"><span class="pre">ode_&lt;hint&gt;</span></tt>.  That function takes
in the ODE and any match expression gathered by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> and returns a solved result.  If
this result has any integrals in it, the hint function will return an
unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><tt class="xref py py-class docutils literal"><span class="pre">Integral</span></tt></a> class.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>, which is the user wrapper function
around all of this, will then call <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a> on
the result, which, among other things, will attempt to solve the equation for
the dependent variable (the function we are solving for), simplify the
arbitrary constants in the expression, and evaluate any integrals, if the hint
allows it.</p>
<p><strong>How to add new solution methods</strong></p>
<p>If you have an ODE that you want <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> to be
able to solve, try to avoid adding special case code here.  Instead, try
finding a general method that will solve your ODE, as well as others.  This
way, the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><tt class="xref py py-mod docutils literal"><span class="pre">ode</span></tt></a> module will become more robust, and
unhindered by special case hacks.  WolphramAlpha and Maple&#8217;s
DETools[odeadvisor] function are two resources you can use to classify a
specific ODE.  It is also better for a method to work with an <span class="math">\(n\)</span>th order ODE
instead of only with specific orders, if possible.</p>
<p>To add a new method, there are a few things that you need to do.  First, you
need a hint name for your method.  Try to name your hint so that it is
unambiguous with all other methods, including ones that may not be implemented
yet.  If your method uses integrals, also include a <tt class="docutils literal"><span class="pre">hint_Integral</span></tt> hint.
If there is more than one way to solve ODEs with your method, include a hint
for each one, as well as a <tt class="docutils literal"><span class="pre">&lt;hint&gt;_best</span></tt> hint.  Your <tt class="docutils literal"><span class="pre">ode_&lt;hint&gt;_best()</span></tt>
function should choose the best using min with <tt class="docutils literal"><span class="pre">ode_sol_simplicity</span></tt> as the
key argument.  See
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><tt class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best()</span></tt></a>, for example.
The function that uses your method will be called <tt class="docutils literal"><span class="pre">ode_&lt;hint&gt;()</span></tt>, so the
hint must only use characters that are allowed in a Python function name
(alphanumeric characters and the underscore &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216; character).  Include a
function for every hint, except for <tt class="docutils literal"><span class="pre">_Integral</span></tt> hints
(<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> takes care of those automatically).
Hint names should be all lowercase, unless a word is commonly capitalized
(such as Integral or Bernoulli).  If you have a hint that you do not want to
run with <tt class="docutils literal"><span class="pre">all_Integral</span></tt> that doesn&#8217;t have an <tt class="docutils literal"><span class="pre">_Integral</span></tt> counterpart (such
as a best hint that would defeat the purpose of <tt class="docutils literal"><span class="pre">all_Integral</span></tt>), you will
need to remove it manually in the <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> code.
See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> docstring for
guidelines on writing a hint name.</p>
<p>Determine <em>in general</em> how the solutions returned by your method compare with
other methods that can potentially solve the same ODEs.  Then, put your hints
in the <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><tt class="xref py py-data docutils literal"><span class="pre">allhints</span></tt></a> tuple in the order that they
should be called.  The ordering of this tuple determines which hints are
default.  Note that exceptions are ok, because it is easy for the user to
choose individual hints with <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.  In
general, <tt class="docutils literal"><span class="pre">_Integral</span></tt> variants should go at the end of the list, and
<tt class="docutils literal"><span class="pre">_best</span></tt> variants should go before the various hints they apply to.  For
example, the <tt class="docutils literal"><span class="pre">undetermined_coefficients</span></tt> hint comes before the
<tt class="docutils literal"><span class="pre">variation_of_parameters</span></tt> hint because, even though variation of parameters
is more general than undetermined coefficients, undetermined coefficients
generally returns cleaner results for the ODEs that it can solve than
variation of parameters does, and it does not require integration, so it is
much faster.</p>
<p>Next, you need to have a match expression or a function that matches the type
of the ODE, which you should put in <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>
(if the match function is more than just a few lines, like
<tt class="xref py py-meth docutils literal"><span class="pre">_undetermined_coefficients_match()</span></tt>, it should go
outside of <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>).  It should match the
ODE without solving for it as much as possible, so that
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> remains fast and is not hindered by
bugs in solving code.  Be sure to consider corner cases.  For example, if your
solution method involves dividing by something, make sure you exclude the case
where that division will be 0.</p>
<p>In most cases, the matching of the ODE will also give you the various parts
that you need to solve it.  You should put that in a dictionary (<tt class="docutils literal"><span class="pre">.match()</span></tt>
will do this for you), and add that as <tt class="docutils literal"><span class="pre">matching_hints['hint']</span> <span class="pre">=</span> <span class="pre">matchdict</span></tt>
in the relevant part of <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a>.
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> will then send this to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>, which will send it to your function as
the <tt class="docutils literal"><span class="pre">match</span></tt> argument.  Your function should be named <tt class="docutils literal"><span class="pre">ode_&lt;hint&gt;(eq,</span> <span class="pre">func,</span>
<span class="pre">order,</span> <span class="pre">match)`.</span>&nbsp; <span class="pre">If</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">to</span> <span class="pre">send</span> <span class="pre">more</span> <span class="pre">information,</span> <span class="pre">put</span> <span class="pre">it</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``match</span></tt>
dictionary.  For example, if you had to substitute in a dummy variable in
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><tt class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></tt></a> to match the ODE, you will need to
pass it to your function using the <span class="math">\(match\)</span> dict to access it.  You can access
the independent variable using <tt class="docutils literal"><span class="pre">func.args[0]</span></tt>, and the dependent variable
(the function you are trying to solve for) as <tt class="docutils literal"><span class="pre">func.func</span></tt>.  If, while trying
to solve the ODE, you find that you cannot, raise <tt class="docutils literal"><span class="pre">NotImplementedError</span></tt>.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a> will catch this error with the <tt class="docutils literal"><span class="pre">all</span></tt>
meta-hint, rather than causing the whole routine to fail.</p>
<p>Add a docstring to your function that describes the method employed.  Like
with anything else in SymPy, you will need to add a doctest to the docstring,
in addition to real tests in <tt class="docutils literal"><span class="pre">test_ode.py</span></tt>.  Try to maintain consistency
with the other hint functions&#8217; docstrings.  Add your method to the list at the
top of this docstring.  Also, add your method to <tt class="docutils literal"><span class="pre">ode.rst</span></tt> in the
<tt class="docutils literal"><span class="pre">docs/src</span></tt> directory, so that the Sphinx docs will pull its docstring into
the main SymPy documentation.  Be sure to make the Sphinx documentation by
running <tt class="docutils literal"><span class="pre">make</span> <span class="pre">html</span></tt> from within the doc directory to verify that the
docstring formats correctly.</p>
<p>If your solution method involves integrating, use <tt class="xref py py-meth docutils literal"><span class="pre">C.Integral()</span></tt> instead of
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt></a>.  This allows the user to bypass
hard/slow integration by using the <tt class="docutils literal"><span class="pre">_Integral</span></tt> variant of your hint.  In
most cases, calling <a class="reference internal" href="../core.html#sympy.core.basic.Basic.doit" title="sympy.core.basic.Basic.doit"><tt class="xref py py-meth docutils literal"><span class="pre">sympy.core.basic.Basic.doit()</span></tt></a> will integrate your
solution.  If this is not the case, you will need to write special code in
<tt class="xref py py-meth docutils literal"><span class="pre">_handle_Integral()</span></tt>.  Arbitrary constants should be
symbols named <tt class="docutils literal"><span class="pre">C1</span></tt>, <tt class="docutils literal"><span class="pre">C2</span></tt>, and so on.  All solution methods should return
an equality instance.  If you need an arbitrary number of arbitrary constants,
you can use <tt class="docutils literal"><span class="pre">constants</span> <span class="pre">=</span> <span class="pre">numbered_symbols(prefix='C',</span> <span class="pre">cls=Symbol,</span> <span class="pre">start=1)</span></tt>.
If it is possible to solve for the dependent function in a general way, do so.
Otherwise, do as best as you can, but do not call solve in your
<tt class="docutils literal"><span class="pre">ode_&lt;hint&gt;()</span></tt> function.  <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a> will attempt
to solve the solution for you, so you do not need to do that.  Lastly, if your
ODE has a common simplification that can be applied to your solutions, you can
add a special case in <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a> for it.  For
example, solutions returned from the <tt class="docutils literal"><span class="pre">1st_homogeneous_coeff</span></tt> hints often
have many <tt class="xref py py-meth docutils literal"><span class="pre">log()</span></tt> terms, so
<a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a> calls
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.logcombine" title="sympy.simplify.simplify.logcombine"><tt class="xref py py-meth docutils literal"><span class="pre">logcombine()</span></tt></a> on them (it also helps to write
the arbitrary constant as <tt class="docutils literal"><span class="pre">log(C1)</span></tt> instead of <tt class="docutils literal"><span class="pre">C1</span></tt> in this case).  Also
consider common ways that you can rearrange your solution to have
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><tt class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></tt></a> take better advantage of it.  It is
better to put simplification in <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><tt class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></tt></a> than in
your method, because it can then be turned off with the simplify flag in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>.  If you have any extraneous
simplification in your function, be sure to only run it using <tt class="docutils literal"><span class="pre">if</span>
<span class="pre">match.get('simplify',</span> <span class="pre">True):</span></tt>, especially if it can be slow or if it can
reduce the domain of the solution.</p>
<p>Finally, as with every contribution to SymPy, your method will need to be
tested.  Add a test for each method in <tt class="docutils literal"><span class="pre">test_ode.py</span></tt>.  Follow the
conventions there, i.e., test the solver using <tt class="docutils literal"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span>
<span class="pre">hint=your_hint)</span></tt>, and also test the solution using
<a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><tt class="xref py py-meth docutils literal"><span class="pre">checkodesol()</span></tt></a> (you can put these in a separate
tests and skip/XFAIL if it runs too slow/doesn&#8217;t work).  Be sure to call your
hint specifically in <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><tt class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></tt></a>, that way the test
won&#8217;t be broken simply by the introduction of another matching hint.  If your
method works for higher order (&gt;1) ODEs, you will need to run <tt class="docutils literal"><span class="pre">sol</span> <span class="pre">=</span>
<span class="pre">constant_renumber(sol,</span> <span class="pre">'C',</span> <span class="pre">1,</span> <span class="pre">order)</span></tt> for each solution, where <tt class="docutils literal"><span class="pre">order</span></tt> is
the order of the ODE.  This is because <tt class="docutils literal"><span class="pre">constant_renumber</span></tt> renumbers the
arbitrary constants by printing order, which is platform dependent.  Try to
test every corner case of your solver, including a range of orders if it is a
<span class="math">\(n\)</span>th order solver, but if your solver is slow, such as if it involves hard
integration, try to keep the test run time down.</p>
<p>Feel free to refactor existing hints to avoid duplicating code or creating
inconsistencies.  If you can show that your method exactly duplicates an
existing method, including in the simplicity and speed of obtaining the
solutions, then you can remove the old, less general method.  The existing
code is tested extensively in <tt class="docutils literal"><span class="pre">test_ode.py</span></tt>, so if anything is broken, one
of those tests will surely fail.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ODE</a><ul>
<li><a class="reference internal" href="#user-functions">User Functions</a><ul>
<li><a class="reference internal" href="#dsolve"><tt class="docutils literal"><span class="pre">dsolve()</span></tt></a></li>
<li><a class="reference internal" href="#classify-ode"><tt class="docutils literal"><span class="pre">classify_ode()</span></tt></a></li>
<li><a class="reference internal" href="#checkodesol"><tt class="docutils literal"><span class="pre">checkodesol()</span></tt></a></li>
<li><a class="reference internal" href="#homogeneous-order"><tt class="docutils literal"><span class="pre">homogeneous_order()</span></tt></a></li>
<li><a class="reference internal" href="#infinitesimals"><tt class="docutils literal"><span class="pre">infinitesimals()</span></tt></a></li>
<li><a class="reference internal" href="#checkinfsol"><tt class="docutils literal"><span class="pre">checkinfsol()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hint-functions">Hint Functions</a><ul>
<li><a class="reference internal" href="#allhints"><tt class="docutils literal"><span class="pre">allhints</span></tt></a></li>
<li><a class="reference internal" href="#odesimp"><tt class="docutils literal"><span class="pre">odesimp</span></tt></a></li>
<li><a class="reference internal" href="#constant-renumber"><tt class="docutils literal"><span class="pre">constant_renumber</span></tt></a></li>
<li><a class="reference internal" href="#constantsimp"><tt class="docutils literal"><span class="pre">constantsimp</span></tt></a></li>
<li><a class="reference internal" href="#sol-simplicity"><tt class="docutils literal"><span class="pre">sol_simplicity</span></tt></a></li>
<li><a class="reference internal" href="#st-exact"><tt class="docutils literal"><span class="pre">1st_exact</span></tt></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-best"><tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_best</span></tt></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-dep-div-indep"><tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></tt></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-indep-div-dep"><tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></tt></a></li>
<li><a class="reference internal" href="#st-linear"><tt class="docutils literal"><span class="pre">1st_linear</span></tt></a></li>
<li><a class="reference internal" href="#bernoulli"><tt class="docutils literal"><span class="pre">Bernoulli</span></tt></a></li>
<li><a class="reference internal" href="#liouville"><tt class="docutils literal"><span class="pre">Liouville</span></tt></a></li>
<li><a class="reference internal" href="#riccati-special-minus2"><tt class="docutils literal"><span class="pre">Riccati_special_minus2</span></tt></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-homogeneous"><tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous</span></tt></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-undetermined-coefficients"><tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></tt></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-variation-of-parameters"><tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters</span></tt></a></li>
<li><a class="reference internal" href="#separable"><tt class="docutils literal"><span class="pre">separable</span></tt></a></li>
<li><a class="reference internal" href="#almost-linear"><tt class="docutils literal"><span class="pre">almost_linear</span></tt></a></li>
<li><a class="reference internal" href="#linear-coefficients"><tt class="docutils literal"><span class="pre">linear_coefficients</span></tt></a></li>
<li><a class="reference internal" href="#separable-reduced"><tt class="docutils literal"><span class="pre">separable_reduced</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#lie-heuristics">Lie heuristics</a><ul>
<li><a class="reference internal" href="#abaco1-simple"><tt class="docutils literal"><span class="pre">abaco1_simple</span></tt></a></li>
<li><a class="reference internal" href="#abaco1-product"><tt class="docutils literal"><span class="pre">abaco1_product</span></tt></a></li>
<li><a class="reference internal" href="#bivariate"><tt class="docutils literal"><span class="pre">bivariate</span></tt></a></li>
<li><a class="reference internal" href="#chi"><tt class="docutils literal"><span class="pre">chi</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-sympy.solvers.ode">Information on the ode module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../stats.html"
                        title="previous chapter">Stats</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pde.html"
                        title="next chapter">PDE</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/modules/solvers/ode.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pde.html" title="PDE"
             >next</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             >previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" >SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Aug 04, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>