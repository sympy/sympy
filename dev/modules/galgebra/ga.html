

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Geometric Algebra &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../../index.html" />
    <link rel="up" title="Geometric Algebra Module" href="index.html" />
    <link rel="next" title="Manifold for Geometric Algebra" href="manifold.html" />
    <link rel="prev" title="Geometric Algebra Module" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="manifold.html" title="Manifold for Geometric Algebra"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Geometric Algebra Module"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" >SymPy Modules Reference</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Geometric Algebra Module</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <script type="text/javascript" >
    MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
</script><div class="section" id="geometric-algebra">
<h1>Geometric Algebra<a class="headerlink" href="#geometric-algebra" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Alan Bromborsky</td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">Abstract</p>
<p>This document describes the implementation, installation and use of a
geometric algebra module written in
python that utilizes the <a class="reference internal" href="../matrices/immutablematrices.html#module-sympy" title="sympy"><tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt></a> symbolic algebra library.  The python
module <em>galgebra</em> has been developed for coordinate free calculations using
the operations (geometric, outer, and inner products etc.) of geometric algebra.
The operations can be defined using a completely arbitrary metric defined
by the inner products of a set of arbitrary vectors or the metric can be
restricted to enforce orthogonality and signature constraints on the set of
vectors.  In addition the module includes the geometric, outer (curl) and inner
(div) derivatives and the ability to define a curvilinear coordinate system.
The module requires the sympy module and the numpy module for numerical linear
algebra calculations.  For latex output a latex distribution must be installed.</p>
</div>
<span class="target" id="module-sympy.galgebra.ga"></span><div class="section" id="what-is-geometric-algebra">
<h2>What is Geometric Algebra?<a class="headerlink" href="#what-is-geometric-algebra" title="Permalink to this headline">¶</a></h2>
<p>Geometric algebra is the Clifford algebra of a real finite dimensional vector
space or the algebra that results when a real finite dimensional vector space
is extended with a product of vectors (geometric product) that is associative,
left and right distributive, and yields a real number for the square (geometric
product) of any vector <a class="reference internal" href="#hestenes">[Hestenes]</a>, <a class="reference internal" href="#doran">[Doran]</a>.  The elements of the geometric
algebra are called multivectors and consist of the linear combination of
scalars, vectors, and the geometric product of two or more vectors. The
additional axioms for the geometric algebra are that for any vectors <span class="math">\(a\)</span>,
<span class="math">\(b\)</span>, and <span class="math">\(c\)</span> in the base vector space (<a class="reference internal" href="#doran">[Doran]</a>,p85):</p>
<div class="math">
\[\begin{equation*}
\begin{array}{c}
a\left ( bc \right ) = \left ( ab \right ) c \\
a\left ( b+c \right ) = ab+ac \\
\left ( a + b \right ) c = ac+bc \\
aa = a^{2} \in \Re
\end{array}
\end{equation*}\]</div><p>By induction the first three axioms also apply to any multivectors.  The dot product of
two vectors is defined by (<a class="reference internal" href="#doran">[Doran]</a>,p86)</p>
<div class="math">
\[\begin{equation*}
   a\cdot b \equiv (ab+ba)/2
\end{equation*}\]</div><p>Then consider</p>
<div class="math">
\[\begin{align*}
   c &= a+b \\
   c^{2} &= (a+b)^{2} \\
   c^{2} &= a^{2}+ab+ba+b^{2} \\
   a\cdot b &= (c^{2}-a^{2}-b^{2})/2 \in \Re
\end{align*}\]</div><p>Thus <span class="math">\(a\cdot b\)</span>  is real.  The objects generated from linear combinations
of the geometric products of vectors are called multivectors.  If a basis for
the underlying vector space is the set of vectors formed from <span class="math">\(e_{1},\dots,e_{n}\)</span>
a complete basis for the geometric algebra is given by the scalar <span class="math">\(1\)</span>, the vectors <span class="math">\(e_{1},\dots,e_{n}\)</span>
and all geometric products of vectors</p>
<div class="math">
\[\begin{equation*}
   e_{i_{1}} e_{i_{2}} \dots e_{i_{r}} \mbox{ where } 0 \le r \le n \mbox{, } 0 \le i_{j} \le n \mbox{ and } 0 < i_{1} < i_{2} < \dots < i_{r} \le n
\end{equation*}\]</div><p>Each base of the complete basis is represented by a noncommutative symbol (except for the scalar 1)
with name <span class="math">\(e_{i_{1}}\dots e_{i_{r}}\)</span> so that the general multivector <span class="math">\(\boldsymbol{A}\)</span> is represented by
(<span class="math">\(A\)</span> is the scalar part of the multivector and the <span class="math">\(A^{i_{1},\dots,i_{r}}\)</span> are scalars)</p>
<div class="math">
\[\begin{equation*}
   \boldsymbol{A} = A + \sum_{r=1}^{n}\sum_{i_{1},\dots,i_{r},\;\forall\; 0\le i_{j} \le n} A^{i_{1},\dots,i_{r}}e_{i_{1}}e_{i_{2}}\dots e_{r}
\end{equation*}\]</div><p>The critical operation in setting up the geometric algebra is reducing
the geometric product of any two bases to a linear combination of bases so that
we can calculate a multiplication table for the bases.  Since the geometric
product is associative we can use the operation (by definition for two vectors
<span class="math">\(a\cdot b \equiv (ab+ba)/2\)</span>  which is a scalar)</p>
<div class="math" id="equation-5.1">
<span id="eq1"></span>\[\begin{equation}
   e_{i_{j+1}}e_{i_{j}} = 2e_{i_{j+1}}\cdot e_{i_{j}} - e_{i_{j}}e_{i_{j+1}}
\end{equation}\]</div><p>These processes are repeated untill every basis list in <span class="math">\(\boldsymbol{A}\)</span> is in normal
(ascending) order with no repeated elements. As an example consider the
following</p>
<div class="math">
\[\begin{align*}
   e_{3}e_{2}e_{1} &= (2(e_{2}\cdot e_{3}) - e_{2}e_{3})e_{1} \\
                   &= 2(e_{2}\cdot e_{3})e_{1} - e_{2}e_{3}e_{1} \\
                   &= 2(e_{2}\cdot e_{3})e_{1} - e_{2}(2(e_{1}\cdot e_{3})-e_{1}e_{3}) \\
                   &= 2((e_{2}\cdot e_{3})e_{1}-(e_{1}\cdot e_{3})e_{2})+e_{2}e_{1}e_{3} \\
                   &= 2((e_{2}\cdot e_{3})e_{1}-(e_{1}\cdot e_{3})e_{2}+(e_{1}\cdot e_{2})e_{3})-e_{1}e_{2}e_{3}
\end{align*}\]</div><p>which results from repeated application of equation <a class="reference internal" href="#eq1"><em>5.1</em></a>.  If the product of basis vectors contains repeated factors
equation <a class="reference internal" href="#eq1"><em>5.1</em></a> can be used to bring the repeated factors next to one another so that if <span class="math">\(e_{i_{j}} = e_{i_{j+1}}\)</span>
then <span class="math">\(e_{i_{j}}e_{i_{j+1}} = e_{i_{j}}\cdot e_{i_{j+1}}\)</span> which is a scalar that commutes with all the terms in the product
and can be brought to the front of the product.  Since every repeated pair of vectors in a geometric product of <span class="math">\(r\)</span> factors
reduces the number of noncommutative factors in the product by <span class="math">\(r-2\)</span>. The number of bases in the multivector algebra is <span class="math">\(2^{n}\)</span>
and the number containing <span class="math">\(r\)</span> factors is <span class="math">\({n\choose r}\)</span> which is the number of combinations or <span class="math">\(n\)</span> things
taken <span class="math">\(r\)</span> at a time (binominal coefficient).</p>
<p>The other construction required for formulating the geometric algebra is the outer or wedge product (symbol <span class="math">\(\wedge\)</span>) of <span class="math">\(r\)</span>
vectors denoted by <span class="math">\(a_{1}\wedge\dots\wedge a_{r}\)</span>.  The wedge product of <span class="math">\(r\)</span> vectors is called an <span class="math">\(r\)</span>-blade and is defined
by (<a class="reference internal" href="#doran">[Doran]</a>,p86)</p>
<div class="math">
\[\begin{equation*}
   a_{1}\wedge\dots\wedge a_{r} \equiv \sum_{i_{j_{1}}\dots i_{j_{r}}} \epsilon^{i_{j_{1}}\dots i_{j_{r}}}a_{i_{j_{1}}}\dots a_{i_{j_{1}}}
\end{equation*}\]</div><p>where <span class="math">\(\epsilon^{i_{j_{1}}\dots i_{j_{r}}}\)</span> is the contravariant permutation symbol which is <span class="math">\(+1\)</span> for an even permutation of the
superscripts, <span class="math">\(0\)</span> if any superscripts are repeated, and <span class="math">\(-1\)</span> for an odd permutation of the superscripts. From the definition
<span class="math">\(a_{1}\wedge\dots\wedge a_{r}\)</span> is antisymmetric in all its arguments and the following relation for the wedge product of a vector <span class="math">\(a\)</span> and an
<span class="math">\(r\)</span>-blade <span class="math">\(B_{r}\)</span> can be derived</p>
<div class="math" id="equation-5.2">
<span id="eq2"></span>\[\begin{equation}
   a\wedge B_{r} = (aB_{r}+(-1)^{r}B_{r}a)/2
\end{equation}\]</div><p>Using equation <a class="reference internal" href="#eq2"><em>5.2</em></a> one can represent the wedge product of all the basis vectors
in terms of the geometric product of all the basis vectors so that one can solve (the system
of equations is lower diagonal) for the geometric product of all the basis vectors in terms of
the wedge product of all the basis vectors.  Thus a general multivector <span class="math">\(\boldsymbol{B}\)</span> can be
represented as a linear combination of a scalar and the basis blades.</p>
<div class="math">
\[\begin{equation*}
   \boldsymbol{B} = B + \sum_{r=1}^{n}\sum_{i_{1},\dots,i_{r},\;\forall\; 0\le i_{j} \le n} B^{i_{1},\dots,i_{r}}e_{i_{1}}\wedge e_{i_{2}}\wedge\dots\wedge e_{r}
\end{equation*}\]</div><p>Using the blades <span class="math">\(e_{i_{1}}\wedge e_{i_{2}}\wedge\dots\wedge e_{r}\)</span> creates a graded
algebra where <span class="math">\(r\)</span> is the grade of the basis blades.  The grade-<span class="math">\(r\)</span>
part of <span class="math">\(\boldsymbol{B}\)</span> is the linear combination of all terms with
grade <span class="math">\(r\)</span> basis blades. The scalar part of <span class="math">\(\boldsymbol{B}\)</span> is defined to
be grade-<span class="math">\(0\)</span>.  Now that the blade expansion of <span class="math">\(\boldsymbol{B}\)</span> is defined
we can also define the grade projection operator <span class="math">\(\left &lt; {\boldsymbol{B}} \right &gt;_{r}\)</span> by</p>
<div class="math">
\[\begin{equation*}
   \left < {\boldsymbol{B}} \right >_{r} = \sum_{i_{1},\dots,i_{r},\;\forall\; 0\le i_{j} \le n} B^{i_{1},\dots,i_{r}}e_{i_{1}}\wedge e_{i_{2}}\wedge\dots\wedge e_{r}
\end{equation*}\]</div><p>and</p>
<div class="math">
\[\begin{equation*}
   \left < {\boldsymbol{B}} \right >_{} \equiv \left < {\boldsymbol{B}} \right >_{0} = B
\end{equation*}\]</div><p>Then if <span class="math">\(\boldsymbol{A}_{r}\)</span> is an <span class="math">\(r\)</span>-grade multivector and <span class="math">\(\boldsymbol{B}_{s}\)</span> is an <span class="math">\(s\)</span>-grade multivector we have</p>
<div class="math">
\[\begin{equation*}
   \boldsymbol{A}_{r}\boldsymbol{B}_{s} = \left < {\boldsymbol{A}_{r}\boldsymbol{B}_{s}} \right >_{\left |{{r-s}}\right |}+\left < {\boldsymbol{A}_{r}\boldsymbol{B}_{s}} \right >_{\left |{{r-s}}\right |+2}+\cdots
                          \left < {\boldsymbol{A}_{r}\boldsymbol{B}_{s}} \right >_{r+s}
\end{equation*}\]</div><p>and define (<a class="reference internal" href="#hestenes">[Hestenes]</a>,p6)</p>
<div class="math">
\[\begin{align*}
   \boldsymbol{A}_{r}\wedge\boldsymbol{B}_{s} &\equiv \left < {\boldsymbol{A}_{r}\boldsymbol{B}_{s}} \right >_{r+s} \\
   \boldsymbol{A}_{r}\cdot\boldsymbol{B}_{s} &\equiv \left \{ \begin{array}{cc}
   r\mbox{ or }s \ne 0: & \left < {\boldsymbol{A}_{r}\boldsymbol{B}_{s}} \right >_{\left |{{r-s}}\right |}  \\
   r\mbox{ or }s = 0: & 0 \end{array} \right \}
\end{align*}\]</div><p>where <span class="math">\(\boldsymbol{A}_{r}\cdot\boldsymbol{B}_{s}\)</span> is called the dot or inner product of
two pure grade multivectors.  For the case of two non-pure grade multivectors</p>
<blockquote>
<div><div class="math">
\[\begin{align*}
   \boldsymbol{A}\wedge\boldsymbol{B} &= \sum_{r,s}\left < {\boldsymbol{A}} \right >_{r}\wedge\left < {\boldsymbol{B}} \right >_{s} \\
   \boldsymbol{A}\cdot\boldsymbol{B} &= \sum_{r,s\ne 0}\left < {\boldsymbol{A}} \right >_{r}\cdot\left < {\boldsymbol{B}} \right >_{s}
\end{align*}\]</div></div></blockquote>
<p>Two other products, the right (<span class="math">\(\rfloor\)</span>) and left (<span class="math">\(\lfloor\)</span>) contractions, are defined by</p>
<blockquote>
<div><div class="math">
\[\begin{align*}
   \boldsymbol{A}\lfloor\boldsymbol{B} &\equiv \sum_{r,s}\left \{ \begin{array}{cc} \left < {\boldsymbol{A}_r\boldsymbol{B}_{s}} \right >_{r-s} & r \ge s \\
                                               0                                               & r < s \end{array}\right \}  \\
   \boldsymbol{A}\rfloor\boldsymbol{B} &\equiv \sum_{r,s}\left \{ \begin{array}{cc} \left < {\boldsymbol{A}_{r}\boldsymbol{B}_{s}} \right >_{s-r} & s \ge r \\
                                               0                                               & s < r\end{array}\right \}
\end{align*}\]</div></div></blockquote>
<p>A final operation for multivectors is the reverse.  If a multivector <span class="math">\(\boldsymbol{A}\)</span> is the geometric product of <span class="math">\(r\)</span> vectors (versor)
so that <span class="math">\(\boldsymbol{A} = a_{1}\dots a_{r}\)</span> the reverse is defined by</p>
<blockquote>
<div><div class="math">
\[\begin{align*}
   \boldsymbol{A}^{\dagger} \equiv a_{r}\dots a_{1}
\end{align*}\]</div></div></blockquote>
<p>where for a general multivector we have (the the sum of the reverse of versors)</p>
<div class="math">
\[\begin{equation*}
   \boldsymbol{A}^{\dagger} = A + \sum_{r=1}^{n}(-1)^{r(r-1)/2}\sum_{i_{1},\dots,i_{r},\;\forall\; 0\le i_{j} \le n} A^{i_{1},\dots,i_{r}}e_{i_{1}}\wedge e_{i_{2}}\wedge\dots\wedge e_{r}
\end{equation*}\]</div><p>note that if <span class="math">\(\boldsymbol{A}\)</span> is a versor then <span class="math">\(\boldsymbol{A}\boldsymbol{A}^{\dagger}\in\Re\)</span> and (<span class="math">\(AA^{\dagger} \ne 0\)</span>)</p>
<div class="math">
\[\begin{equation*}
   \boldsymbol{A}^{-1} = {\displaystyle\frac{\boldsymbol{A}^{\dagger}}{\boldsymbol{AA}^{\dagger}}}
\end{equation*}\]</div></div>
<div class="section" id="representation-of-multivectors-in-sympy">
<h2>Representation of Multivectors in Sympy<a class="headerlink" href="#representation-of-multivectors-in-sympy" title="Permalink to this headline">¶</a></h2>
<p>The sympy python module offers a simple way of representing multivectors using linear
combinations of commutative expressions (expressions consisting only of commuting sympy objects)
and noncommutative symbols. We start by defining <span class="math">\(n\)</span> noncommutative sympy symbols</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">e_1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">e_n</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;e_1,...,e_n&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Several software packages for numerical geometric algebra calculations are
available from Doran-Lasenby group and the Dorst group. Symbolic packages for
Clifford algebra using orthongonal bases such as
<span class="math">\(e_{i}e_{j}+e_{j}e_{i} = 2\eta_{ij}\)</span>, where <span class="math">\(\eta_{ij}\)</span> is a numeric
array are available in Maple and Mathematica. The symbolic algebra module,
<em>galgebra</em>, developed for python does not depend on an orthogonal basis
representation, but rather is generated from a set of <span class="math">\(n\)</span> arbitrary
symbolic vectors,  <span class="math">\(e_{1},e_{2},\dots,e_{n}\)</span> and a symbolic metric
tensor <span class="math">\(g_{ij} = e_{i}\cdot e_{j}\)</span>.</p>
<p>In order not to reinvent the wheel all scalar symbolic algebra is handled by the
python module  <a class="reference internal" href="../matrices/immutablematrices.html#module-sympy" title="sympy"><tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt></a> and the abstract basis vectors are encoded as
noncommuting sympy symbols.</p>
<p>The basic geometic algebra operations will be implemented in python by defining
a multivector class, MV, and overloading the python operators in Table
<a class="reference internal" href="#table1"><em>5.1</em></a> where <em>A</em> and <em>B</em>  are any two multivectors (In the case of
<em>+</em>, <em>-</em>, <em>*</em>, <em>^</em>, and <em>|</em> the operation is also defined if <em>A</em> or
<em>B</em> is a sympy symbol or a sympy real number).</p>
<blockquote>
<div><table border="1" class="docutils" id="table1">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8216;&#8217;A+B&#8217;&#8216;</td>
<td>sum of multivectors</td>
</tr>
<tr class="row-odd"><td>&#8216;&#8217;A-B&#8217;&#8216;</td>
<td>difference of multivectors</td>
</tr>
<tr class="row-even"><td>&#8216;&#8217;A*B&#8217;&#8216;</td>
<td>geometric product</td>
</tr>
<tr class="row-odd"><td>&#8216;&#8217;A^B&#8217;&#8216;</td>
<td>outer product of multivectors</td>
</tr>
<tr class="row-even"><td>&#8216;&#8217;A|B&#8217;&#8216;</td>
<td>inner product of multivectors</td>
</tr>
<tr class="row-odd"><td>&#8216;&#8217;A&lt;B&#8217;&#8216;</td>
<td>left contraction of multivectors</td>
</tr>
<tr class="row-even"><td>&#8216;&#8217;A&gt;B&#8217;&#8216;</td>
<td>right contraction of multivectors</td>
</tr>
</tbody>
</table>
<p>Table <a class="reference internal" href="#table1"><em>5.1</em></a>. Multivector operations for <em>galgebra</em></p>
</div></blockquote>
<p>Since <em>&lt;</em> and <em>&gt;</em> have no r-forms (in python for the <em>&lt;</em> and <em>&gt;</em> operators there are no <em>__rlt__()</em> and <em>__rlt__()</em> member functions to overload)
we can only have mixed modes (scalars and multivectors) if the first operand is a multivector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Except for <em>&lt;</em> and <em>&gt;</em> all the multivector operators have r-forms so that as long as one of the
operands, left or right, is a multivector the other can be a multivector or a scalar (sympy symbol or integer).</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that the operator order precedence is determined by python and is not
necessarily that used by geometric algebra. It is <strong>absolutely essential</strong> to
use parenthesis in multivector
expressions containing <em>^</em>, <em>|</em>, <em>&lt;</em>, and/or <em>&gt;</em>.  As an example let
<em>A</em> and <em>B</em> be any two multivectors. Then <em>A + A*B = A +(A*B)</em>, but
<em>A+A^B = (2*A)^B</em> since in python the <em>^</em> operator has a lower precedence
than the &#8216;+&#8217; operator.  In geometric algebra the outer and inner products and
the left and right contractions have a higher precedence than the geometric
product and the geometric product has a higher precedence than addition and
subtraction.  In python the <em>^</em>, <em>|</em>, <em>&lt;</em>, and <em>&gt;</em> all have a lower
precedence than <em>+</em> and <em>-</em> while <em>*</em> has a higher precedence than
<em>+</em> and <em>-</em>.</p>
</div>
<p>For those users who wish to define a default operator precedence the functions
<em>define_precedence()</em> and <em>GAeval()</em> are available in the module <em>galgebra/precedence</em>.</p>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.precedence.define_precedence">
<tt class="descclassname">sympy.galgebra.precedence.</tt><tt class="descname">define_precedence</tt><big>(</big><em>gd</em>, <em>op_ord='&lt;&gt;|</em>, <em>^</em>, <em>*'</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.precedence.define_precedence" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the precedence of the multivector operations.  The function
<em>define_precedence()</em> must be called from the main program and the
first argument <em>gd</em> must be set to <em>globals()</em>.  The second argument
<em>op_ord</em> determines the operator precedence for expressions input to
the function <em>GAeval()</em>. The default value of <em>op_ord</em> is <em>&#8216;&lt;&gt;|,^,*&#8217;</em>.
For the default value the <em>&lt;</em>, <em>&gt;</em>, and <em>|</em> operations have equal
precedence followed by <em>^</em>, and <em>^</em> is followed by <em>*</em>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.precedence.GAeval">
<tt class="descclassname">sympy.galgebra.precedence.</tt><tt class="descname">GAeval</tt><big>(</big><em>s</em>, <em>pstr=False</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.precedence.GAeval" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <em>GAeval()</em> returns a multivector expression defined by the
string <em>s</em> where the operations in the string are parsed according to
the precedences defined by <em>define_precedence()</em>.  <em>pstr</em> is a flag
to print the input and output of <em>GAeval()</em> for debugging purposes.
<em>GAeval()</em> works by adding parenthesis to the input string <em>s</em> with the
precedence defined by <em>op_ord=&#8217;&lt;&gt;|,^,*&#8217;</em>.  Then the parsed string is
converted to a sympy expression using the python <em>eval()</em> function.
For example consider where <em>X</em>, <em>Y</em>, <em>Z</em>, and <em>W</em> are multivectors</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">define_precedence</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">GAeval</span><span class="p">(</span><span class="s">&#39;X|Y^Z*W&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The sympy variable <em>V</em> would evaluate to <em>((X|Y)^Z)*W</em>.</p>
</dd></dl>

</div>
<div class="section" id="vector-basis-and-metric">
<span id="vbm"></span><h2>Vector Basis and Metric<a class="headerlink" href="#vector-basis-and-metric" title="Permalink to this headline">¶</a></h2>
<p>The two structures that define the <tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt> (multivector) class are the
symbolic basis vectors and the symbolic metric.  The symbolic basis
vectors are input as a string with the symbol name separated by spaces.  For
example if we are calculating the geometric algebra of a system with three
vectors that we wish to denote as <em>a0</em>, <em>a1</em>, and <em>a2</em> we would define the
string variable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;a0 a1 a2&#39;</span>
</pre></div>
</div>
<p>that would be input into the multivector setup function.  The next step would be
to define the symbolic metric for the geometric algebra of the basis we
have defined. The default metric is the most general and is the matrix of
the following symbols</p>
<div class="math" id="equation-3">
<span id="eq3"></span>\[\begin{equation}
g = \left [
\begin{array}{ccc}
  (a0.a0)   & (a0.a1)  & (a0.a2) \\
  (a0.a1) & (a1.a1)  & (a1.a2) \\
  (a0.a2) & (a1.a2) & (a2.a2) \\
\end{array}
\right ]
\end{equation}\]</div><p>where each of the <span class="math">\(g_{ij}\)</span> is a symbol representing all of the dot
products of the basis vectors. Note that the symbols are named so that
<span class="math">\(g_{ij} = g_{ji}\)</span> since for the symbol function
<span class="math">\((a0.a1) \ne (a1.a0)\)</span>.</p>
<p>Note that the strings shown in equation <a class="reference internal" href="#eq3"><em>5.3</em></a> are only used when the values
of <span class="math">\(g_{ij}\)</span> are output (printed).   In the <em>galgebra</em> module (library)
the <span class="math">\(g_{ij}\)</span> symbols are stored in a static member of the multivector
class <tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt> as the sympy matrix <em>MV.metric</em> (<span class="math">\(g_{ij}\)</span> = <em>MV.metric[i,j]</em>).</p>
<p>The default definition of <span class="math">\(g\)</span> can be overwritten by specifying a string
that will define <span class="math">\(g\)</span>. As an example consider a symbolic representation
for conformal geometry. Define for a basis</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;a0 a1 a2 n nbar&#39;</span>
</pre></div>
</div>
<p>and for a metric</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;# # # 0 0, # # # 0 0, # # # 0 0, 0 0 0 0 2, 0 0 0 2 0&#39;</span>
</pre></div>
</div>
<p>then calling <em>MV.setup(basis,metric)</em> would initialize the metric tensor</p>
<div class="math">
\[\begin{equation*}
g = \left [
\begin{array}{ccccc}
  (a0.a0) & (a0.a1)  & (a0.a2) & 0 & 0\\
  (a0.a1) & (a1.a1)  & (a1.a2) & 0 & 0\\
  (a0.a2) & (a1.a2)  & (a2.a2) & 0 & 0 \\
  0 & 0 & 0 & 0 & 2 \\
  0 & 0 & 0 & 2 & 0
\end{array}
\right ]
\end{equation*}\]</div><p>Here we have specified that <em>n</em> and <em>nbar</em> are orthonal to all the
<em>a</em>&#8216;s, <em>(n.n) = (nbar.nbar) = 0</em>, and <em>(n.nbar) = 2</em>. Using
<em>#</em> in the metric definition string just tells the program to use the
default symbol for that value.</p>
<p>When <em>MV.setup</em> is called multivector representations of the basis local to
the program are instantiated.  For our first example that means that the
symbolic vectors named <em>a0</em>, <em>a1</em>, and <em>a2</em> are created and returned from
<em>MV.setup</em> via a tuple as in -</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">a_1</span><span class="p">,</span><span class="n">a_2</span><span class="p">,</span><span class="n">a3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;a_1 a_2 a_3&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the python variable name for a basis vector does not have to
correspond to the name give in <em>MV.setup()</em>, one may wish to use a
shorted python variable name to reduce programming (typing) errors, for
example one could use -</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;a_1 a_2 a_3&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma_1 gamma_2 gamma_3&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
</pre></div>
</div>
<p>so that if the latex printer is used <em>e1</em> would print as <span class="math">\(\boldsymbol{e_{1}}\)</span>
and <em>g1</em> as <span class="math">\(\boldsymbol{\gamma_{1}}\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Additionally <em>MV.setup</em> has simpified options for naming a set of basis vectors and for
inputing an othogonal basis.</p>
<p>If one wishes to name the basis vectors <span class="math">\(\boldsymbol{e}_{x}\)</span>, <span class="math">\(\boldsymbol{e}_{y}\)</span>, and
<span class="math">\(\boldsymbol{e}_{z}\)</span> then set <em>basis=&#8217;e*x|y|z&#8217;</em> or to name <span class="math">\(\boldsymbol{\gamma}_{t}\)</span>,
<span class="math">\(\boldsymbol{\gamma}_{x}\)</span>, <span class="math">\(\boldsymbol{\gamma}_{y}\)</span>, and <span class="math">\(\boldsymbol{\gamma}_{z}\)</span> then set
<em>basis=&#8217;gamma*t|x|y|z&#8217;</em>.</p>
<p class="last">For the case of an othogonal basis if the signature of the
vector space is <span class="math">\((1,1,1)\)</span> (Euclidian 3-space) set <em>metric=&#8217;[1,1,1]&#8217;</em> or if it
is <span class="math">\((1,-1,-1,-1)\)</span> (Minkowsi 4-space) set <em>metric=&#8217;[1,-1,-1,-1]&#8217;</em>.</p>
</div>
</div>
<div class="section" id="representation-and-reduction-of-multivector-bases">
<h2>Representation and Reduction of Multivector Bases<a class="headerlink" href="#representation-and-reduction-of-multivector-bases" title="Permalink to this headline">¶</a></h2>
<p>In our symbolic geometric algebra all multivectors
can be obtained from the symbolic basis vectors we have input, via the
different operations available to geometric algebra. The first problem we have
is representing the general multivector in terms terms of the basis vectors.  To
do this we form the ordered geometric products of the basis vectors and develop
an internal representation of these products in terms of python classes.  The
ordered geometric products are all multivectors of the form
<span class="math">\(a_{i_{1}}a_{i_{2}}\dots a_{i_{r}}\)</span> where <span class="math">\(i_{1}&lt;i_{2}&lt;\dots &lt;i_{r}\)</span>
and <span class="math">\(r \le n\)</span>. We call these multivectors bases and represent them
internally with noncommutative symbols so for example <span class="math">\(a_{1}a_{2}a_{3}\)</span>
is represented by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a_1*a_2*a_3&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>In the simplist case of two basis vectors <em>a_1</em> and <em>a_2</em> we have a list of
bases</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MV</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;ONE&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)],[</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a_1&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>\
             <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a_2&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)],[</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a_1*a_2&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The reason that the base for the scalar component of the multivector is defined as
<em>Symbol(&#8216;ONE&#8217;,commutative=False)</em>, a noncommutative symbol is because of the
properties of the left and right contraction operators which are non commutative
if one is contracting a multivector with a scalar.</p>
</div>
<p>For the case of the basis blades we have</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MV</span><span class="o">.</span><span class="n">blades</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;ONE&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)],[</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a_1&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>\
             <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a_2&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)],[</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a_1^a_2&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For all grades/pseudo-grades greater than one (vectors) the &#8216;*&#8217; in the name of the base symbol is
replaced with a &#8216;^&#8217; in the name of the blade symbol so that for all basis bases and
blades of grade/pseudo-grade greater than one there are different symbols for the corresponding
bases and blades.</p>
</div>
<p>The function that builds all the required arrays and dictionaries upto the base multiplication
table is shown below.  <em>MV.dim</em> is the number of basis vectors and the <em>combinations</em>
functions from <em>itertools</em> constructs the index tupels for the bases of each pseudo grade.
Then the noncommutative symbol representing each base is constructed from each index tuple.
<em>MV.ONE</em> is the noncommutative symbol for the scalar base.  For example if <em>MV.dim = 3</em>
then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MV</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">((),((</span><span class="mi">0</span><span class="p">,),(</span><span class="mi">1</span><span class="p">,),(</span><span class="mi">2</span><span class="p">,)),((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the case that the metric tensor is diagonal (orthogonal basis vectors) both base and blade
bases are identical and fewer arrays and dictionaries need to be constructed.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">build_base_blade_arrays</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">[()]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c">#Set up base and blade and index arrays</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">is_orthogonal</span><span class="p">:</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">bases_flat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">bases</span>  <span class="o">=</span> <span class="p">[</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">]</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">base_to_index</span>  <span class="o">=</span> <span class="p">{</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">:()}</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">index_to_base</span>  <span class="o">=</span> <span class="p">{():</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">}</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">base_grades</span>    <span class="o">=</span> <span class="p">{</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">base_grades</span><span class="p">[</span><span class="n">ONE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">MV</span><span class="o">.</span><span class="n">blades</span> <span class="o">=</span> <span class="p">[</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">]</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">blades_flat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">blade_grades</span>    <span class="o">=</span> <span class="p">{</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">blade_grades</span><span class="p">[</span><span class="n">ONE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">blade_to_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">:()}</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">index_to_blade</span> <span class="o">=</span> <span class="p">{():</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">}</span>

    <span class="n">ig</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#pseudo grade and grade index</span>
    <span class="k">for</span> <span class="n">igrade</span> <span class="ow">in</span> <span class="n">MV</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">is_orthogonal</span><span class="p">:</span>
            <span class="n">bases</span>     <span class="o">=</span> <span class="p">[]</span> <span class="c">#base symbol array within pseudo grade</span>
        <span class="n">blades</span>    <span class="o">=</span> <span class="p">[]</span> <span class="c">#blade symbol array within grade</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#base index within grade</span>
        <span class="k">for</span> <span class="n">ibase</span> <span class="ow">in</span> <span class="n">igrade</span><span class="p">:</span>
            <span class="c">#build base name string</span>
            <span class="p">(</span><span class="n">base_sym</span><span class="p">,</span><span class="n">base_str</span><span class="p">,</span><span class="n">blade_sym</span><span class="p">,</span><span class="n">blade_str</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">make_base_blade_symbol</span><span class="p">(</span><span class="n">ibase</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">is_orthogonal</span><span class="p">:</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base_sym</span><span class="p">)</span>
                <span class="n">MV</span><span class="o">.</span><span class="n">bases_flat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base_sym</span><span class="p">)</span>

            <span class="n">blades</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blade_sym</span><span class="p">)</span>
            <span class="n">MV</span><span class="o">.</span><span class="n">blades_flat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blade_sym</span><span class="p">)</span>
            <span class="n">base_index</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">ig</span><span class="p">][</span><span class="n">ib</span><span class="p">]</span>

            <span class="c">#Add to dictionarys relating symbols and indexes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">is_orthogonal</span><span class="p">:</span>
                <span class="n">MV</span><span class="o">.</span><span class="n">base_to_index</span><span class="p">[</span><span class="n">base_sym</span><span class="p">]</span>   <span class="o">=</span> <span class="n">base_index</span>
                <span class="n">MV</span><span class="o">.</span><span class="n">index_to_base</span><span class="p">[</span><span class="n">base_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_sym</span>
                <span class="n">MV</span><span class="o">.</span><span class="n">base_grades</span><span class="p">[</span><span class="n">base_sym</span><span class="p">]</span>     <span class="o">=</span> <span class="n">ig</span>

            <span class="n">MV</span><span class="o">.</span><span class="n">blade_to_index</span><span class="p">[</span><span class="n">blade_sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_index</span>
            <span class="n">MV</span><span class="o">.</span><span class="n">index_to_blade</span><span class="p">[</span><span class="n">base_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">blade_sym</span>
            <span class="n">MV</span><span class="o">.</span><span class="n">blade_grades</span><span class="p">[</span><span class="n">blade_sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">ig</span>

            <span class="n">ib</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ig</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">is_orthogonal</span><span class="p">:</span>
            <span class="n">MV</span><span class="o">.</span><span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bases</span><span class="p">))</span>

        <span class="n">MV</span><span class="o">.</span><span class="n">blades</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">blades</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">is_orthogonal</span><span class="p">:</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">bases</span>       <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">bases</span><span class="p">)</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">bases_flat</span>  <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">bases_flat</span><span class="p">)</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">bases_flat1</span> <span class="o">=</span> <span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">,)</span><span class="o">+</span><span class="n">MV</span><span class="o">.</span><span class="n">bases_flat</span>
        <span class="n">MV</span><span class="o">.</span><span class="n">bases_set</span>   <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">bases_flat</span><span class="p">[</span><span class="n">MV</span><span class="o">.</span><span class="n">dim</span><span class="p">:])</span>

    <span class="n">MV</span><span class="o">.</span><span class="n">blades</span>       <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">blades</span><span class="p">)</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">blades_flat</span>  <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">blades_flat</span><span class="p">)</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">blades_flat1</span> <span class="o">=</span> <span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">ONE</span><span class="p">,)</span><span class="o">+</span><span class="n">MV</span><span class="o">.</span><span class="n">blades_flat</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">blades_set</span>   <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">blades_flat</span><span class="p">[</span><span class="n">MV</span><span class="o">.</span><span class="n">dim</span><span class="p">:])</span>

    <span class="k">return</span>
</pre></div>
</div>
</div>
<div class="section" id="base-representation-of-multivectors">
<h2>Base Representation of Multivectors<a class="headerlink" href="#base-representation-of-multivectors" title="Permalink to this headline">¶</a></h2>
<p>In terms of the bases defined as noncommutative sympy symbols the general multivector
is a linear combination (scalar sympy coefficients) of bases so that for the case
of two bases the most general multivector is given by -</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">A_0</span><span class="o">*</span><span class="n">MV</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">A__1</span><span class="o">*</span><span class="n">MV</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">A__2</span><span class="o">*</span><span class="n">MV</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">A__12</span><span class="o">*</span><span class="n">MV</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>If we have another multivector <em>B</em> to multiply with <em>A</em> we can calculate the product in
terms of a linear combination of bases if we have a multiplication table for the bases.</p>
</div>
<div class="section" id="blade-representation-of-multivectors">
<h2>Blade Representation of Multivectors<a class="headerlink" href="#blade-representation-of-multivectors" title="Permalink to this headline">¶</a></h2>
<p>Since we can now calculate the symbolic geometric product of any two
multivectors we can also calculate the blades corresponding to the product of
the symbolic basis vectors using the formula</p>
<div class="math">
\[\begin{equation*}
  A_{r}\wedge b = \frac{1}{2}\left ( A_{r}b-\left ( -1 \right )^{r}bA_{r} \right ),
\end{equation*}\]</div><p>where <span class="math">\(A_{r}\)</span> is a multivector of grade <span class="math">\(r\)</span> and <span class="math">\(b\)</span> is a
vector.  For our example basis the result is shown in Table <a class="reference internal" href="#table3"><em>5.3</em></a>.</p>
<div class="highlight-python" id="table3"><pre>1 = 1
a0 = a0
a1 = a1
a2 = a2
a0^a1 = {-(a0.a1)}1+a0a1
a0^a2 = {-(a0.a2)}1+a0a2
a1^a2 = {-(a1.a2)}1+a1a2
a0^a1^a2 = {-(a1.a2)}a0+{(a0.a2)}a1+{-(a0.a1)}a2+a0a1a2</pre>
</div>
<p>Table <a class="reference internal" href="#table3"><em>5.3</em></a>. Bases blades in terms of bases.</p>
<p>The important thing to notice about Table <a class="reference internal" href="#table3"><em>5.3</em></a> is that it is a
triagonal (lower triangular) system of equations so that using a simple back
substitution algorithm we can solve for the pseudo bases in terms of the blades
giving Table <a class="reference internal" href="#table4"><em>5.4</em></a>.</p>
<div class="highlight-python" id="table4"><pre>1 = 1
a0 = a0
a1 = a1
a2 = a2
a0a1 = {(a0.a1)}1+a0^a1
a0a2 = {(a0.a2)}1+a0^a2
a1a2 = {(a1.a2)}1+a1^a2
a0a1a2 = {(a1.a2)}a0+{-(a0.a2)}a1+{(a0.a1)}a2+a0^a1^a2</pre>
</div>
<p>Table <a class="reference internal" href="#table4"><em>5.4</em></a>. Bases in terms of basis blades.</p>
<p>Using Table <a class="reference internal" href="#table4"><em>5.4</em></a> and simple substitution we can convert from a base
multivector representation to a blade representation.  Likewise, using Table
<a class="reference internal" href="#table3"><em>5.3</em></a> we can convert from blades to bases.</p>
<p>Using the blade representation it becomes simple to program functions that will
calculate the grade projection, reverse, even, and odd multivector functions.</p>
<p>Note that in the multivector class <em>MV</em> there is a class variable for each
instantiation, <em>self.bladeflg</em>, that is set to <em>False</em> for a base representation
and <em>True</em> for a blade representation.  One needs to keep track of which
representation is in use since various multivector operations require conversion
from one representation to the other.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When the geometric product of two multivectors is calculated the module looks to
see if either multivector is in blade representation.  If either is the result of
the geometric product is converted to a blade representation.  One result of this
is that if either of the multivectors is a simple vector (which is automatically a
blade) the result will be in a blade representation.  If <em>a</em> and <em>b</em> are vectors
then the result <em>a*b</em> will be <em>(a.b)+a^b</em> or simply <em>a^b</em> if <em>(a.b) = 0</em>.</p>
</div>
</div>
<div class="section" id="outer-and-inner-products-left-and-right-contractions">
<h2>Outer and Inner Products, Left and Right Contractions<a class="headerlink" href="#outer-and-inner-products-left-and-right-contractions" title="Permalink to this headline">¶</a></h2>
<p>In geometric algebra any general multivector <span class="math">\(A\)</span> can be decomposed into
pure grade multivectors (a linear combination of blades of all the same order)
so that in a <span class="math">\(n\)</span>-dimensional vector space</p>
<div class="math">
\[\begin{equation*}
A = \sum_{r = 0}^{n}A_{r}
\end{equation*}\]</div><p>The geometric product of two pure grade multivectors <span class="math">\(A_{r}\)</span> and
<span class="math">\(B_{s}\)</span> has the form</p>
<div class="math">
\[\begin{equation*}
A_{r}B_{s} = \left < {A_{r}B_{s}} \right >_{\left |{{r-s}}\right |}+\left < {A_{r}B_{s}} \right >_{\left |{{r-s}}\right |+2}+\cdots+\left < {A_{r}B_{s}} \right >_{r+s}
\end{equation*}\]</div><p>where <span class="math">\(\left &lt; { } \right &gt;_{t}\)</span> projects the <span class="math">\(t\)</span> grade components of the
multivector argument.  The inner and outer products of <span class="math">\(A_{r}\)</span> and
<span class="math">\(B_{s}\)</span> are then defined to be</p>
<div class="math">
\[\begin{equation*}
A_{r}\cdot B_{s} = \left < {A_{r}B_{s}} \right >_{\left |{{r-s}}\right |}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A_{r}\wedge B_{s} = \left < {A_{r}B_{s}} \right >_{r+s}
\end{equation*}\]</div><p>and</p>
<div class="math">
\[\begin{equation*}
A\cdot B = \sum_{r,s}A_{r}\cdot B_{s}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A\wedge B = \sum_{r,s}A_{r}\wedge B_{s}
\end{equation*}\]</div><p>Likewise the right (<span class="math">\(\lfloor\)</span>) and left (<span class="math">\(\rfloor\)</span>) contractions are defined as</p>
<div class="math">
\[\begin{equation*}
A_{r}\lfloor B_{s} = \left \{ \begin{array}{cc}
   \left < {A_{r}B_{s}} \right >_{r-s} &  r \ge s \\
             0            &  r < s \end{array} \right \}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A_{r}\rfloor B_{s} = \left \{ \begin{array}{cc}
   \left < {A_{r}B_{s}} \right >_{s-r} &  s \ge r \\
             0            &  s < r \end{array} \right \}
\end{equation*}\]</div><p>and</p>
<div class="math">
\[\begin{equation*}
A\lfloor B = \sum_{r,s}A_{r}\lfloor B_{s}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A\rfloor B = \sum_{r,s}A_{r}\rfloor B_{s}
\end{equation*}\]</div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In the  <em>MV</em> class we have overloaded the <em>^</em> operator to represent the outer
product so that instead of calling the outer product function we can write <em>mv1^ mv2</em>.
Due to the precedence rules for python it is <strong>absolutely essential</strong> to enclose outer products
in parenthesis.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In the <em>MV</em> class we have overloaded the <em>|</em> operator for the inner product,
<em>&gt;</em> operator for the right contraction, and <em>&lt;</em> operator for the left contraction.
Instead of calling the inner product function we can write <em>mv1|mv2</em>, <em>mv1&gt;mv2</em>, or
<em>mv1&lt;mv2</em> respectively for the inner product, right contraction, or left contraction.
Again, due to the precedence rules for python it is <strong>absolutely essential</strong> to enclose inner
products and/or contractions in parenthesis.</p>
</div>
</div>
<div class="section" id="reverse-of-multivector">
<span id="reverse"></span><h2>Reverse of Multivector<a class="headerlink" href="#reverse-of-multivector" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math">\(A\)</span> is the geometric product of <span class="math">\(r\)</span> vectors</p>
<div class="math">
\[\begin{equation*}
  A = a_{1}\dots a_{r}
\end{equation*}\]</div><p>then the reverse of <span class="math">\(A\)</span> designated <span class="math">\(A^{\dagger}\)</span> is defined by</p>
<div class="math">
\[\begin{equation*}
  A^{\dagger} \equiv a_{r}\dots a_{1}.
\end{equation*}\]</div><p>The reverse is simply the product with the order of terms reversed.  The reverse
of a sum of products is defined as the sum of the reverses so that for a general
multivector A we have</p>
<div class="math">
\[\begin{equation*}
  A^{\dagger} = \sum_{i=0}^{N} {\left < {A} \right >_{i}}^{\dagger}
\end{equation*}\]</div><p>but</p>
<div class="math" id="equation-5.4">
<span id="eq4"></span>\[\begin{equation}
  {\left < {A} \right >_{i}}^{\dagger} = \left ( -1\right )^{\frac{i\left ( i-1\right )}{2}}\left < {A} \right >_{i}
\end{equation}\]</div><p>which is proved by expanding the blade bases in terms of orthogonal vectors and
showing that equation <a class="reference internal" href="#eq4"><em>5.4</em></a> holds for the geometric product of orthogonal
vectors.</p>
<p>The reverse is important in the theory of rotations in <span class="math">\(n\)</span>-dimensions.  If
<span class="math">\(R\)</span> is the product of an even number of vectors and <span class="math">\(RR^{\dagger} = 1\)</span>
then <span class="math">\(RaR^{\dagger}\)</span> is a composition of rotations of the vector <span class="math">\(a\)</span>.
If <span class="math">\(R\)</span> is the product of two vectors then the plane that <span class="math">\(R\)</span> defines
is the plane of the rotation.  That is to say that <span class="math">\(RaR^{\dagger}\)</span> rotates the
component of <span class="math">\(a\)</span> that is projected into the plane defined by <span class="math">\(a\)</span> and
<span class="math">\(b\)</span> where <span class="math">\(R=ab\)</span>.  <span class="math">\(R\)</span> may be written
<span class="math">\(R = e^{\frac{\theta}{2}U}\)</span>, where <span class="math">\(\theta\)</span> is the angle of rotation
and <span class="math">\(u\)</span> is a unit blade <span class="math">\(\left ( u^{2} = \pm 1\right )\)</span> that defines the
plane of rotation.</p>
</div>
<div class="section" id="reciprocal-frames">
<span id="recframe"></span><h2>Reciprocal Frames<a class="headerlink" href="#reciprocal-frames" title="Permalink to this headline">¶</a></h2>
<p>If we have <span class="math">\(M\)</span> linearly independent vectors (a frame),
<span class="math">\(a_{1},\dots,a_{M}\)</span>, then the reciprocal frame is
<span class="math">\(a^{1},\dots,a^{M}\)</span> where <span class="math">\(a_{i}\cdot a^{j} = \delta_{i}^{j}\)</span>,
<span class="math">\(\delta_{i}^{j}\)</span> is the Kronecker delta (zero if <span class="math">\(i \ne j\)</span> and one
if <span class="math">\(i = j\)</span>). The reciprocal frame is constructed as follows:</p>
<div class="math">
\[\begin{equation*}
  E_{M} = a_{1}\wedge\dots\wedge a_{M}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
  E_{M}^{-1} = {\displaystyle\frac{E_{M}}{E_{M}^{2}}}
\end{equation*}\]</div><p>Then</p>
<div class="math">
\[\begin{equation*}
  a^{i} = \left ( -1\right )^{i-1}\left ( a_{1}\wedge\dots\wedge \breve{a}_{i} \wedge\dots\wedge a_{M}\right ) E_{M}^{-1}
\end{equation*}\]</div><p>where <span class="math">\(\breve{a}_{i}\)</span> indicates that <span class="math">\(a_{i}\)</span> is to be deleted from
the product.  In the standard notation if a vector is denoted with a subscript
the reciprocal vector is denoted with a superscript. The multivector setup
function <em>MV.setup(basis,metric,rframe)</em> has the argument <em>rframe</em> with a
default value of <em>False</em>.  If it is set to <em>True</em> the reciprocal frame of
the basis vectors is calculated. Additionally there is the function
<em>reciprocal_frame(vlst,names=&#8217;&#8216;)</em> external to the <em>MV</em> class that will
calculate the reciprocal frame of a list, <em>vlst</em>, of vectors.  If the argument
<em>names</em> is set to a space delimited string of names for the vectors the
reciprocal vectors will be given these names.</p>
</div>
<div class="section" id="geometric-derivative">
<span id="deriv"></span><h2>Geometric Derivative<a class="headerlink" href="#geometric-derivative" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math">\(F\)</span> is a multivector field that is a function of a vector
<span class="math">\(x = x^{i}\boldsymbol{e}_{i}\)</span> (we are using the summation convention that
pairs of subscripts and superscripts are summed over the dimension of the vector
space) then the geometric derivative <span class="math">\(\nabla F\)</span> is given by (in this
section the summation convention is used):</p>
<div class="math">
\[\begin{equation*}
  \nabla F = \boldsymbol{e}^{i}{\displaystyle\frac{\partial F}{\partial x^{i}}}
\end{equation*}\]</div><p>If <span class="math">\(F_{R}\)</span> is a grade-<span class="math">\(R\)</span> multivector and
<span class="math">\(F_{R} = F_{R}^{i_{1}\dots i_{R}}\boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{R}}\)</span>
then</p>
<div class="math">
\[\begin{equation*}
  \nabla F_{R} = {\displaystyle\frac{\partial F_{R}^{i_{1}\dots i_{R}}}{\partial x^{j}}}\boldsymbol{e}^{j}\left (\boldsymbol{e}_{i_{1}}\wedge
               \dots\wedge \boldsymbol{e}_{i_{R}} \right )
\end{equation*}\]</div><p>Note that
<span class="math">\(\boldsymbol{e}^{j}\left (\boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{R}} \right )\)</span>
can only contain grades <span class="math">\(R-1\)</span> and <span class="math">\(R+1\)</span> so that <span class="math">\(\nabla F_{R}\)</span>
also can only contain those grades. For a grade-<span class="math">\(R\)</span> multivector
<span class="math">\(F_{R}\)</span> the inner (div) and outer (curl) derivatives are defined as</p>
<div class="math">
\[\begin{equation*}
\nabla\cdot F_{R} = \left < \nabla F_{R}\right >_{R-1}
\end{equation*}\]</div><p>and</p>
<div class="math">
\[\begin{equation*}
\nabla\wedge F_{R} = \left < \nabla F_{R}\right >_{R+1}
\end{equation*}\]</div><p>For a general multivector function <span class="math">\(F\)</span> the inner and outer derivatives are
just the sum of the inner and outer dervatives of each grade of the multivector
function.</p>
<p>Curvilinear coordinates are derived from a vector function
<span class="math">\(x(\boldsymbol{\theta})\)</span> where
<span class="math">\(\boldsymbol{\theta} = \left (\theta_{1},\dots,\theta_{N}\right )\)</span> where the number of
coordinates is equal to the dimension of the vector space.  In the case of
3-dimensional spherical coordinates <span class="math">\(\boldsymbol{\theta} = \left ( r,\theta,\phi \right )\)</span>
and the coordinate generating function <span class="math">\(x(\boldsymbol{\theta})\)</span> is</p>
<div class="math">
\[\begin{equation*}
x =  r \cos\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{x}}}+ r \sin\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{y}}}+ r \cos\left({\theta}\right){\boldsymbol{{e}_{z}}}
\end{equation*}\]</div><p>A coordinate frame is derived from <span class="math">\(x\)</span> by
<span class="math">\(\boldsymbol{e}_{i} = {\displaystyle\frac{\partial {x}}{\partial {\theta^{i}}}}\)</span>.  The following show the frame for
spherical coordinates.</p>
<div class="math">
\[\begin{equation*}
\boldsymbol{e}_{r} = \cos\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{x}}}+\sin\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{y}}}+\cos\left({\theta}\right){\boldsymbol{{e}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\boldsymbol{e}_{{\theta}} = \cos\left({\phi}\right) \cos\left({\theta}\right){\boldsymbol{{e}_{x}}}+r \cos\left({\theta}\right) \sin\left({\phi}\right){\boldsymbol{{e}_{y}}} - r \sin\left({\theta}\right){\boldsymbol{{e}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\boldsymbol{e}_{{\phi}} =  - r \sin\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{x}}}+r \cos\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{y}}}
\end{equation*}\]</div><p>The coordinate frame generated in this manner is not necessarily normalized so
define a normalized frame by</p>
<div class="math">
\[\begin{equation*}
\boldsymbol{\hat{e}}_{i} = {\displaystyle\frac{\boldsymbol{e}_{i}}{\sqrt{\left |{{\boldsymbol{e}_{i}^{2}}}\right |}}} = {\displaystyle\frac{\boldsymbol{e}_{i}}{\left |{{\boldsymbol{e}_{i}}}\right |}}
\end{equation*}\]</div><p>This works for all <span class="math">\(\boldsymbol{e}_{i}^{2} \neq 0\)</span> since we have defined
<span class="math">\(\left |\boldsymbol{e}_{i}\right | = \sqrt{\left |\boldsymbol{e}_{i}^{2}\right |}\)</span>.   For spherical
coordinates the normalized frame vectors are</p>
<div class="math">
\[\begin{equation*}
\boldsymbol{\hat{e}}_{r} =  \cos\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{x}}}+\sin\left({\phi}\right) \sin\left({\theta}\right){\boldsymbol{{e}_{y}}}+\cos\left({\theta}\right){\boldsymbol{{e}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\boldsymbol{\hat{e}}_{{\theta}} = \cos\left({\phi}\right) \cos\left({\theta}\right){\boldsymbol{{e}_{x}}}+\cos\left({\theta}\right) \sin\left({\phi}\right){\boldsymbol{{e}_{y}}}- \sin\left({\theta}\right){\boldsymbol{{e}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\boldsymbol{\hat{e}}_{{\phi}} = - \sin\left({\phi}\right){\boldsymbol{{e}_{x}}}+\cos\left({\phi}\right){\boldsymbol{{e}_{y}}}
\end{equation*}\]</div><p>The geometric derivative in curvilinear coordinates is given by</p>
<div class="math">
\[\begin{align*}
  \nabla F_{R} & =  \boldsymbol{e}^{i}{\displaystyle\frac{\partial {}}{\partial {x^{i}}}}\left ( F_{R}^{i_{1}\dots i_{R}}
                   \boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right )  \\
                 & =  \boldsymbol{e^{j}}{\displaystyle\frac{\partial {}}{\partial {\theta^{j}}}}\left ( F_{R}^{i_{1}\dots i_{R}}
                   \boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right )  \\
                 & =   \left ({\displaystyle\frac{\partial {}}{\partial {\theta^{j}}}} F_{R}^{i_{1}\dots i_{R}}\right )
                   \boldsymbol{e^{j}}\left (\boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right )+
                   F_{R}^{i_{1}\dots i_{R}}\boldsymbol{e^{j}}
                   {\displaystyle\frac{\partial {}}{\partial {\theta^{j}}}}\left (\boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right ) \\
                 & =   \left ({\displaystyle\frac{\partial {}}{\partial {\theta^{j}}}} F_{R}^{i_{1}\dots i_{R}}\right )
                   \boldsymbol{e^{j}}\left (\boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right )+
                   F_{R}^{i_{1}\dots i_{R}}C\left \{ \boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right \}
\end{align*}\]</div><p>where</p>
<div class="math">
\[\begin{equation*}
C\left \{ \boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right \}  = \boldsymbol{e^{j}}{\displaystyle\frac{\partial {}}{\partial {\theta^{j}}}}
                                                            \left (\boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{R}}\right )
\end{equation*}\]</div><p>are the connection multivectors for the curvilinear coordinate system. For a
spherical coordinate system they are</p>
<div class="math">
\[\begin{equation*}
C\left \{\boldsymbol{\hat{e}}_{r}\right \} =  \frac{2}{r}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\left \{\boldsymbol{\hat{e}}_{\theta}\right \} =  \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}
                              +\frac{1}{r}\boldsymbol{\hat{e}}_{r}\wedge\boldsymbol{\hat{e}}_{\theta}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\left \{\boldsymbol{\hat{e}}_{\phi}\right \} = \frac{1}{r}\boldsymbol{{\hat{e}}_{r}}\wedge\boldsymbol{\hat{e}}_{{\phi}}+ \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}\boldsymbol{\hat{e}}_{{\theta}}\wedge\boldsymbol{\hat{e}}_{{\phi}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\left \{\hat{e}_{r}\wedge\hat{e}_{\theta}\right \} =  - \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}
                                      \boldsymbol{\hat{e}}_{r}+\frac{1}{r}\boldsymbol{\hat{e}}_{{\theta}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\left \{\boldsymbol{\hat{e}}_{r}\wedge\boldsymbol{\hat{e}}_{\phi}\right \} = \frac{1}{r}\boldsymbol{\hat{e}}_{{\phi}}
                    - \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}\boldsymbol{\hat{e}}_{r}\wedge\boldsymbol{\hat{e}}_{{\theta}}\wedge\boldsymbol{\hat{e}}_{{\phi}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\left \{\boldsymbol{\hat{e}}_{\theta}\wedge\boldsymbol{\hat{e}}_{\phi}\right \} =  \frac{2}{r}\boldsymbol{\hat{e}}_{r}\wedge
                                              \boldsymbol{\hat{e}}_{\theta}\wedge\boldsymbol{\hat{e}}_{\phi}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\left \{\boldsymbol{\hat{e}}_r\wedge\boldsymbol{\hat{e}}_{\theta}\wedge\boldsymbol{\hat{e}}_{\phi}\right \} = 0
\end{equation*}\]</div></div>
<div class="section" id="numpy-latex-and-ansicon-installation">
<h2>Numpy, LaTeX, and Ansicon Installation<a class="headerlink" href="#numpy-latex-and-ansicon-installation" title="Permalink to this headline">¶</a></h2>
<p>To install the geometric algebra module on windows,linux, or OSX perform the following operations</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Install sympy.  <em>galgebra</em> is included in sympy.</p>
</li>
<li><p class="first">To install texlive in linux or windows</p>
<blockquote>
<div><ol class="arabic simple">
<li>Go to &lt;<a class="reference external" href="http://www.tug.org/texlive/acquire-netinstall.html">http://www.tug.org/texlive/acquire-netinstall.html</a>&gt; and click on &#8220;install-tl.zip&#8221; o download</li>
<li>Unzip &#8220;install-tl.zip&#8221; anywhere on your machine</li>
<li>Open the file &#8220;readme.en.html&#8221; in the &#8220;readme-html.dir&#8221; directory.  This file contains the information needed to install texlive.</li>
<li>Open a terminal (console) in the &#8220;install-tl-XXXXXX&#8221; directory</li>
<li>Follow the instructions in &#8220;readme.en.html&#8221; file to run the install-tl.bat file in windows or the install-tl script file in linux.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">For OSX install mactex from &lt;<a class="reference external" href="http://tug.org/mactex/">http://tug.org/mactex/</a>&gt;.</p>
</li>
<li><p class="first">Install python-nympy if you want to calculate numerical matrix functons (determinant, inverse, eigenvalues, etc.).
For windows go to &lt;<a class="reference external" href="http://sourceforge.net/projects/numpy/files/NumPy/1.6.2/">http://sourceforge.net/projects/numpy/files/NumPy/1.6.2/</a>&gt; and install the distribution of numpy
appropriate for your system.  For OSX go to &lt;<a class="reference external" href="http://sourceforge.net/projects/numpy/files/NumPy/1.6.1/">http://sourceforge.net/projects/numpy/files/NumPy/1.6.1/</a>&gt;.</p>
</li>
<li><p class="first">It is strongly suggested that you go to &lt;<a class="reference external" href="http://www.geany.org/Download/Releases">http://www.geany.org/Download/Releases</a>&gt; and install the version of the &#8220;geany&#8221; editor appropriate for your system.</p>
</li>
<li><p class="first">If you wish to use &#8220;enhance_print&#8221; on windows -</p>
<blockquote>
<div><ol class="arabic simple">
<li>Go to &lt;<a class="reference external" href="https://github.com/adoxa/ansicon/downloads">https://github.com/adoxa/ansicon/downloads</a>&gt; and download &#8220;ansicon&#8221;</li>
<li>In the Edit -&gt; Preferences -&gt; Tools menu of &#8220;geany&#8221; enter into the Terminal input the full path of &#8220;ansicon.exe&#8221;</li>
</ol>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>After installation if you are doing you code development in the <em>galgebra</em> directory you need only include</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span><span class="p">,</span><span class="n">enhance_print</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>to use the <em>galgebra</em> module.</p>
<p>In addition to the code shown in the examples section of this document there are more examples in the Examples directory under the
<em>galgebra</em> directory.</p>
</div>
<div class="section" id="module-components">
<h2>Module Components<a class="headerlink" href="#module-components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="initializing-multivector-class">
<h3>Initializing Multivector Class<a class="headerlink" href="#initializing-multivector-class" title="Permalink to this headline">¶</a></h3>
<p>The multivector class is initialized with:</p>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.setup">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">setup</tt><big>(</big><em>basis</em>, <em>metric=None</em>, <em>coords=None</em>, <em>rframe=False</em>, <em>debug=False</em>, <em>curv=(None</em>, <em>None)</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>basis</em> and <em>metric</em> parameters were described in section <a class="reference internal" href="#vbm"><em>Vector Basis and Metric</em></a>. If
<em>rframe=True</em> the reciprocal frame of the symbolic bases vectors is calculated.
If <em>debug=True</em> the data structure required to initialize the <tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt> class
are printer out. <em>coords</em> is a tuple of <a class="reference internal" href="../matrices/immutablematrices.html#module-sympy" title="sympy"><tt class="xref py py-class docutils literal"><span class="pre">sympy</span></tt></a> symbols equal in length to
the number of basis vectors.  These symbols are used as the arguments of a
multivector field as a function of position and for calculating the derivatives
of a multivector field (if <em>coords</em> is defined then <em>rframe</em> is automatically
set equal to <em>True</em>). Additionally, <tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt> calculates the pseudo scalar,
<span class="math">\(I\)</span> and makes them available to the programmer as <em>MV.I</em> and <em>MV.Iinv</em>.</p>
<p><tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt> always returns a tuple containing the basis vectors (as multivectors)
so that if we have the code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e_1 e_2 e_3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>then we can define a multivector by the expression</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a__1 a__2 a__3&#39;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">a1</span><span class="o">*</span><span class="n">e1</span><span class="o">+</span><span class="n">a2</span><span class="o">*</span><span class="n">e2</span><span class="o">+</span><span class="n">a3</span><span class="o">*</span><span class="n">e3</span>
</pre></div>
</div>
<p>Another option is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e*1|2|3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which produce the same results as the previous method.  Note that if
we had used</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e*x|y|z&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>then the basis vectors would have been labeled <em>e_x</em>, <em>e_y</em>, and <em>e_z</em>.  If
<em>coords</em> is defined then <tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt> returns the tuple</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">,</span><span class="n">ez</span><span class="p">,</span><span class="n">grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>the basis vectros are again labeled <em>e_x</em>, <em>e_y</em>, and <em>e_z</em> and the
additional vector <em>grad</em> is returned.  <em>grad</em> acts as the gradient
operator (geometric derivative) so that if <tt class="xref py py-func docutils literal"><span class="pre">F()</span></tt> is a multivector
function of <em>(x,y,z)</em> then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">DFl</span> <span class="o">=</span> <span class="n">grad</span><span class="o">*</span><span class="n">F</span>
<span class="n">DFr</span> <span class="o">=</span> <span class="n">F</span><span class="o">*</span><span class="n">grad</span>
</pre></div>
</div>
<p>are the left and right geometric derivatives of <tt class="xref py py-func docutils literal"><span class="pre">F()</span></tt>.</p>
<p>The final parameter in <tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt> is <em>curv</em> which defines a
curvilinear coordinate system. If 3-dimensional spherical coordinates
are required we would define -</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r theta phi&#39;</span><span class="p">)</span>
<span class="n">curv</span> <span class="o">=</span> <span class="p">[[</span><span class="n">r</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)],[</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)]]</span>
<span class="p">(</span><span class="n">er</span><span class="p">,</span><span class="n">eth</span><span class="p">,</span><span class="n">ephi</span><span class="p">,</span><span class="n">grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e_r e_theta e_phi&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,1,1]&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">curv</span><span class="o">=</span><span class="n">curv</span><span class="p">)</span>
</pre></div>
</div>
<p>The first component of <em>curv</em> is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">r</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)]</span>
</pre></div>
</div>
<p>This is the position vector for the spherical coordinate system expressed
in terms of the rectangular coordinate components given in terms of the
spherical coordinates <em>r</em>, <em>th</em>, and <em>phi</em>.  The second component
of <em>curv</em> is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)]</span>
</pre></div>
</div>
<p>The components of <em>curv[1]</em> are the normalizing factors for the basis
vectors of the spherical coordinate system that are calculated from the
derivatives of <em>curv[0]</em> with respect to the coordinates <em>r</em>, <em>th</em>,
and <em>phi</em>.  In theory the normalizing factors can be calculated from
the derivatives of <em>curv[0]</em>.  In practice one cannot currently specify
in sympy that the square of a function is always positive which leads to
problems when the normalizing factor is the square root of a squared
function.  To avoid these problems the normalizing factors are explicitly
defined in <em>curv[1]</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the case of curvlinear coordinates <em>debug</em> also prints the connection
multivectors.</p>
</div>
</dd></dl>

</div>
<div class="section" id="instantiating-a-multivector">
<h3>Instantiating a Multivector<a class="headerlink" href="#instantiating-a-multivector" title="Permalink to this headline">¶</a></h3>
<p>Now that grades and bases have been described we can show all the ways that a
multivector can be instantiated. As an example assume that the multivector space
is initialized with</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e_1 e_2 e_3&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>then multivectors could be instantiated with</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a__1 a__2 a__3&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a1</span><span class="o">*</span><span class="n">e1</span><span class="o">+</span><span class="n">a2</span><span class="o">*</span><span class="n">e2</span><span class="o">+</span><span class="n">a3</span><span class="o">*</span><span class="n">e3</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">e1</span><span class="o">*</span><span class="n">e2</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">|</span><span class="n">y</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="n">y</span>
</pre></div>
</div>
</div></blockquote>
<p>or with the multivector class constructor:</p>
<dl class="class">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV">
<em class="property">class </em><tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">MV</tt><big>(</big><em>base=None</em>, <em>mvtype=None</em>, <em>fct=False</em>, <em>blade_rep=True</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV" title="Permalink to this definition">¶</a></dt>
<dd><p><em>base</em> is a string that defines the name of the multivector for output
purposes. <em>base</em> and  <em>mvtype</em> are defined by the following table and <em>fct</em> is a
switch that will convert the symbolic coefficients of a multivector to functions
if coordinate variables have been defined when <tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt> is called:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="26%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">mvtype</th>
<th class="head">base</th>
<th class="head">result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>default</td>
<td>default</td>
<td>Zero multivector</td>
</tr>
<tr class="row-odd"><td>scalar</td>
<td>string s</td>
<td>symbolic scalar of value Symbol(s)</td>
</tr>
<tr class="row-even"><td>vector</td>
<td>string s</td>
<td>symbolic vector</td>
</tr>
<tr class="row-odd"><td>grade2 or bivector</td>
<td>string s</td>
<td>symbolic bivector</td>
</tr>
<tr class="row-even"><td>grade</td>
<td>string s,n</td>
<td>symbolic n-grade multivector</td>
</tr>
<tr class="row-odd"><td>pseudo</td>
<td>string s</td>
<td>symbolic pseudoscalar</td>
</tr>
<tr class="row-even"><td>spinor</td>
<td>string s</td>
<td>symbolic even multivector</td>
</tr>
<tr class="row-odd"><td>mv</td>
<td>string s</td>
<td>symbolic general multivector</td>
</tr>
<tr class="row-even"><td>default</td>
<td>sympy scalar c</td>
<td>zero grade multivector with coefficient c</td>
</tr>
<tr class="row-odd"><td>default</td>
<td>multivector</td>
<td>copy constructor for multivector</td>
</tr>
</tbody>
</table>
<p>If the <em>base</em> argument is a string s then the coefficients of the resulting
multivector are named as follows:</p>
<blockquote>
<div><p>The grade r coefficients consist of the base string, s, followed by a double
underscore, __, and an index string of r symbols.  If <em>coords</em> is defined the
index string will consist of coordinate names in a normal order defined by
the <em>coords</em> tuple.  If <em>coords</em> is not defined the index string will be
integers in normal (ascending) order (for an n dimensional vector space the
indices will be 1 to n).  The double underscore is used because the latex printer
interprets it as a superscript and superscripts in the coefficients will balance
subscripts in the bases.</p>
<p>For example if If <em>coords=(x,y,z)</em> and the base is <em>A</em>, the list of all possible
coefficients for the most general multivector would be <em>A</em>, <em>A__x</em>, <em>A__y</em>, <em>A__z</em>,
<em>A__xy</em>, <em>A__xz</em>, <em>A__yz</em>, and <em>A_xyz</em>.  If the latex printer is used and <em>e</em> is the
base for the basis vectors then the pseudo scalar would print as
<span class="math">\(A^{xyz}\boldsymbol{e_{x}\wedge e_{y}\wedge e_{z}}\)</span>. If coordinates are not defined it would print
as <span class="math">\(A^{123}\boldsymbol{e_{1}\wedge e_{2}\wedge e_{3}}\)</span>.  For printed output all multivectors are represented
in terms of products of the basis vectors, either as geometric products or wedge products. This
is also true for the output of expressions containing reciprocal basis vectors.</p>
</div></blockquote>
<p>If the <em>fct</em> argument of <tt class="xref py py-func docutils literal"><span class="pre">MV()</span></tt> is set to <em>True</em> and the <em>coords</em> argument in
<tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt> is defined the symbolic coefficients of the multivector are functions
of the coordinates.</p>
</dd></dl>

</div>
<div class="section" id="basic-multivector-class-functions">
<h3>Basic Multivector Class Functions<a class="headerlink" href="#basic-multivector-class-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.convert_to_blades">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">convert_to_blades</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.convert_to_blades" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert multivector from the base representation to the blade representation.
If multivector is already in blade representation nothing is done.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.convert_from_blades">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">convert_from_blades</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.convert_from_blades" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert multivector from the blade representation to the base representation.
If multivector is already in base representation nothing is done.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.dd">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">dd</tt><big>(</big><em>self</em>, <em>v</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.dd" title="Permalink to this definition">¶</a></dt>
<dd><p>For a mutivector function <em>F</em> and a vector <em>v</em> then <em>F.dd(v)</em> is the
directional derivate of <em>F</em> in the direction <em>v</em>, <span class="math">\(( v\cdot\nabla ) F\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.diff">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">diff</tt><big>(</big><em>self</em>, <em>var</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate derivative of each multivector coefficient with resepect to
variable <em>var</em> and form new multivector from coefficients.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.dual">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">dual</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dual of multivector which is multivector left multiplied by
pseudoscalar <em>MV.I</em> (<a class="reference internal" href="#hestenes">[Hestenes]</a>,p22).</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.even">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">even</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.even" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the even grade components of the multivector.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.exp">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">exp</tt><big>(</big><em>self</em>, <em>alpha=1</em>, <em>norm=0</em>, <em>mode='T'</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return exponential of a blade (if self is not a blade error message
is generated).  If <span class="math">\(A\)</span> is the blade then <span class="math">\(e^{\alpha A}\)</span> is returned
where the default <em>mode</em>, <em>&#8216;T&#8217;</em>, assumes <span class="math">\(AA &lt; 0\)</span> so that</p>
<div class="math">
\[\begin{equation*}
      e^{\alpha A} = {\cos}\left ( {\alpha\sqrt{-A^{2}}} \right )+{\sin}\left ( {\alpha\sqrt{-A^{2}}} \right ){\displaystyle\frac{A}{\sqrt{-A^{2}}}}.
\end{equation*}\]</div><p>If the mode is not <em>&#8216;T&#8217;</em> then <span class="math">\(AA &gt; 0\)</span> is assumed so that</p>
<div class="math">
\[\begin{equation*}
      e^{\alpha A} = {\cosh}\left ( {\alpha\sqrt{A^{2}}} \right )+{\sinh}\left ( {\alpha\sqrt{A^{2}}} \right ){\displaystyle\frac{A}{\sqrt{A^{2}}}}.
\end{equation*}\]</div><p>If <span class="math">\(norm = N  &gt;  0\)</span> then</p>
<div class="math">
\[\begin{equation*}
     e^{\alpha A} = {\cos}\left ( {\alpha N} \right )+{\sin}\left ( {\alpha N} \right ){\displaystyle\frac{A}{N}}
\end{equation*}\]</div><p>or</p>
<div class="math">
\[\begin{equation*}
      e^{\alpha A} = {\cosh}\left ( {\alpha N} \right )+{\sinh}\left ( {\alpha N} \right ){\displaystyle\frac{A}{N}}
\end{equation*}\]</div><p>depending on the value of <em>mode</em>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.expand">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">expand</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multivector in which each coefficient has been expanded using
sympy <em>expand()</em> function.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.factor">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">factor</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <em>sympy</em> <em>factor</em> function to each coefficient of the multivector.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.func">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">func</tt><big>(</big><em>self</em>, <em>fct</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.func" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <em>sympy</em> scalar function <em>fct</em> to each coefficient of the multivector.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.grade">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">grade</tt><big>(</big><em>self</em>, <em>igrade=0</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.grade" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a multivector that consists of the part of the multivector of
grade equal to <em>igrade</em>.  If the multivector has no <em>igrade</em> part
return a zero multivector.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.inv">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">inv</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of the multivector if <em>self*sefl.rev()</em> is a nonzero ctor.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.norm">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">norm</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the norm of the multvector <span class="math">\(M\)</span> (<em>M.norm()</em>) defined by
<span class="math">\(\sqrt{MM^{\dagger}}\)</span>.  If <span class="math">\(MM^{\dagger}\)</span> is a scalar (a sympy scalar
is returned). If <span class="math">\(MM^{\dagger}\)</span> in not a scalar the program exits
with an error message.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">norm</tt><big>(</big><em>self</em><big>)</big></dt>
<dd><p>Return the square of norm of the multvector <span class="math">\(M\)</span> (<em>M.norm2()</em>) defined by
<span class="math">\(MM^{\dagger}\)</span>.  If <span class="math">\(MM^{\dagger}\)</span> is a scalar (a sympy scalar
is returned). If <span class="math">\(MM^{\dagger}\)</span> in not a scalar the program exits
with an error message.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.scalar">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">scalar</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coefficient (sympy scalar) of the scalar part of a
multivector.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.simplify">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">simplify</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multivector where sympy simplify function has been applied to
each coefficient of the multivector.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.subs">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">subs</tt><big>(</big><em>self</em>, <em>x</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.subs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multivector where sympy subs function has been applied to each
coefficient of multivector for argument dictionary/list x.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.rev">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">rev</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.rev" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the reverse of the multivector.  See section <a class="reference internal" href="#reverse"><em>Reverse of Multivector</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.set_coef">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">set_coef</tt><big>(</big><em>self</em>, <em>grade</em>, <em>base</em>, <em>value</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.set_coef" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the multivector coefficient of index <em>(grade,base)</em> to <em>value</em>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.MV.trigsimp">
<tt class="descclassname">sympy.galgebra.ga.MV.</tt><tt class="descname">trigsimp</tt><big>(</big><em>self</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.MV.trigsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <em>sympy</em> trignometric simplification fuction <em>trigsimp</em> to
each coefficient of the multivector. <em>**kwargs</em> are the arguments of
trigsimp.  See <em>sympy</em> documentation on <em>trigsimp</em> for more information.</p>
</dd></dl>

</div>
<div class="section" id="basic-multivector-functions">
<h3>Basic Multivector Functions<a class="headerlink" href="#basic-multivector-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.galgebra.ga.diagpq">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">diagpq</tt><big>(</big><em>p</em>, <em>q=0</em><big>)</big><a class="reference internal" href="../../_modules/sympy/galgebra/ga.html#diagpq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.galgebra.ga.diagpq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string equivalent metric tensor for signature (p, q).</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.arbitrary_metric">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">arbitrary_metric</tt><big>(</big><em>n</em><big>)</big><a class="reference internal" href="../../_modules/sympy/galgebra/ga.html#arbitrary_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.galgebra.ga.arbitrary_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string equivalent metric tensor for arbitrary signature.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.arbitrary_metric_conformal">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">arbitrary_metric_conformal</tt><big>(</big><em>n</em><big>)</big><a class="reference internal" href="../../_modules/sympy/galgebra/ga.html#arbitrary_metric_conformal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.galgebra.ga.arbitrary_metric_conformal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string equivalent metric tensor for arbitrary signature (n+1,1).</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.Com">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Com</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.Com" title="Permalink to this definition">¶</a></dt>
<dd><p>Calulate commutator of multivectors <em>A</em> and <em>B</em>.  Returns <span class="math">\((AB-BA)/2\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.DD">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">DD</tt><big>(</big><em>v</em>, <em>f</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.DD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate directional derivative of multivector function <em>f</em> in direction of
vector <em>v</em>.  Returns <em>f.dd(v)</em>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.Format">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Format</tt><big>(</big><em>Fmode=True</em>, <em>Dmode=True</em>, <em>ipy=False</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.Format" title="Permalink to this definition">¶</a></dt>
<dd><p>See latex printing.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">sympy.galgebra.precedence.</tt><tt class="descname">GAeval</tt><big>(</big><em>s</em>, <em>pstr=False</em><big>)</big></dt>
<dd><p>Returns multivector expression for string <em>s</em> with operator precedence for
string <em>s</em> defined by inputs to function <em>define_precedence()</em>.  if <em>pstr=True</em>
<em>s</em> and <em>s</em> with parenthesis added to enforce operator precedence are printed.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.Nga">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Nga</tt><big>(</big><em>x</em>, <em>prec=5</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.Nga" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>x</em> is a multivector with coefficients that contain floating point numbers, <em>Nga()</em>
rounds all these numbers to a precision of <em>prec</em> and returns the rounded multivector.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.ReciprocalFrame">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">ReciprocalFrame</tt><big>(</big><em>basis</em>, <em>mode='norm'</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.ReciprocalFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>basis</em> is a list/tuple of vectors, <em>ReciprocalFrame()</em> returns a tuple of reciprocal
vectors.  If <em>mode=norm</em> the vectors are normalized.  If <em>mode</em> is anything other than
<em>norm</em> the vectors are unnormalized and the normalization coefficient is added to the
end of the tuple.  One must divide by the coefficient to normalize the vectors.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.ScalarFunction">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">ScalarFunction</tt><big>(</big><em>TheFunction</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.ScalarFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>TheFuction</em> is a real <em>sympy</em> fuction a scalar multivector function is returned.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.cross">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">cross</tt><big>(</big><em>M1</em>, <em>M2</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>M1</em> and <em>M2</em> are 3-dimensional euclidian vectors the vector cross product is
returned, <span class="math">\(v_{1}\times v_{2} = -I\left ( {{v_{1}\wedge v_{2}}} \right )\)</span>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">sympy.galgebra.precedence.</tt><tt class="descname">define_precedence</tt><big>(</big><em>gd</em>, <em>op_ord='&lt;&gt;|</em>, <em>^</em>, <em>*'</em><big>)</big></dt>
<dd><p>This is used with the <em>GAeval()</em> fuction to evaluate a string representing a multivector
expression with a revised operator precedence.  <em>define_precedence()</em> redefines the operator
precedence for multivectors. <em>define_precedence()</em> must be called in the main program an the
argument <em>gd</em> must be <em>globals()</em>.  The argument <em>op_ord</em> defines the order of operator
precedence from high to low with groups of equal precedence separated by commas. the default
precedence <em>op_ord=&#8217;&lt;&gt;|,^,*&#8217;</em> is that used by Hestenes (<a class="reference internal" href="#hestenes">[Hestenes]</a>,p7,[Doran]_,p38).</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.dual">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">dual</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of the multivector <em>M</em>, <span class="math">\(MI^{-1}\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.inv">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">inv</tt><big>(</big><em>B</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>If for the multivector <span class="math">\(B\)</span>,  <span class="math">\(BB^{\dagger}\)</span> is a nonzero scalar, return <span class="math">\(B^{-1} = B^{\dagger}/(BB^{\dagger})\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.proj">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">proj</tt><big>(</big><em>B</em>, <em>A</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project blade A on blade B returning <span class="math">\(\left ( {{A\lfloor B}} \right )B^{-1}\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.refl">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">refl</tt><big>(</big><em>B</em>, <em>A</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.refl" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect blade <em>A</em> in blade <em>B</em>. If <em>r</em> is grade of <em>A</em> and <em>s</em> is grade of <em>B</em>
returns <span class="math">\((-1)^{s(r+1)}BAB^{-1}\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.rot">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">rot</tt><big>(</big><em>itheta</em>, <em>A</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.rot" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate blade <em>A</em> by 2-blade <em>itheta</em>.  Is is assumed that <em>itheta*itheta &gt; 0</em> so that
the rotation is Euclidian and not hyperbolic so that the angle of
rotation is <em>theta = itheta.norm()</em>.  Ther in 3-dimensional Euclidian space. <em>theta</em> is the angle of rotation (scalar in radians) and
<em>n</em> is the vector axis of rotation.  Returned is the rotor <em>cos(theta)+sin(theta)*N</em> where <em>N</em> is
the normalized dual of <em>n</em>.</p>
</dd></dl>

</div>
<div class="section" id="multivector-derivatives">
<h3>Multivector Derivatives<a class="headerlink" href="#multivector-derivatives" title="Permalink to this headline">¶</a></h3>
<p>The various derivatives of a multivector function is accomplished by
multiplying the gradient operator vector with the function.  The gradiant
operation vector is returned by the <em>MV.setup()</em> function if coordinates
are defined.  For example if we have for a 3-D vector space</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">,</span><span class="n">ez</span><span class="p">,</span><span class="n">grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e*x|y|z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,1,1]&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Then the gradient operator vector is <em>grad</em> (actually the user can give
it any name he wants to).  Then the derivatives of the multivector
function <em>F</em> are given by</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">F</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">,</span><span class="s">&#39;mv&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<div class="math">
\[    \begin{align*}
          \nabla F &= grad*F \\
          F \nabla &= F*grad \\
          \nabla \wedge F &= grad \wedge F \\
          F \wedge \nabla &= F \wedge grad \\
          \nabla \cdot F &= grad|F \\
          F \cdot \nabla F &= F|grad \\
          \nabla \lfloor F &= grad  <  F \\
          F \lfloor \nabla &= F  <  grad \\
          \nabla \rfloor F &= grad  >  F \\
          F \rfloor \nabla &= F  >  grad
    \end{align*}\]</div><p>The preceding code block gives examples of all possible multivector
derivatives of the multivector function <em>F</em> where * give the left and
right geometric derivatives, ^ gives the left and right exterior (curl)
derivatives, | gives the left and right interior (div) derivatives,
&lt;  give the left and right derivatives for the left contraction, and
&gt;  give the left and right derivatives for the right contraction.  To
understand the left and right derivatives see a reference on geometric
calculus (<a class="reference internal" href="#doran">[Doran]</a>,chapter6).</p>
<p>If one is taking the derivative of a complex expression that expression
should be in parenthesis.  Additionally, whether or not one is taking the
derivative of a complex expression the <em>grad</em> vector and the expression
it is operating on should always be in parenthesis unless the grad operator
and the expression it is operating on are the only objects in the expression.</p>
</div>
<div class="section" id="vector-manifolds">
<h3>Vector Manifolds<a class="headerlink" href="#vector-manifolds" title="Permalink to this headline">¶</a></h3>
<p>In addtition to the <em>galgebra</em> module there is a <em>manifold</em> module that allows
for the definition of a geometric algebra and calculus on a vector manifold.
The vector mainfold is defined by a vector function of some coordinates
in an embedding vector space (<a class="reference internal" href="#doran">[Doran]</a>,p202,[Hestenes]_,p139).  For example the unit 2-sphere would be the
collection of vectors on the unit shpere in 3-dimensions with possible
coordinates of <span class="math">\(\theta\)</span> and <span class="math">\(\phi\)</span> the angles of elevation and
azimuth.  A vector function <span class="math">\({X}\left ( {\theta,\phi} \right )\)</span> that defines the manifold
would be given by</p>
<div class="math">
\[   \begin{equation*}
      {X}\left ( {\theta,\phi} \right ) = {\cos}\left ( {\theta} \right )\boldsymbol{e_{z}}+{\cos}\left ( {\theta} \right )\left ( {{{\cos}\left ( {\phi} \right )\boldsymbol{e_{x}}
      +{\sin}\left ( {\phi} \right )\boldsymbol{e_{y}}}} \right )
   \end{equation*}\]</div><p>The module <em>manifold.py</em> is transitionary in that all calculation are performed in the embedding vector space (geometric algebra).
Thus due to the limitations on <em>sympy</em>&#8216;s <em>simplify()</em> and  <em>trigsimp()</em>, simple expressions may appear to be very complicated since they are expressed
in terms of the basis vectors (bases/blades) of the embedding space and not in terms of the vector space (geometric algebra) formed
from the manifold&#8217;s basis vectors.  A future implementation of <em>Manifold.py</em> will correct this difficiency. The member functions of
the vector manifold follow.</p>
<dl class="function">
<dt id="sympy.galgebra.ga.Manifold">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Manifold</tt><big>(</big><em>x</em>, <em>coords</em>, <em>debug=False</em>, <em>I=None</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.Manifold" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializer for vector manifold where <em>x</em> is the vector function of the <em>coords</em> that defines the manifold and <em>coords</em> is the list/tuple
of sympy symbols that are the coordinates.  The basis vectors of the manifold as a fuction of the coordinates are returned as a tuple. <em>I</em>
is the pseudo scalar for the manifold.  The default is for the initializer to calculate <em>I</em>, however for complicated <em>x</em> functions (especially
where trigonometric functions of the coordinates are involved) it is sometimes a good idea to calculate <em>I</em> separately and input it to <em>Manifold()</em>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.Basis">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Basis</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.Basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the basis vectors of the manifold as a tuple.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.DD">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">DD</tt><big>(</big><em>self</em>, <em>v</em>, <em>F</em>, <em>opstr=False</em><big>)</big><a class="reference internal" href="../../_modules/sympy/galgebra/ga.html#DD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.galgebra.ga.DD" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the manifold directional derivative of a multivector function <em>F</em> defined on the manifold in the vector direction <em>v</em>.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.Grad">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Grad</tt><big>(</big><em>self</em>, <em>F</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.Grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the manifold multivector derivative of the multivector function <em>F</em> defined on the manifold.</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.Proj">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Proj</tt><big>(</big><em>self</em>, <em>F</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.Proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection of the multivector <em>F</em> onto the manifold tangent space.</p>
</dd></dl>

<p>An example of a simple vector manifold is shown below which demonstrates the instanciation of a manifold, the defining
of vector and scalar functions on the manifold and the calculation of the geometric derivative of those functions.</p>
<img alt="../../_images/manifold_testlatex.png" src="../../_images/manifold_testlatex.png" />
</div>
<div class="section" id="standard-printing">
<h3>Standard Printing<a class="headerlink" href="#standard-printing" title="Permalink to this headline">¶</a></h3>
<p>Printing of multivectors is handled by the module <em>galgebra/printing</em> which contains
a string printer class, <em>GA_Printer</em> derived from the sympy string printer class and a latex
printer class, <em>GA_LatexPrinter</em>, derived from the sympy latex printer class.  Additionally, there
is an <em>enhanced_print</em> class that enhances the console output of sympy to make
the printed output multivectors, functions, and derivatives more readable.
<em>enhanced_print</em> requires an ansi console such as is supplied in linux or the
program <em>ansicon</em> (github.com/adoxa/ansicon) for windows which replaces <em>cmd.exe</em>.</p>
<p>For a windows user the simplest way to implement ansicon is to use the <em>geany</em>
editor and in the Edit-&gt;Preferences-&gt;Tools menu replace <em>cmd.exe</em> with
<em>ansicon.exe</em> (be sure to supply the path to <em>ansicon</em>).</p>
<p>If <em>enhanced_print</em> is called in a program (linux) when multivectors are printed
the basis blades or bases are printed in bold text, functions are printed in red,
and derivative operators in green.</p>
<p>For formatting the multivector output there is the member function</p>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.Fmt">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">Fmt</tt><big>(</big><em>self</em>, <em>fmt=1</em>, <em>title=None</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.Fmt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><em>Fmt</em> is used to control how the multivector is printed with the argument
<em>fmt</em>.  If <em>fmt=1</em> the entire multivector is printed on one line.  If
<em>fmt=2</em> each grade of the multivector is printed on one line.  If <em>fmt=3</em>
each component (base) of the multivector is printed on one line.  If a
<em>title</em> is given then <em>title = multivector</em> is printed.  If the usual print
command is used the entire multivector is printed on one line.</p>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.ga_print_on">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">ga_print_on</tt><big>(</big><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.ga_print_on" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Redirects printer output from standard <em>sympy</em> print handler.  Needed if
one wishes to use compact forms of <em>function</em> and <em>derivative</em> output
strings.</p>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.ga.ga_print_off">
<tt class="descclassname">sympy.galgebra.ga.</tt><tt class="descname">ga_print_off</tt><big>(</big><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.ga.ga_print_off" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Restores standard <em>sympy</em> print handler.</p>
</div>
<div class="section" id="latex-printing">
<h3>Latex Printing<a class="headerlink" href="#latex-printing" title="Permalink to this headline">¶</a></h3>
<p>For latex printing one uses one functions from the <em>galgebra</em> module and one
function from the <em>galgebra/printing</em> module.  The
functions are</p>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.printing.Format">
<tt class="descclassname">sympy.galgebra.printing.</tt><tt class="descname">Format</tt><big>(</big><em>Fmode=True</em>, <em>Dmode=True</em>, <em>ipy=False</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.printing.Format" title="Permalink to this definition">¶</a></dt>
<dd><p>This function from the <em>galgebra</em> module turns on latex printing with the
following options</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="18%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">argument</th>
<th class="head">value</th>
<th class="head">result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>Fmode</em></td>
<td><em>True</em></td>
<td>Print functions without argument list, <span class="math">\(f\)</span></td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>False</em></td>
<td>Print functions with standard sympy latex formatting, <span class="math">\(f(x,y,z)\)</span></td>
</tr>
<tr class="row-even"><td><em>Dmode</em></td>
<td><em>True</em></td>
<td>Print partial derivatives with condensed notatation, <span class="math">\(\partial_{x}f\)</span></td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>False</em></td>
<td>Print partial derivatives with standard sympy latex formatting <span class="math">\(\frac{\partial f}{\partial x}\)</span></td>
</tr>
<tr class="row-even"><td><em>ipy</em></td>
<td><em>False</em></td>
<td>Redirect print output to file for post-processing by latex</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>True</em></td>
<td>Do not redirect print output (This is used for Ipython with MathJax)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.printing.xdvi">
<tt class="descclassname">sympy.galgebra.printing.</tt><tt class="descname">xdvi</tt><big>(</big><em>filename=None</em>, <em>pdf=''</em>, <em>debug=False</em>, <em>paper=(14</em>, <em>11)</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.printing.xdvi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function from the <em>galgebra/printing</em> module post-processes the output captured from
print statements.  Write the resulting latex strings to the file <em>filename</em>,
processes the file with pdflatex, and displays the resulting pdf file. <em>pdf</em> is the name of the
pdf viewer on your computer.  If you are running <em>ubuntu</em> the <em>evince</em> viewer is automatically
used.  On other operating systems if <em>pdf = &#8216;&#8217;</em> the name of the pdf file is executed.  If the
pdf file type is associated with a viewer this will launch the viewer with the associated file.
All latex files except
the pdf file are deleted. If <em>debug = True</em> the file <em>filename</em> is printed to
standard output for debugging purposes and <em>filename</em> (the tex file) is saved.  If <em>filename</em> is not entered the default
filename is the root name of the python program being executed with <em>.tex</em> appended.  The format for the <em>paper</em> is</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>paper=(w,h)</em></td>
<td><em>w</em> is paper width in inches and,*h* is paper height in inches</td>
</tr>
<tr class="row-even"><td><em>paper=&#8217;letter&#8217;</em></td>
<td>paper is standard leter size <span class="math">\(8.5\mbox{ in}\times 11\mbox{ in}\)</span></td>
</tr>
</tbody>
</table>
<p>The default of <em>paper=(14,11)</em> was chosen so that long multivector expressions would not be truncated on
the display.</p>
<p>The <strong>xdvi</strong> function requires that latex and a pdf viewer be installed on
the computer.</p>
</dd></dl>

<p>As an example of using the latex printing options when the following code is
executed</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Format</span><span class="p">()</span>
<span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">,</span><span class="n">ez</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e*x|y|z&#39;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;mv&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\bm{A} =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">r&#39;\bm{A}&#39;</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">r&#39;\bm{A}&#39;</span><span class="p">)</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>The following is displayed</p>
<blockquote>
<div><div class="math">
\[\begin{align*}
\boldsymbol{A} = & A+A^{x}\boldsymbol{e_{x}}+A^{y}\boldsymbol{e_{y}}+A^{z}\boldsymbol{e_{z}}+A^{xy}\boldsymbol{e_{x}\wedge e_{y}}+A^{xz}\boldsymbol{e_{x}\wedge e_{z}}+A^{yz}\boldsymbol{e_{y}\wedge e_{z}}+A^{xyz}\boldsymbol{e_{x}\wedge e_{y}\wedge e_{z}} \\
\boldsymbol{A} =  & A \\  & +A^{x}\boldsymbol{e_{x}}+A^{y}\boldsymbol{e_{y}}+A^{z}\boldsymbol{e_{z}} \\  & +A^{xy}\boldsymbol{e_{x}\wedge e_{y}}+A^{xz}\boldsymbol{e_{x}\wedge e_{z}}+A^{yz}\boldsymbol{e_{y}\wedge e_{z}} \\  & +A^{xyz}\boldsymbol{e_{x}\wedge e_{y}\wedge e_{z}} \\
\boldsymbol{A} =  & A \\  & +A^{x}\boldsymbol{e_{x}} \\  & +A^{y}\boldsymbol{e_{y}} \\  & +A^{z}\boldsymbol{e_{z}} \\  & +A^{xy}\boldsymbol{e_{x}\wedge e_{y}} \\  & +A^{xz}\boldsymbol{e_{x}\wedge e_{z}} \\  & +A^{yz}\boldsymbol{e_{y}\wedge e_{z}} \\  & +A^{xyz}\boldsymbol{e_{x}\wedge e_{y}\wedge e_{z}}
\end{align*}\]</div></div></blockquote>
<p>For the cases of derivatives the code is</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Format</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">,</span><span class="n">ez</span><span class="p">,</span><span class="n">grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e_x e_y e_z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,1,1]&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;grade2&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">print</span> <span class="s">r&#39;\bm{A} =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="k">print</span> <span class="s">r&#39;\bm{B} =&#39;</span><span class="p">,</span><span class="n">B</span>

<span class="k">print</span> <span class="s">&#39;grad*f =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">*</span><span class="n">f</span>
<span class="k">print</span> <span class="s">r&#39;grad|\bm{A} =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">|</span><span class="n">A</span>
<span class="k">print</span> <span class="s">r&#39;grad*\bm{A} =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">*</span><span class="n">A</span>

<span class="k">print</span> <span class="s">r&#39;-I*(grad^\bm{A}) =&#39;</span><span class="p">,</span><span class="o">-</span><span class="n">MV</span><span class="o">.</span><span class="n">I</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="o">^</span><span class="n">A</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;grad*\bm{B} =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">*</span><span class="n">B</span>
<span class="k">print</span> <span class="s">r&#39;grad^\bm{B} =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">^</span><span class="n">B</span>
<span class="k">print</span> <span class="s">r&#39;grad|\bm{B} =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">|</span><span class="n">B</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>and the latex displayed output is (<span class="math">\(f\)</span> is a scalar function)</p>
<blockquote>
<div><div class="math">
\[\begin{align*}
\boldsymbol{A} =& A^{x}\boldsymbol{e_{x}}+A^{y}\boldsymbol{e_{y}}+A^{z}\boldsymbol{e_{z}} \\
\boldsymbol{B} =& B^{xy}\boldsymbol{e_{x}\wedge e_{y}}+B^{xz}\boldsymbol{e_{x}\wedge e_{z}}+B^{yz}\boldsymbol{e_{y}\wedge e_{z}} \\
\boldsymbol{\nabla}  f =& \partial_{x} f\boldsymbol{e_{x}}+\partial_{y} f\boldsymbol{e_{y}}+\partial_{z} f\boldsymbol{e_{z}} \\
\boldsymbol{\nabla} \cdot \boldsymbol{A} = &\partial_{x} A^{x} + \partial_{y} A^{y} + \partial_{z} A^{z} \\
\boldsymbol{\nabla}  \boldsymbol{A} = &\partial_{x} A^{x} + \partial_{y} A^{y} + \partial_{z} A^{z}
                                      +\left ( - \partial_{y} A^{x} + \partial_{x} A^{y}\right ) \boldsymbol{e_{x}\wedge e_{y}}
                                      +\left ( - \partial_{z} A^{x} + \partial_{x} A^{z}\right ) \boldsymbol{e_{x}\wedge e_{z}} \\
                                      &+\left ( - \partial_{z} A^{y} + \partial_{y} A^{z}\right ) \boldsymbol{e_{y}\wedge e_{z}} \\
-I (\boldsymbol{\nabla} \wedge \boldsymbol{A}) = &\left ( - \partial_{z} A^{y} + \partial_{y} A^{z}\right ) \boldsymbol{e_{x}}
                                                +\left ( \partial_{z} A^{x} - \partial_{x} A^{z}\right ) \boldsymbol{e_{y}}
                                                +\left ( - \partial_{y} A^{x} + \partial_{x} A^{y}\right ) \boldsymbol{e_{z}} \\
\boldsymbol{\nabla}  \boldsymbol{B} = &\left ( - \partial_{y} B^{xy} - \partial_{z} B^{xz}\right ) \boldsymbol{e_{x}}
                                     +\left ( \partial_{x} B^{xy} - \partial_{z} B^{yz}\right ) \boldsymbol{e_{y}}
                                     +\left ( \partial_{x} B^{xz} + \partial_{y} B^{yz}\right ) \boldsymbol{e_{z}} \\
                                     &+\left ( \partial_{z} B^{xy} - \partial_{y} B^{xz} + \partial_{x} B^{yz}\right ) \boldsymbol{e_{x}\wedge e_{y}\wedge e_{z}} \\
\boldsymbol{\nabla} \wedge \boldsymbol{B} = &\left ( \partial_{z} B^{xy} - \partial_{y} B^{xz} + \partial_{x} B^{yz}\right ) \boldsymbol{e_{x}\wedge e_{y}\wedge e_{z}} \\
\boldsymbol{\nabla} \cdot \boldsymbol{B} = &\left ( - \partial_{y} B^{xy} - \partial_{z} B^{xz}\right ) \boldsymbol{e_{x}}+\left ( \partial_{x} B^{xy} - \partial_{z} B^{yz}\right ) \boldsymbol{e_{y}}+\left ( \partial_{x} B^{xz} + \partial_{y} B^{yz}\right ) \boldsymbol{e_{z}}
\end{align*}\]</div></div></blockquote>
<p>This example also demonstrates several other features of the latex printer.  In the
case that strings are input into the latex printer such as <tt class="docutils literal"><span class="pre">r'grad*\boldsymbol{A}'</span></tt>,
<tt class="docutils literal"><span class="pre">r'grad^\boldsymbol{A}'</span></tt>, or <tt class="docutils literal"><span class="pre">r'grad*\boldsymbol{A}'</span></tt>.  The text symbols <em>grad</em>, <em>^</em>, <em>|</em>, and
<em>*</em> are mapped by the <em>xdvi()</em> post-processor as follows if the string contains
an <em>=</em>.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">original</th>
<th class="head">replacement</th>
<th class="head">displayed latex</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">grad*A</span></tt></td>
<td><tt class="docutils literal"><span class="pre">\boldsymbol{\nabla}A</span></tt></td>
<td><span class="math">\(\boldsymbol{\nabla}A\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">A^B</span></tt></td>
<td><tt class="docutils literal"><span class="pre">A\wedge</span> <span class="pre">B</span></tt></td>
<td><span class="math">\(A\wedge B\)</span></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">A|B</span></tt></td>
<td><tt class="docutils literal"><span class="pre">A\cdot</span> <span class="pre">B</span></tt></td>
<td><span class="math">\(A\cdot B\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">A*B</span></tt></td>
<td><tt class="docutils literal"><span class="pre">AB</span></tt></td>
<td><span class="math">\(AB\)</span></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">A&lt;B</span></tt></td>
<td><tt class="docutils literal"><span class="pre">A\lfloor</span> <span class="pre">B</span></tt></td>
<td><span class="math">\(A\lfloor B\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">A&gt;B</span></tt></td>
<td><tt class="docutils literal"><span class="pre">A\rfloor</span> <span class="pre">B</span></tt></td>
<td><span class="math">\(A\rfloor B\)</span></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If the string to be printed contains a <em>%</em> none of the above substitutions
are made before the latex processor is applied.  In general for the latex
printer strings are assumed to be in a math environment (<em>equation*</em> or
<em>align*</em>) unless the string contains a <em>#</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Except where noted the conventions for latex printing follow those of the
latex printing module of sympy. This includes translating sympy variables
with Greek name (such as <tt class="docutils literal"><span class="pre">alpha</span></tt>) to the equivalent Greek symbol
(<span class="math">\(\alpha\)</span>) for the purpose of latex printing.  Also a single
underscore in the variable name (such as <tt class="docutils literal"><span class="pre">X_j</span></tt>) indicates a subscript
(<span class="math">\(X_{j}\)</span>), and a double underscore (such as <tt class="docutils literal"><span class="pre">X__k</span></tt>) a
superscript (<span class="math">\(X^{k}\)</span>).  The only other change with regard to the
sympy latex printer is that matrices are printed full size (equation
displaystyle).</p>
</div>
</div>
<div class="section" id="printer-redirection">
<h3>Printer Redirection<a class="headerlink" href="#printer-redirection" title="Permalink to this headline">¶</a></h3>
<p>In order to print transparently, that is to simply use the <em>print</em> statement
with both text and LaTeX printing the printer output is redirected.  In
the case of text printing the reason for redirecting the printer output
is because the <em>sympy</em> printing functions <em>_print_Derivative</em> and
<em>_print_Function</em> are redefined to make the output more compact.  If one
does not wish to use the compact notation redirection is not required for
the text printer.  If one wishes to use the redefined <em>_print_Derivative</em>
and <em>_print_Function</em> the printer should be redirected with the function
<em>ga_print_on()</em> and restored with the function <em>ga_print_off()</em>.  Both
functions can be imported from <em>sympy.galgebra.ga</em>
(see <em>examples/galgebra/terminal_check.py</em> for usage).</p>
<p>For LaTeX printing the <em>Format()</em> (import from <em>sympy.galgebra.ga</em>) redirects the printer output to a
string.  After all printing requests one must call the function <em>xdvi()</em>
(import from <em>sympy.galgebra.printing</em>) tp process the string to a LaTeX format, compile with
pdflatex, and displayed the resulting pdf file.  The function <em>xdvi()</em>
also restores the printer output to normal for standard <em>sympy</em> printing.
If <em>Format(ipy=True)</em> is used there is no printer redirection and the
LaTeX output is simply sent to <em>sys.stdout</em> for use in <em>Ipython</em>
(<em>Ipython</em> LaTeX interface for <em>galgebra</em> not yet implemented).</p>
</div>
<div class="section" id="other-printing-functions">
<h3>Other Printing Functions<a class="headerlink" href="#other-printing-functions" title="Permalink to this headline">¶</a></h3>
<p>These functions are used together if one wishes to print both code and
output in a single file.  They work for text printing and for latex printing.</p>
<p>For these functions to work properly the last function defined must not
contain a <em>Print_Function()</em> call (the last function defined is usually a
<em>dummy()</em> function that does nothing).</p>
<p>Additionally, to work properly none of the functions containing <em>Print_Function()</em>
can contain function definintions (local functions).</p>
<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.printing.Get_Program">
<tt class="descclassname">sympy.galgebra.printing.</tt><tt class="descname">Get_Program</tt><big>(</big><em>off=False</em><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.printing.Get_Program" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells program to print both code and output from functions that have been
properly tagged with <em>Print_Function()</em>.  <em>Get_Program()</em> must be in
main program before the functions that you wish code printing from are
executed. the <em>off</em> argument in <em>Get_Program()</em> allows one to turn off
the printing of the code by changing one line in the entire program
(<em>off=True</em>).</p>
</dd></dl>

<dl class="function">
<dt id="sympy.galgebra.ga.sympy.galgebra.printing.Print_Function">
<tt class="descclassname">sympy.galgebra.printing.</tt><tt class="descname">Print_Function</tt><big>(</big><big>)</big><a class="headerlink" href="#sympy.galgebra.ga.sympy.galgebra.printing.Print_Function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Print_Function()</em> is included in those functions where one wishes to
print the code block along with (before) the usual printed output.  The
<em>Print_Function()</em> statement should be included immediately after the
function def statement.  For proper usage of both  <em>Print_Function()</em>
and <em>Get_Program()</em> see the following example.</p>
</dd></dl>

<p>As an example consider the following code</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span><span class="p">,</span><span class="n">Get_Program</span><span class="p">,</span><span class="n">Print_Function</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Format</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">basic_multivector_operations_3D</span><span class="p">():</span>
    <span class="n">Print_Function</span><span class="p">()</span>
    <span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">,</span><span class="n">ez</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e*x|y|z&#39;</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;mv&#39;</span><span class="p">)</span>

    <span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;A&#39;</span><span class="p">)</span>

    <span class="n">A</span><span class="o">.</span><span class="n">even</span><span class="p">()</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;%A_{+}&#39;</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">odd</span><span class="p">()</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;%A_{-}&#39;</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>

    <span class="k">print</span> <span class="s">&#39;g_{ij} =&#39;</span><span class="p">,</span><span class="n">MV</span><span class="o">.</span><span class="n">metric</span>

    <span class="n">X</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">)</span>
    <span class="n">Y</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;Y&#39;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;X*Y&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">X</span><span class="o">^</span><span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;X^Y&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">X</span><span class="o">|</span><span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;X|Y&#39;</span><span class="p">)</span>
    <span class="k">return</span>

<span class="k">def</span> <span class="nf">basic_multivector_operations_2D</span><span class="p">():</span>
    <span class="n">Print_Function</span><span class="p">()</span>
    <span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e*x|y&#39;</span><span class="p">)</span>

    <span class="k">print</span> <span class="s">&#39;g_{ij} =&#39;</span><span class="p">,</span><span class="n">MV</span><span class="o">.</span><span class="n">metric</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;spinor&#39;</span><span class="p">)</span>

    <span class="n">X</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;A&#39;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">X</span><span class="o">|</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;X|A&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">X</span><span class="o">&lt;</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;X&lt;A&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">A</span><span class="o">&gt;</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;A&gt;X&#39;</span><span class="p">)</span>
    <span class="k">return</span>

<span class="k">def</span> <span class="nf">dummy</span><span class="p">():</span>
    <span class="k">return</span>

<span class="n">Get_Program</span><span class="p">()</span>

<span class="n">basic_multivector_operations_3D</span><span class="p">()</span>
<span class="n">basic_multivector_operations_2D</span><span class="p">()</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>The latex output of the code is</p>
<img alt="../../_images/simple_test_latex_1.png" src="../../_images/simple_test_latex_1.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="../../_images/simple_test_latex_2.png" src="../../_images/simple_test_latex_2.png" />
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="algebra">
<h3>Algebra<a class="headerlink" href="#algebra" title="Permalink to this headline">¶</a></h3>
<div class="section" id="bac-cab-formulas">
<h4>BAC-CAB Formulas<a class="headerlink" href="#bac-cab-formulas" title="Permalink to this headline">¶</a></h4>
<p>This example demonstrates the most general metric tensor</p>
<div class="math">
\[\begin{equation*}
g_{ij} = \left [ \begin{array}{cccc} \left ( a\cdot a\right )  & \left ( a\cdot b\right )  & \left ( a\cdot c\right )  & \left ( a\cdot d\right )  \\
\left ( a\cdot b\right )  & \left ( b\cdot b\right )  & \left ( b\cdot c\right )  & \left ( b\cdot d\right )  \\
\left ( a\cdot c\right )  & \left ( b\cdot c\right )  & \left ( c\cdot c\right )  & \left ( c\cdot d\right )  \\
\left ( a\cdot d\right )  & \left ( b\cdot d\right )  & \left ( c\cdot d\right )  & \left ( d\cdot d\right )
\end{array}\right ]
\end{equation*}\]</div><p>and how the <em>galgebra</em> module can be used to verify and expand geometric algebra identities consisting of relations between
the abstract vectors <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, <span class="math">\(c\)</span>, and <span class="math">\(d\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Format</span><span class="p">()</span>

<span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;a b c d&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b*c)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b^c)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b^c^d)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b^c)+c|(a^b)+b|(c^a)} =&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">))</span><span class="o">+</span><span class="p">(</span><span class="n">c</span><span class="o">|</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">))</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="o">|</span><span class="p">(</span><span class="n">c</span><span class="o">^</span><span class="n">a</span><span class="p">))</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a*(b^c)-b*(a^c)+c*(a^b)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a*(b^c^d)-b*(a^c^d)+c*(a^b^d)-d*(a^b^c)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">^</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{(a^b)|(c^d)} =&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{((a^b)|c)|d} =&#39;</span><span class="p">,((</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="n">c</span><span class="p">)</span><span class="o">|</span><span class="n">d</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{(a^b)</span><span class="se">\\</span><span class="s">times (c^d)} =&#39;</span><span class="p">,</span><span class="n">Com</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
<p>The preceeding code block also demonstrates the mapping of <em>*</em>, <em>^</em>, and <em>|</em> to appropriate latex
symbols.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <span class="math">\(\times\)</span> symbol is the commutator product of two multivectors, <span class="math">\(A\times B = (AB-BA)/2\)</span>.</p>
</div>
<div class="math">
\[\begin{align*}
\boldsymbol{a\cdot (b c)} =& - \left ( a\cdot c\right ) \boldsymbol{b}+\left ( a\cdot b\right ) \boldsymbol{c} \\
\boldsymbol{a\cdot (b\wedge c)} =& - \left ( a\cdot c\right ) \boldsymbol{b}+\left ( a\cdot b\right ) \boldsymbol{c} \\
\boldsymbol{a\cdot (b\wedge c\wedge d)} =& \left ( a\cdot d\right ) \boldsymbol{b\wedge c}- \left ( a\cdot c\right ) \boldsymbol{b\wedge d}+\left ( a\cdot b\right ) \boldsymbol{c\wedge d} \\
\boldsymbol{a\cdot (b\wedge c)+c\cdot (a\wedge b)+b\cdot (c\wedge a)} =& 0 \\
\boldsymbol{a (b\wedge c)-b (a\wedge c)+c (a\wedge b)} =& 3\boldsymbol{a\wedge b\wedge c} \\
\boldsymbol{a (b\wedge c\wedge d)-b (a\wedge c\wedge d)+c (a\wedge b\wedge d)-d (a\wedge b\wedge c)} =& 4\boldsymbol{a\wedge b\wedge c\wedge d} \\
\boldsymbol{(a\wedge b)\cdot (c\wedge d)} =& - \left ( a\cdot c\right )  \left ( b\cdot d\right )  + \left ( a\cdot d\right )  \left ( b\cdot c\right ) \\
\boldsymbol{((a\wedge b)\cdot c)\cdot d} =& - \left ( a\cdot c\right )  \left ( b\cdot d\right )  + \left ( a\cdot d\right )  \left ( b\cdot c\right ) \\
\boldsymbol{(a\wedge b)\times (c\wedge d)} =& - \left ( b\cdot d\right ) \boldsymbol{a\wedge c}+\left ( b\cdot c\right ) \boldsymbol{a\wedge d}+\left ( a\cdot d\right ) \boldsymbol{b\wedge c}- \left ( a\cdot c\right ) \boldsymbol{b\wedge d}
\end{align*}\]</div></div>
<div class="section" id="reciprocal-frame">
<h4>Reciprocal Frame<a class="headerlink" href="#reciprocal-frame" title="Permalink to this headline">¶</a></h4>
<p>The reciprocal frame of vectors with respect to the basis vectors is required
for the evaluation of the geometric dervative.  The following example demonstrates
that for the case of an arbitrary 3-dimensional Euclidian basis the reciprocal
basis vectors are correctly calculated.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Format</span><span class="p">()</span>

<span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;1 # #,&#39;</span><span class="o">+</span> \
         <span class="s">&#39;# 1 #,&#39;</span><span class="o">+</span> \
         <span class="s">&#39;# # 1,&#39;</span>

<span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e1 e2 e3&#39;</span><span class="p">,</span><span class="n">metric</span><span class="p">)</span>

<span class="n">E</span> <span class="o">=</span> <span class="n">e1</span><span class="o">^</span><span class="n">e2</span><span class="o">^</span><span class="n">e3</span>
<span class="n">Esq</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E =&#39;</span><span class="p">,</span><span class="n">E</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="si">%E</span><span class="s">^{2} =&#39;</span><span class="p">,</span><span class="n">Esq</span>
<span class="n">Esq_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Esq</span>

<span class="n">E1</span> <span class="o">=</span> <span class="p">(</span><span class="n">e2</span><span class="o">^</span><span class="n">e3</span><span class="p">)</span><span class="o">*</span><span class="n">E</span>
<span class="n">E2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">e1</span><span class="o">^</span><span class="n">e3</span><span class="p">)</span><span class="o">*</span><span class="n">E</span>
<span class="n">E3</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1</span><span class="o">^</span><span class="n">e2</span><span class="p">)</span><span class="o">*</span><span class="n">E</span>

<span class="k">print</span> <span class="s">&#39;E1 = (e2^e3)*E =&#39;</span><span class="p">,</span><span class="n">E1</span>
<span class="k">print</span> <span class="s">&#39;E2 =-(e1^e3)*E =&#39;</span><span class="p">,</span><span class="n">E2</span>
<span class="k">print</span> <span class="s">&#39;E3 = (e1^e2)*E =&#39;</span><span class="p">,</span><span class="n">E3</span>

<span class="k">print</span> <span class="s">&#39;E1|e2 =&#39;</span><span class="p">,(</span><span class="n">E1</span><span class="o">|</span><span class="n">e2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E1|e3 =&#39;</span><span class="p">,(</span><span class="n">E1</span><span class="o">|</span><span class="n">e3</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E2|e1 =&#39;</span><span class="p">,(</span><span class="n">E2</span><span class="o">|</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E2|e3 =&#39;</span><span class="p">,(</span><span class="n">E2</span><span class="o">|</span><span class="n">e3</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E3|e1 =&#39;</span><span class="p">,(</span><span class="n">E3</span><span class="o">|</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E3|e2 =&#39;</span><span class="p">,(</span><span class="n">E3</span><span class="o">|</span><span class="n">e2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">((</span><span class="n">E1</span><span class="o">|</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="n">Esq</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">Esq</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;%(E1</span><span class="se">\\</span><span class="s">cdot e1)/E^{2} =&#39;</span><span class="p">,</span><span class="n">simplify</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">Esq</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">((</span><span class="n">E2</span><span class="o">|</span><span class="n">e2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;%(E2</span><span class="se">\\</span><span class="s">cdot e2)/E^{2} =&#39;</span><span class="p">,</span><span class="n">simplify</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">Esq</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">((</span><span class="n">E3</span><span class="o">|</span><span class="n">e3</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;%(E3</span><span class="se">\\</span><span class="s">cdot e3)/E^{2} =&#39;</span><span class="p">,</span><span class="n">simplify</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">Esq</span><span class="p">)</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
<p>The preceeding code also demonstrated the use of the <em>%</em> directive in
printing a string so that <em>^</em> is treated literally and not translated
to <em>\wedge</em>. Note that <tt class="docutils literal"><span class="pre">'%E^{2}</span> <span class="pre">='</span></tt> is printed as <span class="math">\(E^{2} =\)</span>
and not as <span class="math">\(E\wedge {2} =\)</span>.</p>
<div class="math">
\[\begin{align*}
E =& \boldsymbol{e_{1}\wedge e_{2}\wedge e_{3}} \\
E^{2} =& \left ( e_{1}\cdot e_{2}\right ) ^{2} - 2 \left ( e_{1}\cdot e_{2}\right )  \left ( e_{1}\cdot e_{3}\right )  \left ( e_{2}\cdot e_{3}\right )  + \left ( e_{1}\cdot e_{3}\right ) ^{2} + \left ( e_{2}\cdot e_{3}\right ) ^{2} -1 \\
E1 =& (e2\wedge e3) E = \left ( \left ( e_{2}\cdot e_{3}\right ) ^{2} -1\right ) \boldsymbol{e_{1}}+\left ( \left ( e_{1}\cdot e_{2}\right )  - \left ( e_{1}\cdot e_{3}\right )  \left ( e_{2}\cdot e_{3}\right ) \right ) \boldsymbol{e_{2}}+\left ( - \left ( e_{1}\cdot e_{2}\right )  \left ( e_{2}\cdot e_{3}\right )  + \left ( e_{1}\cdot e_{3}\right ) \right ) \boldsymbol{e_{3}} \\
E2 =& -(e1\wedge e3) E = \left ( \left ( e_{1}\cdot e_{2}\right )  - \left ( e_{1}\cdot e_{3}\right )  \left ( e_{2}\cdot e_{3}\right ) \right ) \boldsymbol{e_{1}}+\left ( \left ( e_{1}\cdot e_{3}\right ) ^{2} -1\right ) \boldsymbol{e_{2}}+\left ( - \left ( e_{1}\cdot e_{2}\right )  \left ( e_{1}\cdot e_{3}\right )  + \left ( e_{2}\cdot e_{3}\right ) \right ) \boldsymbol{e_{3}} \\
E3 =& (e1\wedge e2) E = \left ( - \left ( e_{1}\cdot e_{2}\right )  \left ( e_{2}\cdot e_{3}\right )  + \left ( e_{1}\cdot e_{3}\right ) \right ) \boldsymbol{e_{1}}+\left ( - \left ( e_{1}\cdot e_{2}\right )  \left ( e_{1}\cdot e_{3}\right )  + \left ( e_{2}\cdot e_{3}\right ) \right ) \boldsymbol{e_{2}}+\left ( \left ( e_{1}\cdot e_{2}\right ) ^{2} -1\right ) \boldsymbol{e_{3}} \\
E1\cdot e2 =& 0 \\
E1\cdot e3 =& 0 \\
E2\cdot e1 =& 0 \\
E2\cdot e3 =& 0 \\
E3\cdot e1 =& 0 \\
E3\cdot e2 =& 0 \\
(E1\cdot e1)/E^{2} =& 1 \\
(E2\cdot e2)/E^{2} =& 1 \\
(E3\cdot e3)/E^{2} =& 1
\end{align*}\]</div><p>The formulas derived for <span class="math">\(E1\)</span>, <span class="math">\(E2\)</span>, <span class="math">\(E3\)</span>, and <span class="math">\(E^{2}\)</span> could
also be applied to the numerical calculations of crystal properties.</p>
</div>
<div class="section" id="lorentz-transformation">
<h4>Lorentz-Transformation<a class="headerlink" href="#lorentz-transformation" title="Permalink to this headline">¶</a></h4>
<p>A simple physics demonstation of geometric algebra is the derivation of
the Lorentz-Transformation.  In this demonstration a 2-dimensional
Minkowski space is defined and the Lorentz-Transformation is generated
from a rotation of a vector in the Minkowski space using the rotor
<span class="math">\(R\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span><span class="n">sinh</span><span class="p">,</span><span class="n">cosh</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Format</span><span class="p">()</span>
<span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;alpha beta gamma&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">xp</span><span class="p">,</span><span class="n">tp</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;x t x&#39; t&#39;&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma*t|x&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,-1]&#39;</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">cosh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">sinh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">g0</span><span class="o">^</span><span class="n">g1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">g0</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="n">g1</span>
<span class="n">Xp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">*</span><span class="n">g0</span><span class="o">+</span><span class="n">xp</span><span class="o">*</span><span class="n">g1</span>

<span class="k">print</span> <span class="s">&#39;R =&#39;</span><span class="p">,</span><span class="n">R</span>
<span class="k">print</span> <span class="s">r&quot;#%t\bm{\gamma_{t}}+x\bm{\gamma_{x}} = t&#39;\bm{\gamma&#39;_{t}}+x&#39;\bm{\gamma&#39;_{x}} &quot;</span><span class="o">+</span>
      <span class="s">r&quot;= R\left ( t&#39;\bm{\gamma_{t}}+x&#39;\bm{\gamma_{x}}\right ) R^{\dagger}&quot;</span>

<span class="n">Xpp</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">Xp</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">rev</span><span class="p">()</span>
<span class="n">Xpp</span> <span class="o">=</span> <span class="n">Xpp</span><span class="o">.</span><span class="n">collect</span><span class="p">([</span><span class="n">xp</span><span class="p">,</span><span class="n">tp</span><span class="p">])</span>
<span class="n">Xpp</span> <span class="o">=</span> <span class="n">Xpp</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span><span class="n">sinh</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span>\
               <span class="n">sinh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">cosh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span><span class="n">cosh</span><span class="p">(</span><span class="n">alpha</span><span class="p">)})</span>
<span class="k">print</span> <span class="s">r&quot;%t\bm{\gamma_{t}}+x\bm{\gamma_{x}} =&quot;</span><span class="p">,</span><span class="n">Xpp</span>
<span class="n">Xpp</span> <span class="o">=</span> <span class="n">Xpp</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">sinh</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span><span class="n">gamma</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span><span class="n">cosh</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span><span class="n">gamma</span><span class="p">})</span>

<span class="k">print</span> <span class="s">r&#39;%\f{\sinh}{\alpha} = \gamma\beta&#39;</span>
<span class="k">print</span> <span class="s">r&#39;%\f{\cosh}{\alpha} = \gamma&#39;</span>

<span class="k">print</span> <span class="s">r&quot;%t\bm{\gamma_{t}}+x\bm{\gamma_{x}} =&quot;</span><span class="p">,</span><span class="n">Xpp</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
<p>The preceeding code also demonstrates how to use the sympy <em>subs</em> functions
to perform the hyperbolic half angle transformation.  The code also shows
the use of both the <em>#</em> and <em>%</em> directives in the text string
<tt class="docutils literal"><span class="pre">r&quot;#%t\bm{\gamma_{t}}+x\bm{\gamma_{x}}</span> <span class="pre">=</span> <span class="pre">t'\bm{\gamma'_{t}}+x'\bm{\gamma'_{x}}</span> <span class="pre">=</span> <span class="pre">R\left</span> <span class="pre">(</span> <span class="pre">t'\bm{\gamma_{t}}+x'\bm{\gamma_{x}}\right</span> <span class="pre">)</span> <span class="pre">R^{\dagger}&quot;</span></tt>.
Both the <em>#</em> and <em>%</em> are needed in this text string for two reasons.  First, the text string contains an <em>=</em> sign.  The latex preprocessor
uses this a key to combine the text string with a sympy expression to be printed after the text string.  The <em>#</em> is required to inform
the preprocessor that there is no sympy expression to follow.  Second, the <em>%</em> is requires to inform the preprocessor that the text
string is to be displayed in latex math mode and not in text mode (if <em>#</em> is present the default latex mode is text mode unless
overridden by the <em>%</em> directive).</p>
<div class="math">
\[\begin{align*} R =& \cosh{\left (\frac{1}{2} \alpha \right )}+\sinh{\left (\frac{1}{2} \alpha \right )}\boldsymbol{\gamma_{t}\wedge \gamma_{x}} \\
t\boldsymbol{\gamma_{t}}+x\boldsymbol{\gamma_{x}} =& t'\boldsymbol{\gamma'_{t}}+x'\boldsymbol{\gamma'_{x}} = R\left ( t'\boldsymbol{\gamma_{t}}+x'\boldsymbol{\gamma_{x}}\right ) R^{\dagger} \\
t\boldsymbol{\gamma_{t}}+x\boldsymbol{\gamma_{x}} =& \left ( t' \cosh{\left (\alpha \right )} - x' \sinh{\left (\alpha \right )}\right ) \boldsymbol{\gamma_{t}}+\left ( - t' \sinh{\left (\alpha \right )} + x' \cosh{\left (\alpha \right )}\right ) \boldsymbol{\gamma_{x}} \\
{\sinh}\left ( {\alpha} \right ) =& \gamma\beta \\
{\cosh}\left ( {\alpha} \right ) =& \gamma \\
t\boldsymbol{\gamma_{t}}+x\boldsymbol{\gamma_{x}} =& \left ( \gamma \left(- \beta x' + t'\right)\right ) \boldsymbol{\gamma_{t}}+\left ( \gamma \left(- \beta t' + x'\right)\right ) \boldsymbol{\gamma_{x}}
\end{align*}\]</div></div>
</div>
<div class="section" id="calculus">
<h3>Calculus<a class="headerlink" href="#calculus" title="Permalink to this headline">¶</a></h3>
<div class="section" id="derivatives-in-spherical-coordinates">
<h4>Derivatives in Spherical Coordinates<a class="headerlink" href="#derivatives-in-spherical-coordinates" title="Permalink to this headline">¶</a></h4>
<p>The following code shows how to use <em>galgebra</em> to use spherical coordinates.
The gradient of a scalar function, <span class="math">\(f\)</span>, the divergence and curl
of a vector function, <span class="math">\(A\)</span>, and the exterior derivative (curl) of
a bivector function, <span class="math">\(B\)</span> are calculated.  Note that to get the
standard curl of a 3-dimension function the result is multiplied by
<span class="math">\(-I\)</span> the negative of the pseudoscalar.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In geometric calculus the operator <span class="math">\(\nabla^{2}\)</span> is well defined
on its own as the geometic derivative of the geometric derivative.
However, if needed we have for the vector function <span class="math">\(A\)</span> the relations
(since <span class="math">\(\nabla\cdot A\)</span> is a scalar it&#8217;s curl is equal to it&#8217;s
geometric derivative and it&#8217;s divergence is zero) -</p>
<div class="math">
\[\begin{align*}
\nabla A =& \nabla\wedge A + \nabla\cdot A \\
\nabla^{2} A =& \nabla\left ( {{\nabla\wedge A}} \right ) + \nabla\left ( {{\nabla\cdot A}} \right ) \\
\nabla^{2} A =& \nabla\wedge\left ( {{\nabla\wedge A}} \right ) + \nabla\cdot\left ( {{\nabla\wedge A}} \right )
+\nabla\wedge\left ( {{\nabla\cdot A}} \right ) + \nabla\cdot\left ( {{\nabla\cdot A}} \right ) \\
\nabla^{2} A =& \nabla\wedge\left ( {{\nabla\wedge A}} \right ) + \left ( {{\nabla\cdot\nabla}} \right ) A
- \nabla\left ( {{\nabla\cdot A}} \right ) + \nabla\left ( {{\nabla\cdot A}} \right ) \\
\nabla^{2} A =& \nabla\wedge\nabla\wedge A + \left ( {{\nabla\cdot\nabla}} \right )A
\end{align*}\]</div><p class="last">In the derivation we have used that <span class="math">\(\nabla\cdot\left ( {{\nabla\wedge A}} \right ) = \left ( {{\nabla\cdot\nabla}} \right )A - \nabla\left ( {{\nabla\cdot A}} \right )\)</span>
which is implicit in the second <em>BAC-CAB</em> formula.
No parenthesis is needed for the geometric curl of the curl (exterior derivative of exterior derivative)
since the <span class="math">\(\wedge\)</span> operation is associative unlike the vector curl operator and <span class="math">\(\nabla\cdot\nabla\)</span> is the usual Laplacian
operator.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span><span class="n">cos</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Format</span><span class="p">()</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r theta phi&#39;</span><span class="p">)</span>
<span class="n">curv</span> <span class="o">=</span> <span class="p">[[</span><span class="n">r</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)],[</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)]]</span>
<span class="p">(</span><span class="n">er</span><span class="p">,</span><span class="n">eth</span><span class="p">,</span><span class="n">ephi</span><span class="p">,</span><span class="n">grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;e_r e_theta e_phi&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,1,1]&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">curv</span><span class="o">=</span><span class="n">curv</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;grade2&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;A =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="k">print</span> <span class="s">&#39;B =&#39;</span><span class="p">,</span><span class="n">B</span>

<span class="k">print</span> <span class="s">&#39;grad*f =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">*</span><span class="n">f</span>
<span class="k">print</span> <span class="s">&#39;grad|A =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">|</span><span class="n">A</span>
<span class="k">print</span> <span class="s">&#39;-I*(grad^A) =&#39;</span><span class="p">,</span><span class="o">-</span><span class="n">MV</span><span class="o">.</span><span class="n">I</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="o">^</span><span class="n">A</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;grad^B =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">^</span><span class="n">B</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
<p>Results of code</p>
<div class="math">
\[\begin{align*}
A =& A^{r}\boldsymbol{e_{r}}+A^{\theta}\boldsymbol{e_{\theta}}+A^{\phi}\boldsymbol{e_{\phi}} \\
B =& B^{r\theta}\boldsymbol{e_{r}\wedge e_{\theta}}+B^{r\phi}\boldsymbol{e_{r}\wedge e_{\phi}}+B^{\theta\phi}\boldsymbol{e_{\theta}\wedge e_{\phi}} \\
\boldsymbol{\nabla}  f =& \partial_{r} f\boldsymbol{e_{r}}+\frac{\partial_{\theta} f}{r}\boldsymbol{e_{\theta}}+\frac{\partial_{\phi} f}{r \sin{\left (\theta \right )}}\boldsymbol{e_{\phi}} \\
\boldsymbol{\nabla} \cdot A =& \partial_{r} A^{r} + \frac{A^{\theta}}{r \tan{\left (\theta \right )}} + 2 \frac{A^{r}}{r} + \frac{\partial_{\theta} A^{\theta}}{r} + \frac{\partial_{\phi} A^{\phi}}{r \sin{\left (\theta \right )}} \\
-I (\boldsymbol{\nabla} \wedge A) =& \left ( \frac{A^{\phi} \cos{\left (\theta \right )} + \sin{\left (\theta \right )} \partial_{\theta} A^{\phi} - \partial_{\phi} A^{\theta}}{r \sin{\left (\theta \right )}}\right ) \boldsymbol{e_{r}}+\left ( - \partial_{r} A^{\phi} - \frac{A^{\phi}}{r} + \frac{\partial_{\phi} A^{r}}{r \sin{\left (\theta \right )}}\right ) \boldsymbol{e_{\theta}}+\left ( \frac{r \partial_{r} A^{\theta} + A^{\theta} - \partial_{\theta} A^{r}}{r}\right ) \boldsymbol{e_{\phi}} \\
\boldsymbol{\nabla} \wedge B =& \left ( \partial_{r} B^{\theta\phi} + 2 \frac{B^{\theta\phi}}{r} - \frac{B^{r\phi}}{r \tan{\left (\theta \right )}} - \frac{\partial_{\theta} B^{r\phi}}{r} + \frac{\partial_{\phi} B^{r\theta}}{r \sin{\left (\theta \right )}}\right ) \boldsymbol{e_{r}\wedge e_{\theta}\wedge e_{\phi}}
\end{align*}\]</div></div>
<div class="section" id="maxwell-s-equations">
<h4>Maxwell&#8217;s Equations<a class="headerlink" href="#maxwell-s-equations" title="Permalink to this headline">¶</a></h4>
<p>The geometric algebra formulation of Maxwell&#8217;s equations is deomonstrated
with the formalism developed in &#8220;Geometric Algebra for Physicists&#8221; <a class="reference internal" href="#doran">[Doran]</a>.
In this formalism the signature of the metric is <span class="math">\((1,-1,-1,-1)\)</span> and the
basis vectors are <span class="math">\(\gamma_{t}\)</span>, <span class="math">\(\gamma_{x}\)</span>, <span class="math">\(\gamma_{y}\)</span>,
and <span class="math">\(\gamma_{z}\)</span>.  The if <span class="math">\(\boldsymbol{E}\)</span> and <span class="math">\(\boldsymbol{B}\)</span> are the
normal electric and magnetic field vectors the electric and magnetic
bivectors are given by <span class="math">\(E = \boldsymbol{E}\gamma_{t}\)</span> and <span class="math">\(B = \boldsymbol{B}\gamma_{t}\)</span>.
The electromagnetic bivector is then <span class="math">\(F = E+IB\)</span> where
<span class="math">\(I = \gamma_{t}\gamma_{x}\gamma_{y}\gamma_{z}\)</span> is the pesudo-scalar
for the Minkowski space.  Note that the electromagnetic bivector is isomorphic
to the electromagnetic tensor.  Then if <span class="math">\(J\)</span> is the 4-current all of
Maxwell&#8217;s equations are given by <span class="math">\(\boldsymbol{\nabla}F = J\)</span>.  For more details
see <a class="reference internal" href="#doran">[Doran]</a> chapter 7.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span><span class="n">sin</span><span class="p">,</span><span class="n">cos</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Format</span><span class="p">()</span>

<span class="nb">vars</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">,</span><span class="n">grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma*t|x|y|z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,-1,-1,-1]&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="nb">vars</span><span class="p">)</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">I</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;E&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">B</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">E</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">B</span> <span class="o">*=</span> <span class="n">g0</span>
<span class="n">E</span> <span class="o">*=</span> <span class="n">g0</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;J&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">I</span><span class="o">*</span><span class="n">B</span>

<span class="k">print</span> <span class="s">&#39;B = </span><span class="se">\\</span><span class="s">bm{B</span><span class="se">\\</span><span class="s">gamma_{t}} =&#39;</span><span class="p">,</span><span class="n">B</span>
<span class="k">print</span> <span class="s">&#39;E = </span><span class="se">\\</span><span class="s">bm{E</span><span class="se">\\</span><span class="s">gamma_{t}} =&#39;</span><span class="p">,</span><span class="n">E</span>
<span class="k">print</span> <span class="s">&#39;F = E+IB =&#39;</span><span class="p">,</span><span class="n">F</span>
<span class="k">print</span> <span class="s">&#39;J =&#39;</span><span class="p">,</span><span class="n">J</span>
<span class="n">gradF</span> <span class="o">=</span> <span class="n">grad</span><span class="o">*</span><span class="n">F</span>
<span class="n">gradF</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;grad*F&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;grad*F = J&#39;</span>
<span class="p">(</span><span class="n">gradF</span><span class="o">.</span><span class="n">grade</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;%</span><span class="se">\\</span><span class="s">grade{</span><span class="se">\\</span><span class="s">nabla F}_{1} -J = 0&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">gradF</span><span class="o">.</span><span class="n">grade</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;%</span><span class="se">\\</span><span class="s">grade{</span><span class="se">\\</span><span class="s">nabla F}_{3} = 0&#39;</span><span class="p">)</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
<div class="math">
\[\begin{align*}
B =& \boldsymbol{B\gamma_{t}} = - B^{x}\boldsymbol{\gamma_{t}\wedge \gamma_{x}}- B^{y}\boldsymbol{\gamma_{t}\wedge \gamma_{y}}- B^{z}\boldsymbol{\gamma_{t}\wedge \gamma_{z}} \\
E =& \boldsymbol{E\gamma_{t}} = - E^{x}\boldsymbol{\gamma_{t}\wedge \gamma_{x}}- E^{y}\boldsymbol{\gamma_{t}\wedge \gamma_{y}}- E^{z}\boldsymbol{\gamma_{t}\wedge \gamma_{z}} \\
F =& E+IB = - E^{x}\boldsymbol{\gamma_{t}\wedge \gamma_{x}}- E^{y}\boldsymbol{\gamma_{t}\wedge \gamma_{y}}- E^{z}\boldsymbol{\gamma_{t}\wedge \gamma_{z}}- B^{z}\boldsymbol{\gamma_{x}\wedge \gamma_{y}}+B^{y}\boldsymbol{\gamma_{x}\wedge \gamma_{z}}- B^{x}\boldsymbol{\gamma_{y}\wedge \gamma_{z}} \\
J =& J^{t}\boldsymbol{\gamma_{t}}+J^{x}\boldsymbol{\gamma_{x}}+J^{y}\boldsymbol{\gamma_{y}}+J^{z}\boldsymbol{\gamma_{z}} \\
\boldsymbol{\nabla}  F =& \left ( \partial_{x} E^{x} + \partial_{y} E^{y} + \partial_{z} E^{z}\right ) \boldsymbol{\gamma_{t}} \\
& +\left ( - \partial_{z} B^{y} + \partial_{y} B^{z} - \partial_{t} E^{x}\right ) \boldsymbol{\gamma_{x}} \\
& +\left ( \partial_{z} B^{x} - \partial_{x} B^{z} - \partial_{t} E^{y}\right ) \boldsymbol{\gamma_{y}} \\
& +\left ( - \partial_{y} B^{x} + \partial_{x} B^{y} - \partial_{t} E^{z}\right ) \boldsymbol{\gamma_{z}} \\
& +\left ( - \partial_{t} B^{z} + \partial_{y} E^{x} - \partial_{x} E^{y}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{x}\wedge \gamma_{y}} \\
& +\left ( \partial_{t} B^{y} + \partial_{z} E^{x} - \partial_{x} E^{z}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{x}\wedge \gamma_{z}} \\
& +\left ( - \partial_{t} B^{x} + \partial_{z} E^{y} - \partial_{y} E^{z}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{y}\wedge \gamma_{z}} \\
& +\left ( \partial_{x} B^{x} + \partial_{y} B^{y} + \partial_{z} B^{z}\right ) \boldsymbol{\gamma_{x}\wedge \gamma_{y}\wedge \gamma_{z}} \\
\boldsymbol{\nabla}  F =& J \\
\left < {{\nabla F}} \right >_{1} -J = 0 =  & \left ( - J^{t} + \partial_{x} E^{x} + \partial_{y} E^{y} + \partial_{z} E^{z}\right ) \boldsymbol{\gamma_{t}} \\
& +\left ( - J^{x} - \partial_{z} B^{y} + \partial_{y} B^{z} - \partial_{t} E^{x}\right ) \boldsymbol{\gamma_{x}} \\
& +\left ( - J^{y} + \partial_{z} B^{x} - \partial_{x} B^{z} - \partial_{t} E^{y}\right ) \boldsymbol{\gamma_{y}} \\
& +\left ( - J^{z} - \partial_{y} B^{x} + \partial_{x} B^{y} - \partial_{t} E^{z}\right ) \boldsymbol{\gamma_{z}} \\
\left < {{\nabla F}} \right >_{3} = 0 =  & \left ( - \partial_{t} B^{z} + \partial_{y} E^{x} - \partial_{x} E^{y}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{x}\wedge \gamma_{y}} \\
& +\left ( \partial_{t} B^{y} + \partial_{z} E^{x} - \partial_{x} E^{z}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{x}\wedge \gamma_{z}} \\
& +\left ( - \partial_{t} B^{x} + \partial_{z} E^{y} - \partial_{y} E^{z}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{y}\wedge \gamma_{z}} \\
& +\left ( \partial_{x} B^{x} + \partial_{y} B^{y} + \partial_{z} B^{z}\right ) \boldsymbol{\gamma_{x}\wedge \gamma_{y}\wedge \gamma_{z}}
\end{align*}\]</div></div>
<div class="section" id="dirac-equation">
<h4>Dirac Equation<a class="headerlink" href="#dirac-equation" title="Permalink to this headline">¶</a></h4>
<p>In <a class="reference internal" href="#doran">[Doran]</a> equation 8.89 (page 283) is the geometric algebra formulation of the Dirac equation.  In this equation
<span class="math">\(\psi\)</span> is an 8-component real spinor which is to say that it is a multivector with sacalar, bivector, and
pseudo-vector components in the space-time geometric algebra (it consists only of even grade components).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span><span class="n">sin</span><span class="p">,</span><span class="n">cos</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.printing</span> <span class="kn">import</span> <span class="n">xdvi</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.ga</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">Format</span><span class="p">()</span>

<span class="nb">vars</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">,</span><span class="n">grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma*t|x|y|z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,-1,-1,-1]&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="nb">vars</span><span class="p">)</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">I</span>
<span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;m e&#39;</span><span class="p">)</span>

<span class="n">psi</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;psi&#39;</span><span class="p">,</span><span class="s">&#39;spinor&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">sig_z</span> <span class="o">=</span> <span class="n">g3</span><span class="o">*</span><span class="n">g0</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{A} =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{</span><span class="se">\\</span><span class="s">psi} =&#39;</span><span class="p">,</span><span class="n">psi</span>

<span class="n">dirac_eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">grad</span><span class="o">*</span><span class="n">psi</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">sig_z</span><span class="o">-</span><span class="n">e</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">psi</span><span class="o">-</span><span class="n">m</span><span class="o">*</span><span class="n">psi</span><span class="o">*</span><span class="n">g0</span>
<span class="n">dirac_eq</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

<span class="n">dirac_eq</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">r&#39;\nabla \bm{\psi} I \sigma_{z}-e\bm{A}\bm{\psi}-m\bm{\psi}\gamma_{t} = 0&#39;</span><span class="p">)</span>

<span class="n">xdvi</span><span class="p">()</span>
</pre></div>
</div>
<p>The equations displayed are the partial differential equations for each component of the Dirac equation
in rectangular coordinates we the driver for the equations is the 4-potential <span class="math">\(A\)</span>.  One utility
of these equations is to setup a numerical solver for the Dirac equation.</p>
<div class="math">
\[\begin{align*}
\boldsymbol{A} =& A^{t}\boldsymbol{\gamma_{t}}+A^{x}\boldsymbol{\gamma_{x}}+A^{y}\boldsymbol{\gamma_{y}}+A^{z}\boldsymbol{\gamma_{z}} \\
\boldsymbol{\psi} =& \psi+\psi^{tx}\boldsymbol{\gamma_{t}\wedge \gamma_{x}}
                    +\psi^{ty}\boldsymbol{\gamma_{t}\wedge \gamma_{y}}
                    +\psi^{tz}\boldsymbol{\gamma_{t}\wedge \gamma_{z}}
                    +\psi^{xy}\boldsymbol{\gamma_{x}\wedge \gamma_{y}}
                    +\psi^{xz}\boldsymbol{\gamma_{x}\wedge \gamma_{z}}
                    +\psi^{yz}\boldsymbol{\gamma_{y}\wedge \gamma_{z}} \\
                    &+\psi^{txyz}\boldsymbol{\gamma_{t}\wedge \gamma_{x}\wedge \gamma_{y}\wedge \gamma_{z}} \\
\nabla \boldsymbol{\psi} I \sigma_{z}-e\boldsymbol{A}\boldsymbol{\psi}-m\boldsymbol{\psi}\gamma_{t} = 0 =  & \left ( - e A^{t} \psi - e A^{x} \psi^{tx} - e A^{y} \psi^{ty} - e A^{z} \psi^{tz} - m \psi - \partial_{y} \psi^{tx} - \partial_{z} \psi^{txyz} + \partial_{x} \psi^{ty} + \partial_{t} \psi^{xy}\right ) \boldsymbol{\gamma_{t}} \\
\hspace{-0.5in}& +\left ( - e A^{t} \psi^{tx} - e A^{x} \psi - e A^{y} \psi^{xy} - e A^{z} \psi^{xz} + m \psi^{tx} + \partial_{y} \psi - \partial_{t} \psi^{ty} - \partial_{x} \psi^{xy} + \partial_{z} \psi^{yz}\right ) \boldsymbol{\gamma_{x}} \\
\hspace{-0.5in}& +\left ( - e A^{t} \psi^{ty} + e A^{x} \psi^{xy} - e A^{y} \psi - e A^{z} \psi^{yz} + m \psi^{ty} - \partial_{x} \psi + \partial_{t} \psi^{tx} - \partial_{y} \psi^{xy} - \partial_{z} \psi^{xz}\right ) \boldsymbol{\gamma_{y}} \\
\hspace{-0.5in}& +\left ( - e A^{t} \psi^{tz} + e A^{x} \psi^{xz} + e A^{y} \psi^{yz} - e A^{z} \psi + m \psi^{tz} + \partial_{t} \psi^{txyz} - \partial_{z} \psi^{xy} + \partial_{y} \psi^{xz} - \partial_{x} \psi^{yz}\right ) \boldsymbol{\gamma_{z}} \\
\hspace{-0.5in}& +\left ( - e A^{t} \psi^{xy} + e A^{x} \psi^{ty} - e A^{y} \psi^{tx} - e A^{z} \psi^{txyz} - m \psi^{xy} - \partial_{t} \psi + \partial_{x} \psi^{tx} + \partial_{y} \psi^{ty} + \partial_{z} \psi^{tz}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{x}\wedge \gamma_{y}} \\
\hspace{-0.5in}& +\left ( - e A^{t} \psi^{xz} + e A^{x} \psi^{tz} + e A^{y} \psi^{txyz} - e A^{z} \psi^{tx} - m \psi^{xz} + \partial_{x} \psi^{txyz} + \partial_{z} \psi^{ty} - \partial_{y} \psi^{tz} - \partial_{t} \psi^{yz}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{x}\wedge \gamma_{z}} \\
\hspace{-0.5in}& +\left ( - e A^{t} \psi^{yz} - e A^{x} \psi^{txyz} + e A^{y} \psi^{tz} - e A^{z} \psi^{ty} - m \psi^{yz} - \partial_{z} \psi^{tx} + \partial_{y} \psi^{txyz} + \partial_{x} \psi^{tz} + \partial_{t} \psi^{xz}\right ) \boldsymbol{\gamma_{t}\wedge \gamma_{y}\wedge \gamma_{z}} \\
\hspace{-0.5in}& +\left ( - e A^{t} \psi^{txyz} - e A^{x} \psi^{yz} + e A^{y} \psi^{xz} - e A^{z} \psi^{xy} + m \psi^{txyz} + \partial_{z} \psi - \partial_{t} \psi^{tz} - \partial_{x} \psi^{xz} - \partial_{y} \psi^{yz}\right ) \boldsymbol{\gamma_{x}\wedge \gamma_{y}\wedge \gamma_{z}}
\end{align*}\]</div><table class="docutils citation" frame="void" id="doran" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Doran]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>, <a class="fn-backref" href="#id4">3</a>, <a class="fn-backref" href="#id5">4</a>, <a class="fn-backref" href="#id9">5</a>, <a class="fn-backref" href="#id10">6</a>, <a class="fn-backref" href="#id11">7</a>, <a class="fn-backref" href="#id12">8</a>, <a class="fn-backref" href="#id13">9</a>)</em> <a class="reference external" href="http://www.mrao.cam.ac.uk/~cjld1/pages/book.htm">http://www.mrao.cam.ac.uk/~cjld1/pages/book.htm</a>
<tt class="docutils literal"><span class="pre">Geometric</span> <span class="pre">Algebra</span> <span class="pre">for</span> <span class="pre">Physicists</span></tt> by C. Doran and A. Lasenby, Cambridge
University Press, 2003.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hestenes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Hestenes]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id7">3</a>, <a class="fn-backref" href="#id8">4</a>)</em> <a class="reference external" href="http://geocalc.clas.asu.edu/html/CA_to_GC.html">http://geocalc.clas.asu.edu/html/CA_to_GC.html</a>
<tt class="docutils literal"><span class="pre">Clifford</span> <span class="pre">Algebra</span> <span class="pre">to</span> <span class="pre">Geometric</span> <span class="pre">Calculus</span></tt> by D.Hestenes and G. Sobczyk, Kluwer
Academic Publishers, 1984.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="macdonald" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Macdonald]</td><td>&#8216;&lt;<a class="reference external" href="http://faculty.luther.edu/~macdonal">http://faculty.luther.edu/~macdonal</a>&gt;&#8217;_
<tt class="docutils literal"><span class="pre">Linear</span> <span class="pre">and</span> <span class="pre">Geometric</span> <span class="pre">Algebra</span></tt> by Alan Macdonald, <a class="reference external" href="http://www.amazon.com/Alan-Macdonald/e/B004MB2QJQ">http://www.amazon.com/Alan-Macdonald/e/B004MB2QJQ</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Geometric Algebra</a><ul>
<li><a class="reference internal" href="#what-is-geometric-algebra">What is Geometric Algebra?</a></li>
<li><a class="reference internal" href="#representation-of-multivectors-in-sympy">Representation of Multivectors in Sympy</a></li>
<li><a class="reference internal" href="#vector-basis-and-metric">Vector Basis and Metric</a></li>
<li><a class="reference internal" href="#representation-and-reduction-of-multivector-bases">Representation and Reduction of Multivector Bases</a></li>
<li><a class="reference internal" href="#base-representation-of-multivectors">Base Representation of Multivectors</a></li>
<li><a class="reference internal" href="#blade-representation-of-multivectors">Blade Representation of Multivectors</a></li>
<li><a class="reference internal" href="#outer-and-inner-products-left-and-right-contractions">Outer and Inner Products, Left and Right Contractions</a></li>
<li><a class="reference internal" href="#reverse-of-multivector">Reverse of Multivector</a></li>
<li><a class="reference internal" href="#reciprocal-frames">Reciprocal Frames</a></li>
<li><a class="reference internal" href="#geometric-derivative">Geometric Derivative</a></li>
<li><a class="reference internal" href="#numpy-latex-and-ansicon-installation">Numpy, LaTeX, and Ansicon Installation</a></li>
<li><a class="reference internal" href="#module-components">Module Components</a><ul>
<li><a class="reference internal" href="#initializing-multivector-class">Initializing Multivector Class</a></li>
<li><a class="reference internal" href="#instantiating-a-multivector">Instantiating a Multivector</a></li>
<li><a class="reference internal" href="#basic-multivector-class-functions">Basic Multivector Class Functions</a></li>
<li><a class="reference internal" href="#basic-multivector-functions">Basic Multivector Functions</a></li>
<li><a class="reference internal" href="#multivector-derivatives">Multivector Derivatives</a></li>
<li><a class="reference internal" href="#vector-manifolds">Vector Manifolds</a></li>
<li><a class="reference internal" href="#standard-printing">Standard Printing</a></li>
<li><a class="reference internal" href="#latex-printing">Latex Printing</a></li>
<li><a class="reference internal" href="#printer-redirection">Printer Redirection</a></li>
<li><a class="reference internal" href="#other-printing-functions">Other Printing Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#algebra">Algebra</a><ul>
<li><a class="reference internal" href="#bac-cab-formulas">BAC-CAB Formulas</a></li>
<li><a class="reference internal" href="#reciprocal-frame">Reciprocal Frame</a></li>
<li><a class="reference internal" href="#lorentz-transformation">Lorentz-Transformation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#calculus">Calculus</a><ul>
<li><a class="reference internal" href="#derivatives-in-spherical-coordinates">Derivatives in Spherical Coordinates</a></li>
<li><a class="reference internal" href="#maxwell-s-equations">Maxwell&#8217;s Equations</a></li>
<li><a class="reference internal" href="#dirac-equation">Dirac Equation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Geometric Algebra Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="manifold.html"
                        title="next chapter">Manifold for Geometric Algebra</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/modules/galgebra/ga.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="manifold.html" title="Manifold for Geometric Algebra"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Geometric Algebra Module"
             >previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" >SymPy Modules Reference</a> &raquo;</li>
          <li><a href="index.html" >Geometric Algebra Module</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Aug 04, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>