from sympy.matrices.matrices import MatrixBase
from sympy.core import Basic
from sympy.matrices import zeros, Matrix, eye, ones
from sympy.core.sympify import _sympify

class Standard_Cartan(Basic):
    """
    Semi-Concrete base class for Cartan types such as A4, etc. In this module we make
    certain choices about how to represent the algebra.  This class is never meant to be
    called directly. It is exported as `CartanType` and should be called that way.

    Examples
    ========
    >>> from sympy.liealgebras import CartanType
    >>> CartanType("G2")
    TypeG('G', 2)

    Sources
    =======
    - https://inspirehep.net/literature/181168
    - https://www.researchgate.net/publication/252487471_Group_Theory_A_Physicist's_Survey
    - https://arxiv.org/pdf/1206.6379.pdf
    """

    def __new__(cls, series, n):
        n= _sympify(n)
        return super().__new__(cls, series, n)

    @property
    def rank(self):
        """
        Returns the rank of the Lie algebra
        """
        return self.args[1]

    @property
    def series(self):
        """
        Returns the type of the Lie algebra
        """
        return self.args[0]

    def cartan_matrix(self):
        r"""
        Returns the Cartan Matrix for the algebra. For a
        given simple Lie algebra the elements $a_{ij}$ can be
        generated by

        .. math::
            a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle

        where $a_i$ is the i'th simple root and $\langle,\rangle$ is the scalar product.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Cartan_matrix
        - https://mathworld.wolfram.com/CartanMatrix.html

        """
        r = self.rank
        cartan_matrix = zeros(r,r)
        for i, sr_i in enumerate(self.simple_roots()):
            for j, sr_j in enumerate(self.simple_roots()):
                cartan_matrix[j,i] = 2 * sr_i.dot(sr_j) / sr_i.dot(sr_i)
        return cartan_matrix

    def cocartan_matrix(self):
        r"""
        Returns the Cocartan matrix. The Cocartan matrix
        row elements, $c_i$, are built from covectors of simple roots, $\alpha_i$.

        .. math::
            c_i = 2 \alpha_i / \langle \alpha_i, \alpha_i \rangle

        This relationship is helpful in defining the orthogonal base where
        multiplying by some weight, $w_j$, yields the unit matrix.

        .. math::
            \langle c_i, w_j \rangle = \delta_{ij}

        """
        return Matrix([
                2 * x / x.dot(x) for x in self.simple_roots()])

    def omega_matrix(self):
        """
        Returns the omega matrix whose rows are built from
        the fundamental weights of the algebra in the orthogonal
        basis.
        """

        return self.cocartan_matrix().pinv().T

    def simple_root(self, i):
        """
        Returns the i'th simple root in the orthogonal basis.
        """
        raise NotImplementedError("Do not call this method directly from the base class.")


    def simple_roots(self) -> list:
        """
        Returns the simple roots of the algebra.
        """
        return [Matrix(self.simple_root(i+1)) for i in range(self.rank)]

    def fundamental_weight(self, i):
        r"""
        Returns the i'th fundamental weight of the algebra in the
        orthogonal basis.

        Note: To match consistency with simple roots, i starts at 1.

        Explanation
        ===========
        The weights of an algebra, lambda, can be
        written as a linear combination of the simple roots, $\alpha_i$.
        The following theorem,

        .. math::
            a_i = 2\langle\lambda, \alpha_i \rangle / \langle\alpha_i, \alpha_i \rangle


        where $a_i$ are the Dynkin labels.  The fundamental weights
        of the algebra are the weights, lambda, with the smallest $a_i >= 0$.
        Note that if $\lambda_i==\alpha_i$, then the Dynkin labels become
        the elements of the Cartan matrix.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Weight_(representation_theory)
        - http://www.math.columbia.edu/~woit/notes11.pdf
        """
        i = i - 1
        return self.omega_matrix().row(i)

    def fundamental_weights(self):
        """
        Returns a list of the fundamental weights in the orthogonal basis
        """
        return [self.fundamental_weight(i) for i in range(self.omega_matrix().rows)]

    def rootsystem(self):
        """Returns the root system of the group ordered from
        highest root to lowest. The roots are found by reflecting
        each simple root about its hyperplane, repeating this procedure
        on each subsequent root generated until no more are found.
        The roots are then weighed and sorted according to weight.

        Note: This is a costly calculation for groups with
        rank > 6, most notably E7 and E8

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> CartanType("A2").rootsystem()
        [Matrix([[1, 0, -1]]),
        Matrix([[0, 1, -1]]),
        Matrix([[1, -1, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[-1, 1, 0]]),
        Matrix([[0, -1, 1]]),
        Matrix([[-1, 0, 1]])]
        """
        s_r = self.simple_roots()
        rank = self.rank

        orbits = set()
        for i in s_r:
            for r in self.orbit(i):
                orbits.add(r)

        zero_roots = [zeros(1, rank)] * rank

        orbits = [i * self.cocartan_matrix().T for i in orbits] + zero_roots


        # rotate back to the orthogonal basis for consistency
        omega_matrix = self.omega_matrix()
        # sort roots by their weight level, then general positive number order (2nd one is )
        sorbits = sorted(orbits, key=lambda x: (-self.root_level(x, "alpha"), tuple(x)))

        return [x * omega_matrix for x in sorbits]

    def roots(self):
        """Returns the number of total roots in the algebra"""
        raise NotImplementedError("Do not call this method directly from the base class.")

    def root_level(self, root, basis='orthogonal'):
        """Returns the root level of the root. The root level is calculated
        by rotating by the omega matrix and then summing the rotated vector.
        The basis argument flags which basis the incoming root or weight is in.
        This class's default basis is 'orthogonal' but when this method is called
        in the rootsystem calculations, the weights are passed via the 'alpha'
        basis.

        Args:
            root (Matrix): A Matrix of shape (1, rank)
            basis (str): Which basis incoming root or weight is in.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> g2 = CartanType("G2")
        >>> rs = g2.rootsystem()
        >>> g2.root_level(rs[0])
        5
        """
        if not hasattr(self, "_cached_r"):
            inverse_cartan = self.cartan_matrix().pinv()
            self._cached_r = inverse_cartan * ones(inverse_cartan.rows, 1)

        r = self._cached_r

        # TODO: Add basis features throughout class
        if basis == 'orthogonal':
            root = root * self.omega_matrix().pinv()

        return (root * r)[0]

    def positive_roots(self):
        """Returns all the postive roots of the algebra.
        """
        n_pos = self.roots() // 2
        return self.rootsystem()[:n_pos]

    def orbit(self, weight, stabilizer=None):
        """
        Returns the orbit of the weight or root by reflecting it
        a plane. A stabilizer may be passed to calculate the orbit using
        the Orbit-Stabilizer theorem.

        Note the stabilizer starts counting simple roots at index 0

        Args:
            weight (Matrix): A Matrix of shape (1, rank)
            stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
            theorem, integer iterable of simple root indexes. Defaults to None.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit
        - https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers

        """
        # Generating the rotation matrices from simple roots
        # to avoid recalculating them each loop
        reflection_matrices = self._reflection_matrices()

        if stabilizer is not None:
            reflection_matrices = [reflection_matrices[i] for i in stabilizer]

        # Fill up master list of reflected roots by
        # continually operating on them until all weights in orbit are found
        master_list = [weight.as_immutable()]
        master_list_hash = set()
        while True:
            # we use this because we can't change master_list during
            # iteration (python rule)
            ref_list = []
            for w in master_list:
                # if we've seen w before, we've also see all its reflections
                if w in master_list_hash:
                    continue
                for refl in reflection_matrices:
                    reflected = w * refl
                    if reflected not in ref_list and reflected not in master_list:
                        ref_list.append(reflected)
                        master_list_hash.add(w)

            # No new reflections have been found
            if len(ref_list) == 0:
                break

            master_list += ref_list
        return master_list

    def _reflection_matrices(self, weight=None):
        """Returns reflection matricies depending on how
        weight is (or isn't) passed.

        - If weight is None, then
        a set of reflection matrices generated from simple roots are
        returned.
        - If weight is type of Matrix then a single matrix
        is returned by rotating the weight.
        - If weight is type of list (implied of MatrixBase) then
        rotations are done on each MatrixBase and returned.
        """
        reflection_matrix = lambda v: (eye(len(v)) - 2 * v.T * v / v.dot(v)).as_immutable()

        # simple_roots generated reflection matrices
        if weight is None:
            return [reflection_matrix(x) for x in self.simple_roots()]

        if isinstance(weight, MatrixBase):
            return reflection_matrix(weight)

        if isinstance(weight,list):
            return [reflection_matrix(x) for x in weight]
