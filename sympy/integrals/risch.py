"""
The Risch Algorithm for transcendental function integration.

The core algorithms for the Risch algorithm are here.  The subproblem algorithms
are in the rde.py and prde.py files for the Risch Differential Equation solver
and the parametric problems solvers, respectively.  Conventions here is that
the base domain is QQ(x), and each differential extension is t1, t2, ..., t.
x is the variable of integration (Dx == 1), D is a list of the derivatives of t1,
t2, ..., t, T is the list of t1, t2, ..., t, t is the outer-most variable of the
differential extension, k is the field Q(x, t1, ..., tn-1), where t == tn.  The
numerator of a fraction is denoted by a and the denominator by d.  If the
fraction is named f, fa == numer(f) and fd == denom(f).  Fractions are returned
as tuples (fa, fd).  d and t are often used to represent the topmost derivation
and extension variable, respectively.  The docstring of a function signifies
whether an argument is in k[t], in which case it will just return a Poly in t,
or in k(t), in which case it will return the fraction (fa, fd). Other variable
names probably come from the names used in Bronstein's book.
"""
from sympy.core.add import Add
from sympy.core.mul import Mul
from sympy.core.symbol import Symbol, Wild
from sympy.core.basic import S, C, sympify
from sympy.core.numbers import Rational
from sympy.core.function import Lambda

from sympy.functions import exp, sin , cos , tan , cot , asin
from sympy.functions import log, sinh, cosh, tanh, coth, asinh

from sympy.functions import sqrt, erf

from sympy.solvers import solve

from sympy.polys import (quo, gcd, lcm, monomials, factor, cancel,
    PolynomialError, Poly, reduced, RootSum)
from sympy.polys.polyroots import root_factors

from sympy.utilities.iterables import make_list

#    from pudb import set_trace; set_trace() # Debugging

class NonElementaryIntegral(Exception):
    """
    Exception used by subroutines within the Risch algorithm to indicate to one
    another that the function being integrated does not have an elementary
    integral in the given differential field.
    """
    # TODO: Rewrite algorithms below to use this (?)
    pass

def gcdex_diophantine(a, b, c):
    """
    Extended Euclidean Algorithm, Diophantine version.

    Given a, b in K[x] and c in (a, b), the ideal generated by a and b,
    return (s, t) such that s*a + t*b = c and either s = 0 or s.degree()
    < b.degree().
    """
    # Extended Euclidean Algorithm (Diophantine Version) pg. 13
    # XXX: This should go in densetools.py.
    # XXX: Bettter name?

    s, g = a.half_gcdex(b)
    q = c.quo(g) # Inexact division means c is not in (a, b)
    s = q*s

    if not s.is_zero and b.degree() >= b.degree():
        q, s = s.div(b)

    t = (c - s*a).quo(b)

    return (s, t)

# TODO: Rewrite to support multiple extensions
def derivation(p, D, x, T, coefficientD=False):
    """
    Computes Dp.

    Given the derivation D with D = d/dx and p is a polynomial in t over
    K(x), return Dp.  If coefficientD is True, it computes the derivation kD
    (kappaD), which is defined as kD(sum(ai*Xi**i, (i, 0, n))) ==
    sum(Dai*Xi**i, (i, 1, n)) (Definition 3.2.2, page 80).  X in this case is T,
    so coefficientD computes the derivative just with respect to x, with the
    elements of T treated as constants.

    x is the base variable in the differential extension, the variable of
    integration.  T is a list of the other variables in the extension.  D is a
    list of the derivatives of each element of t, such that for each D[i] is a
    polynomial in t[i] and a ratinoal function in t[:i].
    """
    px = p.as_poly(x)
    if px is None:
        px = p.as_basic()

    if coefficientD:
        return px.diff(x).as_poly(*T)

    p = Poly(p, *T)
    return sum([d*p.diff(v) for d, v in zip(D, T)]) + px.diff(x).as_poly(*T)

def get_case(d, x, t):
    """
    Returns the type of the derivation d.

    Returns one of {'exp', 'tan', 'base', 'primitive', 'other_linear',
    'other_nonlinear'}.
    """
    if not d.has(t):
        if d.is_one:
            return 'base'
        return 'primitive'
    if d.rem(Poly(t, t)).is_zero:
        return 'exp'
    if d.rem(Poly(1 + t**2, t)).is_zero:
        return 'tan'
    if d.degree(t) > 1:
        return 'other_nonlinear'
    return 'other_linear'

def splitfactor(p, D, x, T, coefficientD=False):
    """
    Splitting factorization.

    Given a derivation D on k[t] and p in k[t], return (p_n, p_s) in
    k[t] x k[t] such that p = p_n*p_s, p_s is special, and each square
    factor of p_n is normal.

    Page. 100
    """
    One = Poly(1, *T, domain=p.get_domain())
    Dp = derivation(p, D, x, T, coefficientD)
    for t in T:
        if p.is_zero:
            continue

        if not p.has_any_symbols(t):
            s = p.as_poly(1/x).gcd(Dp.as_poly(1/x)).as_poly(t)
            n = p.quo(s)
            return (n, s)

        if not Dp.is_zero:
            h = p.gcd(Dp)
            g = p.gcd(p.diff(t))
            s = h.quo(g)

            if s.degree(t) == 0:
                return (p, One)

            q_split = splitfactor(p.quo(s), D, x, T, coefficientD)

            return (q_split[0], q_split[1]*s)
    else:
        return (p, One)

def splitfactor_sqf(p, D, x, T, coefficientD=False):
    """
    Splitting Square-free Factorization

    Given a derivation D on k[t] and p in k[t], returns (N1, ..., Nm)
    and (S1, ..., Sm) in k[t]^m such that p =
    (N1*N2**2*...*Nm**m)*(S1*S2**2*...*Sm**m) is a splitting
    factorization of p and the Ni and Si are square-free and coprime.
    """
    # TODO: This algorithm appears to be faster in every case
    # TODO: Verify this and splitfactor() for multiple extensions
    S = []
    N = []
    p_sqf = p.sqf_list_include()
    if p.is_zero:
        return (((p, 1),), ())

    for pi, i in p_sqf:
        Si = pi.as_poly(1/x, x).gcd(derivation(pi, D, x, T,
            coefficientD).as_poly(1/x, x)).as_poly(*T)
        pi = Poly(pi, *T)
        Si = Poly(Si, *T)
        Ni = pi.quo(Si)
        if not Si.is_one:
            S.append((Si, i))
        if not Ni.is_one:
            N.append((Ni, i))

    return (tuple(N), tuple(S))

def canonical_representation(a, d, D, x, T):
    """
    Canonical Representation.

    Given a derivation D on k[t] and f = a/d in k(t), return (f_p, f_s,
    f_n) in k[t] x k(t) x k(t) such that f = f_p + f_s + f_n is the
    canonical representation of f (f_p is a polynomial, f_s is reduced
    (has a special denominator), and f_n is simple (has a normal
    denominator).
    """
    # Make d monic
    l = Poly(1/d.LC(), *T)
    a, d = a.mul(l), d.mul(l)

    q, r = a.div(d)
    dn, ds = splitfactor(d, D, x, T)

    b, c = gcdex_diophantine(dn, ds, r)

    return (q, (b, ds), (c, dn))

def hermite_reduce(a, d, D, x, T):
    """
    Hermite Reduction - Quadratic version.

    Given a derivation D on k(t) and f = a/d in k(t), returns g, h, r in
    k(t) such that f = Dg + h + r, h is simple, and r is reduced.
    """
    # TODO: Rewrite this using Mack's linear version
    # Make d monic
    l = Poly(1/d.LC(), *T)
    a, d = a.mul(l), d.mul(l)

    fp, fs, fn = canonical_representation(a, d, D, x, T)

    a, d = fn
    l = Poly(1/d.LC(), *T)
    a, d = a.mul(l), d.mul(l)

    d_sqf = d.sqf_list()

    gn = Poly(0, *T)
    gd = Poly(1, *T)

    for v, i in d.sqf_list_include():
        if i < 2:
            continue

        u = d.quo(v**i)
        for j in range(i - 1, 0, -1):
            udv = u*derivation(v, D, x, T)
            b, c = gcdex_diophantine(udv, v, a.mul(Poly(-1/j, *T)))

            gn = gn*v**j + b
            gd = gd*v**j
            a = c.mul(Poly(-j, *T)) - u*derivation(b, D, x, T)

        d = u*v
    q, r = a.div(d)

    gn, gd = gn.cancel(gd, include=True)
    r, d = r.cancel(d, include=True)

    rrn = q + fp + fs[0]
    rrd = fs[1]
    rrn, rrd = rrn.cancel(rrd, include=True)

    return ((gn, gd), (r, d), (rrn, rrd))

def polynomial_reduce(p, D, x, T):
    """
    Polynomial Reduction.

    Given a derivation D on k(t) and p in k[t] where t is a nonlinear
    monomial over k, return q, r in k[t] such that p = Dq  + r, and
    deg(r) < deg_t(Dt).
    """
    t = T[-1]
    d = D[-1]
    q = Poly(0, *T)
    while p.degree(t) >= d.degree(t):
        m = p.degree(t) - d.degree(t) + 1
        q0 = Poly(t**m, *T).mul(Poly(p.as_poly(t).LC()/(m*d.as_poly(t).LC()), *T))
        q += q0
        p = p - derivation(q0, D, x, T)

    return (q, p)

def residue_reduce(a, d, D, x, T, z=None, invert=True):
    """
    Lazard-Rioboo-Rothstein-Trager resultant reduction.

    Given a derivation D on k(t) and f in k(t) simple, return g
    elementary over k(t) and a Boolean b in {True, False} such that f -
    Dg in k[t] if b == True or f + h and f + h - Dg do not have an
    elementary integral over k(t) for any h in k<t> (reduced) if b ==
    False.

    Returns (G, b), where G is a tuple of tuples of the form (s_i, S_i),
    such that g = Add(*[RootSum(s_i, lambda z: z*log(S_i(z, t))) for
    S_i, s_i in G]). f - Dg is the remaining integral, which is
    elementary if and only if b == True, and hence the integral of f is
    elementary if and only if b == True.

    f - Dg is not calculated in this function because that would require
    explicitly calculating the RootSum.  Use
    residue_reduce_derivation().
    """
    # If r = residue_reduce(...), then the logarithmic part is given by:
    # sum([RootSum(a[0].as_poly(z), lambda i: i*log(a[1].as_basic()).subs(z,
    # i)).subs(t, log(x)) for a in r[0]])
    a, d = a.cancel(d, include=True)
    if a.is_zero:
        return ([], True)

    p, a = a.div(d)
    t = T[-1]
    z = z or Symbol('z', dummy=True)
    Tz = T + [z]

    pz = Poly(z, *Tz)

    Dd = derivation(d, D, x, T)
    q = a - pz*Dd

    if Dd.degree(t) <= d.degree(t):
        r, R = d.resultant(q, includePRS=True)
    else:
        r, R = q.resultant(d, includePRS=True)

    Np, Sp = splitfactor_sqf(r, D, x, T, coefficientD=True)
    H = []

    for s, i in Sp:
        if i == d.degree(t):
            s = Poly(s, z).monic()
            H.append((s, d))
        else:
            h = R[-i - 1]
            h_lc = Poly(h.as_poly(t).LC(), *T, field=True)

            h_lc_sqf = h_lc.sqf_list_include(all=True)

            for a, j in h_lc_sqf:
                h = Poly(h, t, field=True).quo(Poly(gcd(a, s**j, x, 1/x), *T))

            s = Poly(s, z).monic()

            if invert:
                h_lc = Poly(h.as_poly(t).LC(), *T, field=True)
                inv, coeffs = h_lc.as_poly(z, field=True).invert(s), [S(1)]

                for coeff in h.coeffs()[1:]:
                    L = reduced(inv*coeff, [s])[1]
                    coeffs.append(L.as_basic())

                h = Poly(dict(zip(h.monoms(), coeffs)), *T)

            H.append((s, h))

    b = all([not cancel(i.as_basic()).has_any_symbols(*Tz) for i, _ in Np])

    return (H, b)

def residue_reduce_to_basic(H, x, T, z, Tfuncs):
    """
    Converts the tuple returned by residue_reduce() into a Basic expression.
    """
    # TODO: check what Lambda does with RootOf
    i = Symbol('i', dummy=True)
    return sum((RootSum(a[0].as_poly(z), Lambda(i, i*log(a[1].as_basic()).subs(
        {z: i}).subs(zip(T, [f(x) for f in Tfuncs])))) for a in H))

def residue_reduce_derivation(H, D, x, T, z):
    """
    Computes the derivation of an expression returned by residue_reduce().

    In general, this is a rational function in t, so this returns an
    as_basic() result.
    """
    # TODO: verify that this is correct for multiple extensions
    i = Symbol('i', dummy=True)
    return S(sum((RootSum(a[0].as_poly(z), Lambda(i, i*derivation(a[1], D, x,
        T).as_basic().subs(z, i)/a[1].as_basic().subs(z, i))) for a in H)))

def integrate_hypertangent_polynomial(p, D, x, T):
    """
    Integration of hypertangent polynomials.

    Given a differential field k such that sqrt(-1) is not in k, a
    hypertangent monomial t over k, and p in k[t], return q in k[t] and
    c in k such that p - Dq - c*D(t**2 + 1)/(t**1 + 1) is in k and p -
    Dq does not have an elementary integral over k(t) if Dc != 0.
    """
    # XXX: Make sure that sqrt(-1) is not in k.
    t = T[-1]
    q, r = polynomial_reduce(p, D, x, T)
    a = derivation(t, D, x, T).quo(Poly(t**2 + 1, *T))
    c = Poly(r.nth(1)/(2*a.as_basic()), *T)
    return (q, c)

def integrate_nonlinear_no_specials(a, d, D, x, T, Tfuncs):
    """
    Integration of nonlinear monomials with no specials.

    Given a nonlinear monomial t over k such that Sirr = p in k[t] such
    that p is special, monic, and irreducible} is empty, and f in k(t),
    returns g elementary over k(t) and a Boolean b in {True, False} such
    that f - Dg is in k if b == True, or f - Dg does not have an
    elementary integral over k(t) if b == False.

    This function returns a Basic expression.
    """
    t = T[-1]
    z = Symbol('z', dummy=True)
    g1, h, r = hermite_reduce(a, d, D, x, T)
    g2, b = residue_reduce(h[0], h[1], D, x, T, z=z)
    if not b:
        return ((g1[0].as_basic()/g2[1].as_basic()).subs(zip(T, [f(x) for x in
            Tfuncs])) + residue_reduce_to_basic(g2, t, z, tfunc))

    # Because f has no specials, this should be a polynomial in t, or else
    # there is a bug.
    p = cancel(h[0].as_basic()/h[1].as_basic() - residue_reduce_derivation(g2,
        D, x, T, z).as_basic() + r[0].as_basic()/r[1].as_basic()).as_poly(*T)
    q1, q2 = polynomial_reduce(p, D, x, T)

    if q2.has(t):
        b = False
    else:
        b = True
    ret = cancel(g1[0].as_basic()/g1[1].as_basic() + q1.as_basic()).subs(zip(T,
        [f(x) for f in Tfuncs])) + residue_reduce_to_basic(g2, x, T, z, Tfuncs)
    return (ret, b)
