from sympy.core.add import Add
from sympy.core.mul import Mul
from sympy.core.symbol import Symbol, Wild
from sympy.core.basic import S, C, sympify
from sympy.core.numbers import Rational

from sympy.functions import exp, sin , cos , tan , cot , asin
from sympy.functions import log, sinh, cosh, tanh, coth, asinh

from sympy.functions import sqrt, erf

from sympy.solvers import solve

from sympy.polys import (quo, gcd, lcm, monomials, factor, cancel,
    PolynomialError, Poly, reduced, RootSum)
from sympy.polys.polyroots import root_factors

from sympy.utilities.iterables import make_list


#Zero = Poly(0, *V)

#One = Poly(1, *V)

#    from pudb import set_trace; set_trace() # Debugging

class NonElementaryIntegral(Exception):
    """
    Exception used by subroutines within the Risch algorithm to indicate to one
    another that the function being integrated does not have an elementary
    integral in the given differential field.
    """
    # TODO: Rewrite algorithms below to use this (?)
    pass

def gcdex_diophantine(a, b, c):
    """
    Extended Euclidean Algorithm, Diophantine version.

    Given a, b in K[x] and c in (a, b), the ideal generated by a and b,
    return (s, t) such that s*a + t*b = c and either s = 0 or s.degree()
    < b.degree().
    """
    # Extended Euclidean Algorithm (Diophantine Version) pg. 13
    # XXX: This go in densetools.py
    # XXX: Bettter name?

    s, g = a.half_gcdex(b)
    q = c.quo(g) # Inexact division means c is not in (a, b)
    s = q*s

    if not s.is_zero and b.degree() >= b.degree():
        q, r = s.div(b)
        s = r

    t = (c - s*a).quo(b)

    return (s, t)

def derivation(p, D, x, t, coefficientD=False):
    """
    Computes Dp.

    Given the derivation D with D = d/dx and p is a polynomial in t over
    K(x).  If coefficientD is True, it computes the derivation kD
    (kappaD), which is defined as kD(sum(ai*Xi**i, (i, 0, n))) ==
    sum(Dai*Xi**i, (i, 1, n)) (Definition 3.2.2, page 80).
    """
    px = p.as_poly(x)
    if px is None:
        px = p.as_basic()

    if coefficientD:
        return px.diff(x).as_poly(t)
    return p.diff(t)*D + px.diff(x).as_poly(t)

def get_case(D, x, t):
    """
    Returns the type of the derivation D.

    Returns one of {'exp', 'tan', 'primitive', 'other_linear',
    'other_nonlinear'}.
    This implementation does not yet consider the tower of differential
    extensions that may lie below the current extension.
    """
    if not D.has(t):
        return 'primitive'
    if D.rem(Poly(t, t)).is_zero:
        return 'exp'
    if D.rem(Poly(1 + t**2, t)).is_zero:
        return 'tan'
    if D.degree(t) > 1:
        return 'other_nonlinear'
    return 'other_linear'

def splitfactor(p, D, x, t, coefficientD=False):
    """
    Splitting factorization.

    Given a derivation D on k[t] and p in k[t], return (p_n, p_s) in
    k[t] x k[t] such that p = p_n*p_s, p_s is special, and each square
    factor of p_n is normal.

    Page. 100
    """
    One = Poly(1, t, domain=p.get_domain())
    Dp = derivation(p, D, x, t, coefficientD)
    if not p.has_any_symbols(t):
        s = p.as_poly(1/x).gcd(Dp.as_poly(1/x)).as_poly(t)
        n = p.quo(s)
        return (n, s)

    if not Dp.is_zero:
        h = p.gcd(Dp)
        g = p.gcd(p.diff(t))
        s = h.quo(g)

        if s.degree(t) == 0:
            return (p, One)

        q_split = splitfactor(p.quo(s), D, x, t, coefficientD)

        return (q_split[0], q_split[1]*s)
    else:
        return (p, One)

def splitfactor_sqf(p, D, x, t, coefficientD=False):
    """
    Splitting Square-free Factorization

    Given a derivation D on k[t] and p in k[t], returns (N1, ..., Nm)
    and (S1, ..., Sm) in k[t]^m such that p =
    (N1*N2**2*...*Nm**m)*(S1*S2**2*...*Sm**m) is a splitting
    factorization of p and the Ni and Si are square-free and coprime.
    """
    # TODO: This algorithm appears to be faster in every case
    S = []
    N = []
    p_sqf = p.sqf_list_include()
    for pi, i in p_sqf:
        Si = pi.as_poly(1/x, x).gcd(derivation(pi, D, x, t,
            coefficientD).as_poly(1/x, x)).as_poly(t)
        pi = Poly(pi, t)
        Si = Poly(Si, t)
        Ni = pi.quo(Si)
        if not Si.is_one:
            S.append((Si, i))
        if not Ni.is_one:
            N.append((Ni, i))

    return (tuple(N), tuple(S))

def canonical_representation(a, d, D, x, t):
    """
    Canonical Representation.

    Given a derivation D on k[t] and f = a/d in k(t), return (f_p, f_s,
    f_n) in k[t] x k(t) x k(t) such that f = f_p + f_s + f_n is the
    canonical representation of f (f_p is a polynomial, f_s is reduced
    (has a special denominator), and f_n is simple (has a normal
    denominator).
    """
    # Make d monic
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    q, r = a.div(d)
    dn, ds = splitfactor(d, D, x, t)

    b, c = gcdex_diophantine(dn, ds, r)

    return (q, (b, ds), (c, dn))

def hermite_reduce(a, d, D, x, t):
    """
    Hermite Reduction - Quadratic version.

    Given a derivation D on k(t) and f = a/d in k(t), returns g, h, r in
    k(t) such that f = Dg + h + r, h is simple, and r is reduced.
    """
    # TODO: Rewrite this using Mack's linear version
    # Make d monic
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    fp, fs, fn = canonical_representation(a, d, D, x, t)

    a, d = fn
    l = Poly(1/d.LC(), t)
    a, d = a.mul(l), d.mul(l)

    d_sqf = d.sqf_list()

    gn = Poly(0, t)
    gd = Poly(1, t)

    for v, i in d.sqf_list_include():
        if i < 2:
            continue

        u = d.quo(v**i)
        for j in range(i - 1, 0, -1):
            udv = u*derivation(v, D, x, t)
            b, c = gcdex_diophantine(udv, v, a.mul(Poly(-1/j, t)))

            gn = gn*v**j + b
            gd = gd*v**j
            a = c.mul(Poly(-j, t)) - u*derivation(b, D, x, t)

        d = u*v
    q, r = a.div(d)

    # TODO: review the proof to see if this is necessary
    gn, gd = gn.cancel(gd, include=True)

    rrn = q + fp + fs[0]
    rrd = fs[1]
    rrn, rrd = rrn.cancel(rrd, include=True)

    return ((gn, gd), (r, d), (rrn, rrd))

def polynomial_reduce(p, D, x, t):
    """
    Polynomial Reduction.

    Given a derivation D on k(t) and p in k[t] where t is a nonlinear
    monomial over k, return q, r in k[t] such that p = Dq  + r, and
    deg(r) < deg_t(Dt).
    """
    q = Poly(0, t)
    while p.degree(t) >= D.degree(t):
        m = p.degree(t) - D.degree(t) + 1
        q0 = Poly(t**m, t).mul(Poly(p.as_poly(t).LC()/(m*D.as_poly(t).LC()), t))
        q += q0
        p = p - derivation(q0, D, x, t)

    return (q, p)

def residue_reduce(a, d, D, x, t, z=None, invert=True):
    """
    Lazard-Rioboo-Rothstein-Trager resultant reduction.

    Given a derivation D on k(t) and f in k(t) simple, return g
    elementary over k(t) and a Boolean b in {True, False} such that f -
    Dg in k[t] if b == True or f + h and f + h - Dg do not have an
    elementary integral over k(t) for any h in k<t> (reduced) if b ==
    False.

    Returns (G, b), where G is a tuple of tuples of the form (s_i, S_i),
    such that g = Add(*[RootSum(s_i, lambda z: z*log(S_i(z, t))) for
    S_i, s_i in G]). f - Dg is the remaining integral, which is
    elementary if and only if b == True, and hence the integral of f is
    elementary if and only if b == True.

    f - Dg is not calculated in this function because that would require
    explicitly calculating the RootSum.  Use
    residue_reduce_derivation().
    """
    # If r = residue_reduce(...), then the logarithmic part is given by:
    # sum([RootSum(a[0].as_poly(z), lambda i: i*log(a[1].as_basic()).subs(z,
    # i)).subs(t, log(x)) for a in r[0]])
    if a.is_zero:
        return ([], True)
    p, a = a.div(d)
    z = z or Symbol('z', dummy=True)

    pz = Poly(z, t, z)

    Dd = derivation(d, D, x, t)
    q = a - pz*Dd

    if Dd.degree(t) <= d.degree(t):
        r, R = d.resultant(q, includePRS=True)
    else:
        r, R = q.resultant(d, includePRS=True)

    Np, Sp = splitfactor_sqf(r, D, x, t, coefficientD=True)
    H = []

    for s, i in Sp:
        if i == d.degree(t):
            s = Poly(s, z).monic()
            H.append((s, d))
        else:
            h = R[-i - 1]
            h_lc = Poly(h.as_poly(t).LC(), t, field=True)

            h_lc_sqf = h_lc.sqf_list_include(all=True)

            for a, j in h_lc_sqf:
                h = h.as_poly(t).quo(Poly(gcd(a, s**j, x, 1/x), t))

            s = Poly(s, z).monic()

            if invert:
                h_lc = Poly(h.as_poly(t).LC(), t, field=True)
                inv, coeffs = h_lc.as_poly(z, field=True).invert(s), [S(1)]

                for coeff in h.coeffs()[1:]:
                    T = reduced(inv*coeff, [s])[1]
                    coeffs.append(T.as_basic())

                h = Poly(dict(zip(h.monoms(), coeffs)), t)

            H.append((s, h))

    b = all([not cancel(i.as_basic()).has_any_symbols(t, z) for i, _ in Np])

    return (H, b)

def residue_reduce_to_basic(H, x, t, z, tfunc):
    """
    Converts the tuple returned by residue_reduce() into a Basic expression.
    """
    return sum([RootSum(a[0].as_poly(z), lambda i:
        i*log(a[1].as_basic()).subs(z, i)).subs(t, tfunc(x)) for a in H])

def residue_reduce_derivation(H, D, x, t, z):
    """
    Computes the derivation of an expression returned by residue_reduce().

    In general, this is a rational function in t, so this returns an
    as_basic() result.
    """
    return S(sum((RootSum(a[0].as_poly(z), lambda i: i*derivation(a[1], D, x,
        t).as_basic().subs(z, i)/a[1].as_basic().subs(z, i)) for a in H)))

def integrate_hypertangent_polynomial(p, D, x, t):
    """
    Integration of hypertangent polynomials.

    Given a differential field k such that sqrt(-1) is not in k, a
    hypertangent monomial t over k, and p in k[t], return q in k[t] and
    c in k such that p - Dq - c*D(t**2 + 1)/(t**1 + 1) is in k and p -
    Dq does not have an elementary integral over k(t) if Dc != 0.
    """
    # XXX: Make sure that sqrt(-1) is not in k.
    q, r = polynomial_reduce(p, D, x, t)
    a = derivation(t, D, x, t).quo(Poly(t**2 + 1, t))
    c = Poly(r.nth(1)/(2*a.as_basic()), t)
    return (q, c)

def integrate_nonlinear_no_specials(a, d, D, x, t, tfunc):
    """
    Integration of nonlinear monomials with no specials.

    Given a nonlinear monomial t over k such that Sirr = p in k[t] such
    that p is special, monic, and irreducible} is empty, and f in k(t),
    returns g elementary over k(t) and a Boolean b in {True, False} such
    that f - Dg is in k if b == True, or f - Dg does not have an
    elementary integral over k(t) if b == False.

    This function returns a Basic expression.
    """
    z = Symbol('z', dummy=True)
    g1, h, r = hermite_reduce(a, d, D, x, t)
    g2, b = residue_reduce(h[0], h[1], D, x, t, z=z)
    if not b:
        return ((g1[0].as_basic()/g2[1].as_basic()).subs(t, tfunc(x)) +
                residue_reduce_to_basic(g2, t, z, tfunc))

    # This should be a polynomial in t, or else there is a bug.
    p = cancel(h[0].as_basic()/h[1].as_basic() - residue_reduce_derivation(g2,
        D, x, t, z).as_basic() + r[0].as_basic()/r[1].as_basic()).as_poly(t)
    q1, q2 = polynomial_reduce(p, D, x, t)

    if q2.has(t):
        b = False
    else:
        b = True
    ret = cancel(g1[0].as_basic()/g1[1].as_basic() + q1.as_basic()).subs(t,
        tfunc(x)) + residue_reduce_to_basic(g2, x, t, z, tfunc)
    return (ret, b)
